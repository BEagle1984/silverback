<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>

  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Producing Messages | Silverback </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Producing Messages | Silverback ">
    <meta name="generator" content="docfx ">
  

    <link rel="apple-touch-icon" sizes="180x180" href="../../../images/icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="../../../images/icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="../../../images/icons/favicon-16x16.png">
    <link rel="manifest" href="../../../images/icons/site.webmanifest">
    <link rel="mask-icon" href="../../../images/icons/safari-pinned-tab.svg" color="#5bbad5">

    <link rel="stylesheet" href="../../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../../styles/docfx.css">
    <link rel="stylesheet" href="../../../styles/main.css">
    <meta property="docfx:navrel" content="../../../toc.html">
    <meta property="docfx:tocrel" content="../../toc.html">
  
  <meta property="docfx:rel" content="../../../">
  
    <script src="https://kit.fontawesome.com/e3306be642.js" crossorigin="anonymous"></script>
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>

        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>

              <a class="navbar-brand" href="../../../index.html">
                <img id="logo" class="svg" src="../../../images/logo.png" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>

        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div class="container body-content">

        <div id="search-results">
          <div class="search-list"></div>
          <div class="sr-items">
            <p><i class="glyphicon glyphicon-refresh index-loading"></i></p>
          </div>
          <ul id="pagination"></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">

        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="producing">
<h1 id="producing-messages">Producing Messages</h1>

<p>The integration with message brokers is based on the concept of producers and consumers. Producers are responsible for sending messages to the broker, while consumers receive and process them. This guide focuses on the producing side.</p>
<h2 id="producer-configuration">Producer Configuration</h2>
<p>Silverback provides a fluent API to configure the producer settings. The following example demonstrates how to set up a basic Kafka and MQTT producer.</p>
<div class="tabGroup" id="tabgroup_1">
<ul role="tablist">
<li role="presentation">
<a href="#tabpanel_1_kafka" role="tab" aria-controls="tabpanel_1_kafka" data-tab="kafka" tabindex="0" aria-selected="true">Kafka</a>
</li>
<li role="presentation">
<a href="#tabpanel_1_mqtt" role="tab" aria-controls="tabpanel_1_mqtt" data-tab="mqtt" tabindex="-1">MQTT</a>
</li>
</ul>
<section id="tabpanel_1_kafka" role="tabpanel" data-tab="kafka">

<pre><code class="lang-csharp">services.AddSilverback()
    .WithConnectionToMessageBroker(options =&gt; options.AddKafka())
    .AddKafkaClients(clients =&gt; clients
        .WithBootstrapServers(&quot;PLAINTEXT://localhost:9092&quot;)
        .AddProducer(&quot;producer1&quot;, producer =&gt; producer
            .Produce&lt;MyMessage&gt;(&quot;endpoint1&quot;, endpoint =&gt; endpoint
                .ProduceTo(&quot;my-topic&quot;))));
</code></pre>
</section>
<section id="tabpanel_1_mqtt" role="tabpanel" data-tab="mqtt" aria-hidden="true" hidden="hidden">

<pre><code class="lang-csharp">services.AddSilverback()
    .WithConnectionToMessageBroker(options =&gt; options.AddMqtt())
    .AddMqttClients(clients =&gt; clients
        .ConnectViaTcp(&quot;localhost&quot;)
        .AddClient(&quot;my-client&quot;, client =&gt; client
            .WithClientId(&quot;client1&quot;)
            .Produce&lt;MyMessage&gt;(&quot;endpoint1&quot;, endpoint =&gt; endpoint
                .ProduceTo(&quot;messages/my&quot;)
                .WithAtLeastOnceQoS());
</code></pre>
</section>
</div>

<p>The <code>AddProducer</code> or <code>AddClient</code> method is used to configure the producer. The <code>Produce&lt;TMessage&gt;</code> method is used to wire up the producer for a specific message type. The <code>ProduceTo</code> method specifies the topic to which the messages should be sent.</p>
<p>Each <code>AddProducer</code> call will result in a producer to be created. The <code>Produce&lt;TMessage&gt;</code> method can be called multiple times to configure multiple message types for the same producer, each with its own settings, and leading to optimized resource usage and sometimes overall performance in comparison to using a dedicated producer for each message type.</p>
<div class="NOTE">
<h5>Note</h5>
<p>While Kafka producers and consumers are different entities, MQTT clients are used for both producing and consuming messages.</p>
</div>
<div class="TIP">
<h5>Tip</h5>
<p>Assigning a name to the producer or client and its endpoints is optional but can be useful for logging and debugging purposes, as well as for direct access to the producer or client instance for advanced scenarios. Furthermore, it allows you to ensure that each client and endpoint is only configured once, even if you duplicate the declaration (for example if needed in multiple feature slices).</p>
</div>
<div class="TIP">
<h5>Tip</h5>
<p>For a more in-depth documentation about the configuration of the underlying libraries refer to the <a href="https://docs.confluent.io/current/clients/confluent-kafka-dotnet/api/Confluent.Kafka.html">confluent-kafka-dotnet documentation</a> and [MQTTNet documentation](<a href="https://github.com/chkr1011/MQTTnet/wiki">MQTTNet documentation</a> respectively.</p>
</div>
<h2 id="producing-messages-1">Producing Messages</h2>
<p>Once the producer is configured, you can use the <code>IPublisher</code> to send messages through the mediator and Silverback will take care of routing them to the appropriate producer.</p>
<pre><code class="lang-csharp">await _publisher.PublishAsync(new MyMessage { ... });
</code></pre>
<h3 id="wrapandpublish">WrapAndPublish</h3>
<p>The <code>WrapAndPublish</code> and <code>WrapAndPublishAsync</code> methods can be used to wrap the message in an envelope and add additional metadata, such as headers.</p>
<pre><code class="lang-csharp">await _publisher.WrapAndPublishAsync(
    new MyMessage { ... },
    envelope =&gt; envelope
        .AddHeader(&quot;x-priority&quot;, 1))
        .AddHeader(&quot;x-random&quot;, Random.Shared.Next()));
</code></pre>
<h3 id="wrapandpublishbatch">WrapAndPublishBatch</h3>
<p>The <code>WrapAndPublishBatch</code> and <code>WrapAndPublishBatchAsync</code> methods can be used to publish multiple messages in a single batch, leveraging the batching capabilities of Kafka for a much greater throughput (see <a class="xref" href="../../../peformance.html">benchmarks</a>).</p>
<pre><code class="lang-csharp">public async Task PublishBatch(IEnumerable&lt;MyMessage&gt; messages)
{
    await _publisher.WrapAndPublishBatchAsync(
        messages,
        envelope =&gt; envelope
            .AddHeader(&quot;x-priority&quot;, 1))
            .AddHeader(&quot;x-random&quot;, Random.Shared.Next()));
}
</code></pre>
<p>Some overloads allow you to specify a mapping function, so that you can use a streaming source and build the message models on-the-fly before they are wrapped.</p>
<pre><code class="lang-csharp">public async Task PublishBatch(IAsyncEnumerable&lt;Order&gt; orderEntities)
{
    await _publisher.WrapAndPublishBatchAsync(
        orderEntities,
        orderEntity =&gt; new OrderReceived { OrderNumer = orderEntity.Number },
        (envelope, orderEntity) =&gt; envelope
            .AddHeader(&quot;x-priority&quot;, orderEntity.Priority)));
}
</code></pre>
<h2 id="routing">Routing</h2>
<p>The <code>Produce&lt;TMessage&gt;</code> method is used to configure the specified message type to be routed through the producer. The <code>ProduceTo</code> method specifies the topic to which the messages should be sent. Each endpoint can be configured with additional settings, such as specific headers or message properties, or a different serialization strategy.</p>
<figure>
	<a href="../../../images/diagrams/outbound-routing.png"><img src="../../../images/diagrams/outbound-routing.png"></a>
    <figcaption>The messages are dynamically routed to the appropriate endpoint.</figcaption>
</figure>
<p>By default, Silverback routes the messages based on the message type. However, you can also implement custom routing logic.</p>
<div class="NOTE">
<h5>Note</h5>
<p>Messages published and routed to a producer cannot be subscribed to locally (within the same process) unless the endpoint is explicitly configured with the <code>EnableSubscribing</code> method. However, you can still subscribe to the <a class="xref" href="../../../api/Silverback.Messaging.Messages.IOutboundEnvelope-1.html">IOutboundEnvelope&lt;TMessage&gt;</a> without <code>EnableSubscribing</code>.</p>
</div>
<h3 id="routing-function">Routing Function</h3>
<p>A routing function can be used to determine the endpoint based on the message content or metadata (via <a class="xref" href="../../../api/Silverback.Messaging.Messages.IOutboundEnvelope-1.html">IOutboundEnvelope&lt;TMessage&gt;</a>). The function is called for each message and should return the destination topic name.</p>
<div class="tabGroup" id="tabgroup_2">
<ul role="tablist">
<li role="presentation">
<a href="#tabpanel_2_kafka" role="tab" aria-controls="tabpanel_2_kafka" data-tab="kafka" tabindex="0" aria-selected="true">Kafka</a>
</li>
<li role="presentation">
<a href="#tabpanel_2_mqtt" role="tab" aria-controls="tabpanel_2_mqtt" data-tab="mqtt" tabindex="-1">MQTT</a>
</li>
</ul>
<section id="tabpanel_2_kafka" role="tabpanel" data-tab="kafka">

<pre><code class="lang-csharp">services.AddSilverback()
    .WithConnectionToMessageBroker(options =&gt; options.AddKafka())
    .AddKafkaClients(clients =&gt; clients
        .WithBootstrapServers(...)
        .AddProducer(producer =&gt; producer
            .Produce&lt;MyMessage&gt;(endpoint =&gt; endpoint
                .ProduceTo(envelope =&gt; envelope.Headers.GetValue&lt;int&gt;(&quot;x-random&quot;) % 2 == 0 ? &quot;my-even&quot; : &quot;my-odd&quot;))));
</code></pre>
</section>
<section id="tabpanel_2_mqtt" role="tabpanel" data-tab="mqtt" aria-hidden="true" hidden="hidden">

<pre><code class="lang-csharp">services.AddSilverback()
    .WithConnectionToMessageBroker(options =&gt; options.AddMqtt())
    .AddMqttClients(clients =&gt; clients
        .ConnectViaTcp(...)
        .AddClient(client =&gt; client
            .WithClientId(&quot;my.client&quot;)
            .Produce&lt;MyMessage&gt;(endpoint =&gt; endpoint
                .ProduceTo(envelope =&gt; envelope.Headers.GetValue&lt;int&gt;(&quot;x-random&quot;) % 2 == 0 ? &quot;my/even&quot; : &quot;my/odd&quot;)));
</code></pre>
</section>
</div>

<div class="TIP">
<h5>Tip</h5>
<p>Several overloads of the <code>ProduceTo</code> method allow you to specify the routing function based on the bare message or the envelope, giving you access to the message content, its headers and other metadata.
Furthermore, for Kafka you can also specify the partition to produce to.</p>
</div>
<p>You can also use a built-in string format to specify only the variable parts of the topic name.</p>
<div class="tabGroup" id="tabgroup_3">
<ul role="tablist">
<li role="presentation">
<a href="#tabpanel_3_kafka" role="tab" aria-controls="tabpanel_3_kafka" data-tab="kafka" tabindex="0" aria-selected="true">Kafka</a>
</li>
<li role="presentation">
<a href="#tabpanel_3_mqtt" role="tab" aria-controls="tabpanel_3_mqtt" data-tab="mqtt" tabindex="-1">MQTT</a>
</li>
</ul>
<section id="tabpanel_3_kafka" role="tabpanel" data-tab="kafka">

<pre><code class="lang-csharp">services.AddSilverback()
    .WithConnectionToMessageBroker(options =&gt; options.AddKafka())
    .AddKafkaClients(clients =&gt; clients
        .WithBootstrapServers(...)
        .AddProducer(producer =&gt; producer
            .Produce&lt;MyMessage&gt;(endpoint =&gt; endpoint
                .ProduceTo(
                    &quot;my-{0}&quot;,
                    message =&gt; message.Id % 2 == 0 ? [&quot;even&quot;] : [&quot;odd&quot;]))));
</code></pre>
</section>
<section id="tabpanel_3_mqtt" role="tabpanel" data-tab="mqtt" aria-hidden="true" hidden="hidden">

<pre><code class="lang-csharp">services.AddSilverback()
    .WithConnectionToMessageBroker(options =&gt; options.AddMqtt())
    .AddMqttClients(clients =&gt; clients
        .ConnectViaTcp(...)
        .AddClient(client =&gt; client
            .WithClientId(&quot;my.client&quot;)
            .Produce&lt;MyMessage&gt;(endpoint =&gt; endpoint
                .ProduceTo(
                    &quot;my/{0}&quot;,
                    message =&gt; message.Id % 2 == 0 ? [&quot;even&quot;] : [&quot;odd&quot;]))));
</code></pre>
</section>
</div>
<h3 id="resolver-class">Resolver Class</h3>
<p>The custom routing logic can also be implemented in a dedicated endpoint resolver class. The resolver must implement the <a class="xref" href="../../../api/Silverback.Messaging.Producing.EndpointResolvers.IKafkaProducerEndpointResolver-1.html">IKafkaProducerEndpointResolver&lt;TMessage&gt;</a> or <a class="xref" href="../../../api/Silverback.Messaging.Producing.EndpointResolvers.IMqttProducerEndpointResolver-1.html">IMqttProducerEndpointResolver&lt;TMessage&gt;</a> interface and is resolved via the DI container, thus allowing you to inject dependencies.</p>
<div class="tabGroup" id="tabgroup_4">
<ul role="tablist">
<li role="presentation">
<a href="#tabpanel_4_kafka" role="tab" aria-controls="tabpanel_4_kafka" data-tab="kafka" tabindex="0" aria-selected="true">Kafka</a>
</li>
<li role="presentation">
<a href="#tabpanel_4_mqtt" role="tab" aria-controls="tabpanel_4_mqtt" data-tab="mqtt" tabindex="-1">MQTT</a>
</li>
</ul>
<section id="tabpanel_4_kafka" role="tabpanel" data-tab="kafka">

<pre><code class="lang-csharp">services.AddSilverback()
    .WithConnectionToMessageBroker(options =&gt; options.AddKafka())
    .AddKafkaClients(clients =&gt; clients
        .WithBootstrapServers(...)
        .AddProducer(producer =&gt; producer
            .Produce&lt;MyMessage&gt;(endpoint =&gt; endpoint
                .UseEndpointResolver&lt;MyTopicResolver&gt;())));
</code></pre>
</section>
<section id="tabpanel_4_mqtt" role="tabpanel" data-tab="mqtt" aria-hidden="true" hidden="hidden">

<pre><code class="lang-csharp">services.AddSilverback()
    .WithConnectionToMessageBroker(options =&gt; options.AddMqtt())
    .AddMqttClients(clients =&gt; clients
        .ConnectViaTcp(...)
        .AddClient(client =&gt; client
            .WithClientId(&quot;my.client&quot;)
            .Produce&lt;MyMessage&gt;(endpoint =&gt; endpoint
                .UseEndpointResolver&lt;MyTopicResolver&gt;())));
</code></pre>
</section>
</div>
<div class="tabGroup" id="tabgroup_5">
<ul role="tablist">
<li role="presentation">
<a href="#tabpanel_5_kafka" role="tab" aria-controls="tabpanel_5_kafka" data-tab="kafka" tabindex="0" aria-selected="true">Kafka</a>
</li>
<li role="presentation">
<a href="#tabpanel_5_mqtt" role="tab" aria-controls="tabpanel_5_mqtt" data-tab="mqtt" tabindex="-1">MQTT</a>
</li>
</ul>
<section id="tabpanel_5_kafka" role="tabpanel" data-tab="kafka">

<pre><code class="lang-csharp">public class MyTopicResolver : IKafkaProducerEndpointResolver&lt;MyMessage&gt;
{
    public TopicPartition GetTopicPartition(IOutboundEnvelope&lt;MyMessage&gt; envelope)
    {
        return new TopicPartition(
            &quot;my-&quot; + envelope.Message.Priority,
            envelope.Headers.GetValue&lt;int&gt;(&quot;x-random&quot;) % 10);
    }
}
</code></pre>
</section>
<section id="tabpanel_5_mqtt" role="tabpanel" data-tab="mqtt" aria-hidden="true" hidden="hidden">

<pre><code class="lang-csharp">public class MyTopicResolver : IMqttProducerEndpointResolver&lt;MyMessage&gt;
{
    public string GetTopic(IOutboundEnvelope&lt;MyMessage&gt; envelope)
    {
        return &quot;my/&quot; + envelope.Message.Priority;
    }
}
</code></pre>
</section>
</div>
<h3 id="dynamic-routing">Dynamic Routing</h3>
<p>The routing can also be fully dynamic and be delegated to the actual code publishing the message.</p>
<div class="tabGroup" id="tabgroup_6">
<ul role="tablist">
<li role="presentation">
<a href="#tabpanel_6_kafka" role="tab" aria-controls="tabpanel_6_kafka" data-tab="kafka" tabindex="0" aria-selected="true">Kafka</a>
</li>
<li role="presentation">
<a href="#tabpanel_6_mqtt" role="tab" aria-controls="tabpanel_6_mqtt" data-tab="mqtt" tabindex="-1">MQTT</a>
</li>
</ul>
<section id="tabpanel_6_kafka" role="tabpanel" data-tab="kafka">

<pre><code class="lang-csharp">services.AddSilverback()
    .WithConnectionToMessageBroker(options =&gt; options.AddKafka())
    .AddKafkaClients(clients =&gt; clients
        .WithBootstrapServers(...)
        .AddProducer(producer =&gt; producer
            .Produce&lt;MyMessage&gt;(endpoint =&gt; endpoint
                .ProduceToDynamicTopic())));
</code></pre>
</section>
<section id="tabpanel_6_mqtt" role="tabpanel" data-tab="mqtt" aria-hidden="true" hidden="hidden">

<pre><code class="lang-csharp">services.AddSilverback()
    .WithConnectionToMessageBroker(options =&gt; options.AddMqtt())
    .AddMqttClients(clients =&gt; clients
        .ConnectViaTcp(...)
        .AddClient(client =&gt; client
            .WithClientId(&quot;my.client&quot;)
            .Produce&lt;MyMessage&gt;(endpoint =&gt; endpoint
                .ProduceToDynamicTopic())));
</code></pre>
</section>
</div>
<div class="tabGroup" id="tabgroup_7">
<ul role="tablist">
<li role="presentation">
<a href="#tabpanel_7_kafka" role="tab" aria-controls="tabpanel_7_kafka" data-tab="kafka" tabindex="0" aria-selected="true">Kafka</a>
</li>
<li role="presentation">
<a href="#tabpanel_7_mqtt" role="tab" aria-controls="tabpanel_7_mqtt" data-tab="mqtt" tabindex="-1">MQTT</a>
</li>
</ul>
<section id="tabpanel_7_kafka" role="tabpanel" data-tab="kafka">

<pre><code class="lang-csharp">await _publisher.WrapAndPublishAsync(
    new MyMessage { ... },
    envelope =&gt; envelope
        .SetKafkaDestinationTopic(&quot;my-topic&quot;)));
</code></pre>
</section>
<section id="tabpanel_7_mqtt" role="tabpanel" data-tab="mqtt" aria-hidden="true" hidden="hidden">

<pre><code class="lang-csharp">await _publisher.WrapAndPublishAsync(
    new MyMessage { ... },
    envelope =&gt; envelope
        .SetMqttDestinationTopic(&quot;my/topic&quot;)));
</code></pre>
</section>
</div>
<h3 id="kafka-partitioning">Kafka Partitioning</h3>
<p>For Kafka producers, you can also specify the partition to produce to or influence it using a partitioning key. More information can be found in the <a class="xref" href="kafka/partitioning.html">Kafka Key and Partitioning</a> guide.</p>
<h2 id="additional-resources">Additional Resources</h2>
<p>For more information about the producer configuration possibilities refer to the other guides in this section and the <a class="xref" href="../../../api/Silverback.html">API Reference</a>.</p>
</article>
          </div>

          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/beagle1984/silverback/blob/master/docs/guides/broker/producing/basics.md/#L1" class="contribution-link">Improve this doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>

      <footer>
        <div class="footer">
          <div class="container contacts">
            <a href="https://github.com/BEagle1984" rel="nofollow noopener noreferrer"><i class='fab fa-github'></i> GitHub</a>
            <a href="mailto:silverback-project@outlook.com" rel="nofollow noopener noreferrer"><i class='fas fa-envelope'></i> E-Mail</a>
          </div>
          <div class="container">
            <span class="pull-right">
              <a href="#top">&uarr; Back to top</a>
            </span>
      © 2025 Sergio Aquilini
      
          </div>
        </div>
      </footer>
    </div>

    <script type="text/javascript" src="../../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../../styles/main.js"></script>
  </body>
</html>
