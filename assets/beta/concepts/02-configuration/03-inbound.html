<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Inbound Connector | Silverback </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Inbound Connector | Silverback ">
    <meta name="generator" content="docfx 2.56.5.0">
    
  
    <link rel="apple-touch-icon" sizes="180x180" href="../../images/icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="../../images/icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="../../images/icons/favicon-16x16.png">
    <link rel="manifest" href="../../images/icons/site.webmanifest">
    <link rel="mask-icon" href="../../images/icons/safari-pinned-tab.svg" color="#5bbad5">
  
    <link rel="stylesheet" href="../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../styles/docfx.css">
    <link rel="stylesheet" href="../../styles/main.css">
    <meta property="docfx:navrel" content="../../toc.html">
    <meta property="docfx:tocrel" content="../toc.html">
    
    <meta property="docfx:rel" content="../../">
    
    <script src="https://kit.fontawesome.com/e3306be642.js" crossorigin="anonymous"></script>
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../../index.html">
                <img id="logo" class="svg" src="../../images/logo.png" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div class="container body-content">
        
        <div id="search-results">
          <div class="search-list"></div>
          <div class="sr-items">
            <p><i class="glyphicon glyphicon-refresh index-loading"></i></p>
          </div>
          <ul id="pagination"></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="inbound">
<h1 id="inbound-connector">Inbound Connector</h1>

<p>The inbound connector is used to automatically consume a topic/queue and relay the messages to the internal bus.</p>
<div class="NOTE">
<h5>Note</h5>
<p>The inbound connector abstracts the message broker completely and the messages are automatically acknowledged if the subscribers complete without throwing an exception (unless error handling policies are defined and unless batch processing).</p>
</div>
<h2 id="implementations">Implementations</h2>
<p>Multiple implementations are available, offering a variable degree of reliability.</p>
<h3 id="basic">Basic</h3>
<p>The basic <code>InboundConnector</code> is very simple and just forwards the consumed messages to the internal bus. If no exception is thrown, the message is committed and the next one is consumed.</p>
<figure>
	<a href="../../images/diagrams/inbound-basic.png"><img src="../../images/diagrams/inbound-basic.png"></a>
    <figcaption>The messages are consumed directly.</figcaption>
</figure>
<div class="tabGroup" id="tabgroup_CeZOj-G++Q">
<ul role="tablist">
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q_basic-startup" role="tab" aria-controls="tabpanel_CeZOj-G++Q_basic-startup" data-tab="basic-startup" tabindex="0" aria-selected="true">Startup</a>
</li>
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q_basic-configurator" role="tab" aria-controls="tabpanel_CeZOj-G++Q_basic-configurator" data-tab="basic-configurator" tabindex="-1">EndpointsConfigurator</a>
</li>
</ul>
<section id="tabpanel_CeZOj-G++Q_basic-startup" role="tabpanel" data-tab="basic-startup">

<pre><code class="lang-csharp">public class Startup
{
    public void ConfigureServices(IServiceCollection services)
    {
        services
            .AddSilverback()
            .WithConnectionToMessageBroker(options =&gt; options
                .AddKafka())
            .AddEndpointsConfigurator&lt;MyEndpointsConfigurator&gt;();
    }
}
</code></pre>
</section>
<section id="tabpanel_CeZOj-G++Q_basic-configurator" role="tabpanel" data-tab="basic-configurator" aria-hidden="true" hidden="hidden">

<pre><code class="lang-csharp">public class MyEndpointsConfigurator : IEndpointsConfigurator
{
    public void Configure(IEndpointsConfigurationBuilder builder)
    {
        builder
            .AddInbound(
                new KafkaConsumerEndpoint(&quot;basket-events&quot;)
                {
                    ...
                }));
    }
}
</code></pre>
</section>
</div>
<h3 id="exactly-once-processing">Exactly-once processing</h3>
<p>Silverback is able to keep track of the messages that have been consumed in order to guarantee that each message is processed exactly once.</p>
<h4 id="offset-storage">Offset storage</h4>
<p>The <code>DbOffsetStoredInboundConnector</code> will store the offset of the latest processed message (of each topic/partition) into a database table.</p>
<figure>
	<a href="../../images/diagrams/inbound-offsetstore.png"><img src="../../images/diagrams/inbound-offsetstore.png"></a>
    <figcaption>The offsets are being stored to prevent the very same message to be consumed twice.</figcaption>
</figure>
<div class="NOTE">
<h5>Note</h5>
<p>The <code>Silverback.EntityFrameworkCore</code> package is also required and the <code>DbContext</code> must include a <code>DbSet&lt;StoredOffset&gt;</code>. See also the <a class="xref" href="../06-extras/01-dbcontext.html">Sample DbContext (EF Core)</a>.</p>
</div>
<pre><code class="lang-csharp">public class Startup
{
    public void ConfigureServices(IServiceCollection services)
    {
        services
            .AddSilverback()
            .UseDbContext&lt;MyDbContext&gt;()
            .WithConnectionToMessageBroker(options =&gt; options
                .AddKafka()
                .AddDbOffsetStoredInboundConnector())
            .AddEndpointsConfigurator&lt;MyEndpointsConfigurator&gt;();
    }
}
</code></pre>
<h4 id="logged">Logged</h4>
<p>The <code>DbLoggedInboundConnector</code> will store all the processed messages into a database table. This has the double purpose of serving as a log in addition to preventing double processing.</p>
<figure>
	<a href="../../images/diagrams/inbound-log.png"><img src="../../images/diagrams/inbound-log.png"></a>
    <figcaption>The inbound messages are logged to prevent two messages with the same key to be consumed.</figcaption>
</figure>
<div class="NOTE">
<h5>Note</h5>
<p>The <code>Silverback.EntityFrameworkCore</code> package is also required and the <code>DbContext</code> must include a <code>DbSet&lt;InboundMessage&gt;</code>. See also the <a class="xref" href="../06-extras/01-dbcontext.html">Sample DbContext (EF Core)</a>.</p>
</div>
<pre><code class="lang-csharp">public class Startup
{
    public void ConfigureServices(IServiceCollection services)
    {
        services
            .AddSilverback()
            .UseDbContext&lt;MyDbContext&gt;()
            .WithConnectionToMessageBroker(options =&gt; options
                .AddKafka()
                .AddDbLoggedInboundConnector())
            .AddEndpointsConfigurator&lt;MyEndpointsConfigurator&gt;();
    }
}
</code></pre>
<h4 id="custom-store">Custom store</h4>
<p>You can easily implement your own storage for the offsets or the messages, simply creating your own <code>IOffsetStore</code> or <code>IInboundLog</code> and plugging them in.</p>
<pre><code class="lang-csharp">public class Startup
{
    public void ConfigureServices(IServiceCollection services)
    {
        services
            .AddSilverback()
            .WithConnectionToMessageBroker(options =&gt; options
                .AddKafka()
                .AddLoggedInboundConnector&lt;SomeCustomInboundLog&gt;()
                .AddOffsetStoredInboundConnector&lt;SomeCustomOffsetStore&gt;())
            .AddEndpointsConfigurator&lt;MyEndpointsConfigurator&gt;();
    }
}
</code></pre>
<h2 id="error-handling">Error handling</h2>
<p>If an exceptions is thrown by the methods consuming the incoming messages (subscribers) the consumer will stop, unless some error policies are defined.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Policy</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><code>Skip</code></td>
<td style="text-align: left;">This is the simplest policy: just ignore the message and go ahead. Use the <code>LogWithLevel</code> method to specify the log level to be applied the &quot;message skipped&quot; log entry (default is <code>Error</code>).</td>
</tr>
<tr>
<td style="text-align: left;"><code>Retry</code></td>
<td style="text-align: left;">Define how many times and at which interval to retry to process the message. Be aware that this will block the consumer.</td>
</tr>
<tr>
<td style="text-align: left;"><code>Move</code></td>
<td style="text-align: left;">Used to re-publish the message to the specified endpoint, this policy is very flexible and allow quite a few scenarios: move to same topic to retry later on without blocking, move to a retry topic to delay the retry or move to a failed messages topic. The message can also be transformed, to allow adding useful information (e.g. source, error type, etc.) that will allow for better handling while reprocessing.</td>
</tr>
<tr>
<td style="text-align: left;"><code>Chain</code></td>
<td style="text-align: left;">Combine different policies, for example to move the message to a dead letter after some retries.</td>
</tr>
</tbody>
</table>
<pre><code class="lang-csharp">public class MyEndpointsConfigurator : IEndpointsConfigurator
{
    public void Configure(IEndpointsConfigurationBuilder builder)
    {
        builder.AddInbound(
            new KafkaConsumerEndpoint(&quot;some-events&quot;)
            {
                ...
            },
            policy =&gt; policy.Chain(
                policy.Retry().MaxFailedAttempts(3),
                policy.Move(new KafkaProducerEndpoint(&quot;bad-messages&quot;)
                    {
                        ...
                    }
                )));
    }
}
</code></pre>
<div class="IMPORTANT">
<h5>Important</h5>
<p>If the processing still fails after the last policy is applied the inbound connector will return the exception to the consumer, causing it to stop. A <code>Retry</code> (with limited amount of attempts) alone is therefore not recommendend and it should be combined with <code>Skip</code> or <code>Move</code>.</p>
</div>
<h3 id="retries">Retries</h3>
<p><code>Retry</code> and <code>Move</code> policies can be used to retry over and over the same message. Use <code>MaxFailedAttempts</code> to limit the number of attempts.</p>
<pre><code class="lang-csharp">policy.Chain(
    policy.Retry(TimeSpan.FromSeconds(1)).MaxFailedAttempts(3),
    policy.Skip().LogWithLevel(LogLevel.Critical))
</code></pre>
<div class="NOTE">
<h5>Note</h5>
<p>A message can be moved to the same topic to simply be moved to the end of the queue.</p>
</div>
<div class="IMPORTANT">
<h5>Important</h5>
<p>The Retry policy will prevent the message broker to be polled for the entire comulative duration of the attempts and it could lead to timeouts. With Kafka you should for example set the <code>max.poll.interval.ms</code> settings to an higher value.</p>
</div>
<h3 id="apply-rules">Apply rules</h3>
<p>Use <code>ApplyTo</code> and <code>Exclude</code> methods to decide which exceptions must be handled by the error policy or take advantage of  <code>ApplyWhen</code> to specify a custom apply rule.</p>
<pre><code class="lang-csharp">policy.Move(new KafkaProducerEndpoint(&quot;same-endpoint&quot;) { ... })
    .Exclude&lt;MyException&gt;()
    .ApplyWhen((msg, ex) =&gt; msg.Xy == myValue)
</code></pre>
<h3 id="publishing-messages-events">Publishing messages (events)</h3>
<p>Messages can be published when a policy is applied, in order to execute custom code.</p>
<div class="tabGroup" id="tabgroup_CeZOj-G++Q-1">
<ul role="tablist">
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-1_eventhandler-configurator" role="tab" aria-controls="tabpanel_CeZOj-G++Q-1_eventhandler-configurator" data-tab="eventhandler-configurator" tabindex="0" aria-selected="true">EndpointsConfigurator</a>
</li>
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-1_eventhandler" role="tab" aria-controls="tabpanel_CeZOj-G++Q-1_eventhandler" data-tab="eventhandler" tabindex="-1">Event Handler</a>
</li>
</ul>
<section id="tabpanel_CeZOj-G++Q-1_eventhandler-configurator" role="tabpanel" data-tab="eventhandler-configurator">

<pre><code class="lang-csharp">public class MyEndpointsConfigurator : IEndpointsConfigurator
{
    public void Configure(IEndpointsConfigurationBuilder builder)
    {
        builder.AddInbound(
            new KafkaConsumerEndpoint(&quot;some-events&quot;)
            {
                ...
            },
            policy =&gt; policy.Chain(
                policy
                    .Retry(TimeSpan.FromMilliseconds(500))
                    .MaxFailedAttempts(3),
                policy
                    .Skip()
                    .Publish(msg =&gt; new ProcessingFailedEvent(msg))
            ));
    }
}
</code></pre>
</section>
<section id="tabpanel_CeZOj-G++Q-1_eventhandler" role="tabpanel" data-tab="eventhandler" aria-hidden="true" hidden="hidden">

<pre><code class="lang-csharp">public void OnProcessingFailed(ProcessingFailedEvent @event)
{
    _processingStatusService.SetFailed(@event.Message.Id);

    _mailService.SendNotification(&quot;Failed to process message!&quot;);
}
</code></pre>
</section>
</div>
<h2 id="batch-processing">Batch processing</h2>
<p>The inbound connector can be configured to process the messages in batches.</p>
<figure>
	<a href="../../images/diagrams/inbound-batch.png"><img src="../../images/diagrams/inbound-batch.png"></a>
    <figcaption>The messages are processed in batches.</figcaption>
</figure>
<table>
<thead>
<tr>
<th style="text-align: left;">Property</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><code>Batch.Size</code></td>
<td style="text-align: left;">The number of messages to be processed in batch. The default is 1.</td>
</tr>
<tr>
<td style="text-align: left;"><code>Batch.MaxWaitTime</code></td>
<td style="text-align: left;">The maximum amount of time to wait for the batch to be filled. After this time the batch will be processed even if the desired Size is not reached. Set it to <code>TimeSpan.MaxValue</code> to disable this feature. The default is <code>TimeSpan.MaxValue</code>.</td>
</tr>
</tbody>
</table>
<pre><code class="lang-csharp">public class MyEndpointsConfigurator : IEndpointsConfigurator
{
    public void Configure(IEndpointsConfigurationBuilder builder)
    {
        builder.AddInbound(
            new KafkaConsumerEndpoint(&quot;basket-events&quot;)
            {
                ...
            },
            settings: new InboundConnectorSettings
            {
                Batch = new Messaging.Batch.BatchSettings
                {
                    Size = 5,
                    MaxWaitTime = TimeSpan.FromSeconds(5)
                }
            }));
    }
}
</code></pre>
<div class="NOTE">
<h5>Note</h5>
<p>The batch is consider a unit of work: it will be processed in the same DI scope, it will be atomically committed, the error policies will be applied to the batch as a whole and all messages will be acknowledged at once when the batch is successfully processed.</p>
</div>
<p>Some additional events are published to the internal bus when batch processing:</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Event</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><code>BatchStartedEvent</code></td>
<td style="text-align: left;">Fired when the batch has been filled and just before the first message is published. This event can be subscribed to perform some operations before the messages are processed.</td>
</tr>
<tr>
<td style="text-align: left;"><code>BatchCompleteEvent</code></td>
<td style="text-align: left;">Fired when all the messages in a batch have been published.</td>
</tr>
<tr>
<td style="text-align: left;"><code>BatchProcessedEvent</code></td>
<td style="text-align: left;">Fired after all messages have been successfully processed. It can tipically be used to commit the transaction.</td>
</tr>
<tr>
<td style="text-align: left;"><code>BatchAbortedEvent</code></td>
<td style="text-align: left;">Fired when an exception occured during the processing of the batch. It can tipically be used to rollback the transaction.</td>
</tr>
</tbody>
</table>
<p>The usage should be similar to the following examples.</p>
<div class="tabGroup" id="tabgroup_CeZOj-G++Q-2">
<ul role="tablist">
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-2_batch-example1" role="tab" aria-controls="tabpanel_CeZOj-G++Q-2_batch-example1" data-tab="batch-example1" tabindex="0" aria-selected="true">Example 1</a>
</li>
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q-2_batch-example2" role="tab" aria-controls="tabpanel_CeZOj-G++Q-2_batch-example2" data-tab="batch-example2" tabindex="-1">Startup</a>
</li>
</ul>
<section id="tabpanel_CeZOj-G++Q-2_batch-example1" role="tabpanel" data-tab="batch-example1">

<pre><code class="lang-csharp">public class InventoryService
{
    private DbContext _db;

    public InventoryService(MyDbContext db)
    {
        _db = db;
    }

    public void OnBatchStarted(BatchStartedEvent message)
    {
        _logger.LogInformation(
            $&quot;Processing batch '{message.BatchId} &quot; +
            $&quot;({message.BatchSize} messages)&quot;);
    }

    public void OnMessageReceived(InventoryUpdateEvent @event)
    {
        // Process the event (but don't call SaveChanges)
    }

    public async Task OnBatchProcessed(BatchProcessedEvent message)
    {
        // Commit all changes in a single transaction
        await _db.SaveChangesAsync();

        _logger.LogInformation(
            $&quot;Successfully processed batch '{message.BatchId} &quot; +
            $&quot;({message.BatchSize} messages)&quot;);
    }
    
    public void OnBatchAborted(BatchAbortedEvent message)
    {
        _logger.LogError(
            $&quot;An error occurred while processing batch '{message.BatchId} &quot; +
            $&quot;({message.BatchSize} messages)&quot;);
    }
}
</code></pre>
</section>
<section id="tabpanel_CeZOj-G++Q-2_batch-example2" role="tabpanel" data-tab="batch-example2" aria-hidden="true" hidden="hidden">

<pre><code class="lang-csharp">public class InventoryService
{
    private DbContext _db;

    public InventoryService(MyDbContext db)
    {
        _db = db;
    }

    public void OnBatchStarted(BatchStartedEvent message)
    {
    }

    public async Task OnMessageReceived(
        IReadOnlyCollection&lt;InventoryUpdateEvent&gt; events)
    {
        _logger.LogInformation(
            $&quot;Processing {events.Count} messages&quot;);

        // Process all items
        foreach (var event in events)
        {
            ...
        }

        // Commit all changes in a single transaction
        await _db.SaveChangesAsync();

        _logger.LogInformation(
            $&quot;Successfully processed {events.Count} messages&quot;);
    }
}
</code></pre>
</section>
</div>

<div class="NOTE">
<h5>Note</h5>
<p>The method <code>OnMessageReceived</code> could declare an argument of type <code>IReadOnlyCollection&lt;InventoryUpdateEvent&gt;</code> instead of <code>IEnumerable&lt;InventoryUpdateEvent&gt;</code>. (Silverback will in any case always forward a materialized <code>IList</code> of messages, but explicitly declaring the paramter as <a href="https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.ireadonlycollection-1">IReadOnlyCollection<t></t></a> avoids any false positive <em>&quot;possible multiple enumeration of IEnumerable&quot;</em> issue that may be detected by a static code analysis tool.)</p>
</div>
<h2 id="multi-threaded-consuming">Multi-threaded consuming</h2>
<p>Multiple consumers can be created for the same endpoint to consume in parallel in multiple threads (you need multiple partitions in Kafka).</p>
<pre><code class="lang-csharp">public class MyEndpointsConfigurator : IEndpointsConfigurator
{
    public void Configure(IEndpointsConfigurationBuilder builder)
    {
        builder.AddInbound(
            new KafkaConsumerEndpoint(&quot;basket-events&quot;)
            {
                ...
            },
            settings: new InboundConnectorSettings
            {
                Consumers: 2
            }));
    }
}
</code></pre>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/beagle1984/silverback/blob/master/docs/concepts/02-configuration/03-inbound.md/#L1" class="contribution-link">Improve this doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="footer">
          <div class="container contacts">
            <a href="https://github.com/BEagle1984" rel="nofollow noopener noreferrer"><i class='fab fa-github'></i> GitHub</a>
            <a href="mailto:silverback-project@outlook.com" rel="nofollow noopener noreferrer"><i class='fas fa-envelope'></i> E-Mail</a>
          </div>
          <div class="container">
            <span class="pull-right">
              <a href="#top">&uarr; Back to top</a>
            </span>
            © 2020 Sergio Aquilini
            
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../styles/main.js"></script>
  </body>
</html>
