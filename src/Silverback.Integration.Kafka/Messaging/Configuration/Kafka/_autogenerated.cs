// Copyright (c) 2024 Sergio Aquilini
// This code is licensed under MIT license (see LICENSE file for details)

/*******************************************************************************************
  Note: These proxies are generated using Silverback.Tools.KafkaConfigClassGenerator
        located under /tools/
********************************************************************************************/

using System.Diagnostics.CodeAnalysis;
using Confluent.Kafka;

namespace Silverback.Messaging.Configuration.Kafka;

/// <content>
///     The autogenerated part of the <see cref="KafkaClientConfiguration{TClientConfig}" /> class.
/// </content>
[SuppressMessage("StyleCop.CSharp.MaintainabilityRules", "SA1402:File may only contain a single type", Justification = "Autogenerated all at once")]
[SuppressMessage("Design", "CA1044:Properties should not be write only", Justification = "Accessors generated according to wrapped class")]
public partial record KafkaClientConfiguration<TClientConfig>
{
    /// <summary>
    ///     Gets the SASL mechanism to use for authentication. Supported: GSSAPI, PLAIN, SCRAM-SHA-256, SCRAM-SHA-512.
    /// </summary>
    public SaslMechanism? SaslMechanism
    {
        get => ClientConfig.SaslMechanism;
        init => ClientConfig.SaslMechanism = value;
    }

    /// <summary>
    ///     Gets the number of acknowledgements that the leader broker must receive from the in-sync replicas before responding to the request:
    ///     <see cref="Confluent.Kafka.Acks.None" /> (no response/ack is sent to the client), <see cref="Confluent.Kafka.Acks.Leader" /> (the leader will write the record to
    ///     its local log but will respond without awaiting full acknowledgement from all followers, or <see cref="Confluent.Kafka.Acks.All" /> (the broker
    ///     will block until the message is committed by all in-sync replicas. If there are less than <c>min.insync.replicas</c> (broker configuration)
    ///     in the in-sync replicas set the produce request will fail.
    /// </summary>
    public Acks? Acks
    {
        get => ClientConfig.Acks;
        init => ClientConfig.Acks = value;
    }

    /// <summary>
    ///     Gets the client identifier.
    /// </summary>
    public string? ClientId
    {
        get => ClientConfig.ClientId;
        init => ClientConfig.ClientId = value;
    }

    /// <summary>
    ///     Gets the comma-separated list of brokers (host or host:port).
    /// </summary>
    public string? BootstrapServers
    {
        get => ClientConfig.BootstrapServers;
        init => ClientConfig.BootstrapServers = value;
    }

    /// <summary>
    ///     Gets the maximum message size.
    /// </summary>
    public int? MessageMaxBytes
    {
        get => ClientConfig.MessageMaxBytes;
        init => ClientConfig.MessageMaxBytes = value;
    }

    /// <summary>
    ///     Gets the maximum size for a message to be copied into the buffer. Messages larger than this will be passed by reference (zero-copy)
    ///     at the expense of larger iovecs.
    /// </summary>
    public int? MessageCopyMaxBytes
    {
        get => ClientConfig.MessageCopyMaxBytes;
        init => ClientConfig.MessageCopyMaxBytes = value;
    }

    /// <summary>
    ///     Gets the maximum response message size. This serves as a safety precaution to avoid memory exhaustion in case of protocol hickups.
    ///     This value must be at least <see cref="KafkaConsumerConfiguration.FetchMaxBytes" /> + 512 to allow for protocol overhead.
    ///     The value is adjusted automatically unless the configuration property is explicitly set.
    /// </summary>
    public int? ReceiveMessageMaxBytes
    {
        get => ClientConfig.ReceiveMessageMaxBytes;
        init => ClientConfig.ReceiveMessageMaxBytes = value;
    }

    /// <summary>
    ///     Gets the maximum number of in-flight requests per broker connection. This is a generic property applied to all broker communication,
    ///     however it is primarily relevant to produce requests. In particular, note that other mechanisms limit the number of outstanding consumer
    ///     fetch request per broker to one.
    /// </summary>
    public int? MaxInFlight
    {
        get => ClientConfig.MaxInFlight;
        init => ClientConfig.MaxInFlight = value;
    }

    /// <summary>
    ///     Gets the interval (in milliseconds) at which the topic and broker metadata is refreshed in order to proactively discover any new
    ///     brokers, topics, partitions or partition leader changes. Use -1 to disable the intervalled refresh (not recommended). If there are
    ///     no locally referenced topics (no topic objects created, no messages produced, no subscription or no assignment) then only the broker
    ///     list will be refreshed every interval but no more often than every 10s.
    /// </summary>
    public int? TopicMetadataRefreshIntervalMs
    {
        get => ClientConfig.TopicMetadataRefreshIntervalMs;
        init => ClientConfig.TopicMetadataRefreshIntervalMs = value;
    }

    /// <summary>
    ///     Gets the metadata cache max age (in milliseconds). Defaults to <see cref="TopicMetadataRefreshIntervalMs" />.
    /// </summary>
    public int? MetadataMaxAgeMs
    {
        get => ClientConfig.MetadataMaxAgeMs;
        init => ClientConfig.MetadataMaxAgeMs = value;
    }

    /// <summary>
    ///     Gets the refresh interval (in milliseconds) to be applied instead of the <see cref="TopicMetadataRefreshIntervalMs" />
    ///     when a topic loses its leader and a new metadata request will be enqueued. This initial interval will be exponentially increased
    ///     until the topic metadata has been refreshed. This is used to recover quickly from transitioning leader brokers.
    /// </summary>
    public int? TopicMetadataRefreshFastIntervalMs
    {
        get => ClientConfig.TopicMetadataRefreshFastIntervalMs;
        init => ClientConfig.TopicMetadataRefreshFastIntervalMs = value;
    }

    /// <summary>
    ///     Gets a value indicating whether less metadata requests must be performed (consuming less network bandwidth).
    /// </summary>
    public bool? TopicMetadataRefreshSparse
    {
        get => ClientConfig.TopicMetadataRefreshSparse;
        init => ClientConfig.TopicMetadataRefreshSparse = value;
    }

    /// <summary>
    ///     Gets the delay (in milliseconds) to be applied before marking a topic as non-existent. The maximum propagation time is calculated
    ///     from the time the topic is first referenced in the client.
    /// </summary>
    public int? TopicMetadataPropagationMaxMs
    {
        get => ClientConfig.TopicMetadataPropagationMaxMs;
        init => ClientConfig.TopicMetadataPropagationMaxMs = value;
    }

    /// <summary>
    ///     Gets a comma-separated list of regular expressions for matching topic names that should be ignored in broker metadata information
    ///     as if the topics did not exist.
    /// </summary>
    public string? TopicBlacklist
    {
        get => ClientConfig.TopicBlacklist;
        init => ClientConfig.TopicBlacklist = value;
    }

    /// <summary>
    ///     Gets a comma-separated list of debug contexts to enable.
    ///     Detailed producer debugging: <c>broker,topic,msg</c>.
    ///     Detailed consumer debugging: <c>consumer,cgrp,topic,fetch</c>.
    /// </summary>
    public string? Debug
    {
        get => ClientConfig.Debug;
        init => ClientConfig.Debug = value;
    }

    /// <summary>
    ///     Gets the default timeout (in milliseconds) for network requests.
    /// </summary>
    public int? SocketTimeoutMs
    {
        get => ClientConfig.SocketTimeoutMs;
        init => ClientConfig.SocketTimeoutMs = value;
    }

    /// <summary>
    ///     Gets the socket send buffer size. The system default is used if 0.
    /// </summary>
    public int? SocketSendBufferBytes
    {
        get => ClientConfig.SocketSendBufferBytes;
        init => ClientConfig.SocketSendBufferBytes = value;
    }

    /// <summary>
    ///     Gets the socket receive buffer size. The system default is used if 0.
    /// </summary>
    public int? SocketReceiveBufferBytes
    {
        get => ClientConfig.SocketReceiveBufferBytes;
        init => ClientConfig.SocketReceiveBufferBytes = value;
    }

    /// <summary>
    ///     Gets a value indicating whether TCP keep-alive (SO_KEEPALIVE) must be enabled on the broker sockets.
    /// </summary>
    public bool? SocketKeepaliveEnable
    {
        get => ClientConfig.SocketKeepaliveEnable;
        init => ClientConfig.SocketKeepaliveEnable = value;
    }

    /// <summary>
    ///     Gets a value indicating whether the Nagle's algorithm (TCP_NODELAY) must be disabled on broker sockets.
    /// </summary>
    public bool? SocketNagleDisable
    {
        get => ClientConfig.SocketNagleDisable;
        init => ClientConfig.SocketNagleDisable = value;
    }

    /// <summary>
    ///     Gets the maximum number of send failures (e.g. timed out requests) before disconnecting. Disable with 0.<br />
    ///     Warning: It is highly recommended to leave this setting at its default value of 1 to avoid the client and broker to
    ///     become desynchronized in case of request timeouts.<br />
    ///     Note: The connection is automatically re-established.
    /// </summary>
    public int? SocketMaxFails
    {
        get => ClientConfig.SocketMaxFails;
        init => ClientConfig.SocketMaxFails = value;
    }

    /// <summary>
    ///     Gets the duration in milliseconds of the cache of the broker address resolving results.
    /// </summary>
    public int? BrokerAddressTtl
    {
        get => ClientConfig.BrokerAddressTtl;
        init => ClientConfig.BrokerAddressTtl = value;
    }

    /// <summary>
    ///     Gets the allowed broker IP address families.
    /// </summary>
    public BrokerAddressFamily? BrokerAddressFamily
    {
        get => ClientConfig.BrokerAddressFamily;
        init => ClientConfig.BrokerAddressFamily = value;
    }

    /// <summary>
    ///     Gets the maximum time (in milliseconds) allowed for the setup of the broker connection (TCP connection setup and SSL/SASL handshake).
    ///     The connection to the broker will be closed and retried, if the timeout elapses before it is fully functional.
    /// </summary>
    public int? SocketConnectionSetupTimeoutMs
    {
        get => ClientConfig.SocketConnectionSetupTimeoutMs;
        init => ClientConfig.SocketConnectionSetupTimeoutMs = value;
    }

    /// <summary>
    ///     Gets the maximum time of inactivity (in milliseconds) before closing the broker connections. Disable with 0.
    ///     If this property is left at its default value some heuristics are performed to determine a suitable default value.
    /// </summary>
    public int? ConnectionsMaxIdleMs
    {
        get => ClientConfig.ConnectionsMaxIdleMs;
        init => ClientConfig.ConnectionsMaxIdleMs = value;
    }

    /// <summary>
    ///     Gets the initial time (in milliseconds) to wait before reconnecting to a broker after the connection has been closed. The time is increased
    ///     exponentially until <see cref="ReconnectBackoffMaxMs" /> is reached. -25% to +50% jitter is applied to each reconnect backoff.
    ///     A value of 0 disables the backoff and reconnects immediately.
    /// </summary>
    public int? ReconnectBackoffMs
    {
        get => ClientConfig.ReconnectBackoffMs;
        init => ClientConfig.ReconnectBackoffMs = value;
    }

    /// <summary>
    ///     Gets the maximum time (in milliseconds) to wait before reconnecting to a broker after the connection has been closed.
    /// </summary>
    public int? ReconnectBackoffMaxMs
    {
        get => ClientConfig.ReconnectBackoffMaxMs;
        init => ClientConfig.ReconnectBackoffMaxMs = value;
    }

    /// <summary>
    ///     Gets the statistics emit interval (in milliseconds). The granularity is 1000ms. A value of 0 disables statistics.
    /// </summary>
    public int? StatisticsIntervalMs
    {
        get => ClientConfig.StatisticsIntervalMs;
        init => ClientConfig.StatisticsIntervalMs = value;
    }

    /// <summary>
    ///     Gets a value indicating whether the broker's supported API versions must be requested to adjust the functionality to the available protocol features.
    ///     If set to <c>false</c>, or the API version request fails, the fallback version <see cref="BrokerVersionFallback" /> will be used.
    /// </summary>
    public bool? ApiVersionRequest
    {
        get => ClientConfig.ApiVersionRequest;
        init => ClientConfig.ApiVersionRequest = value;
    }

    /// <summary>
    ///     Gets the timeout (in milliseconds) for the broker API version requests.
    /// </summary>
    public int? ApiVersionRequestTimeoutMs
    {
        get => ClientConfig.ApiVersionRequestTimeoutMs;
        init => ClientConfig.ApiVersionRequestTimeoutMs = value;
    }

    /// <summary>
    ///     Gets how long the <see cref="BrokerVersionFallback" /> is used in the case the API version request fails.
    /// </summary>
    public int? ApiVersionFallbackMs
    {
        get => ClientConfig.ApiVersionFallbackMs;
        init => ClientConfig.ApiVersionFallbackMs = value;
    }

    /// <summary>
    ///     Gets the broker API version to be used when the API version request fails or it's disabled. Older broker versions (before 0.10.0) don't support
    ///     the API version request. Valid values are: 0.9.0, 0.8.2, 0.8.1, 0.8.0. Any other value &gt;= 0.10, such as 0.10.2.1, enables the <see cref="ApiVersionRequest" />.
    /// </summary>
    public string? BrokerVersionFallback
    {
        get => ClientConfig.BrokerVersionFallback;
        init => ClientConfig.BrokerVersionFallback = value;
    }

    /// <summary>
    ///     Gets a value indicating whether topics can be automatically created on the broker when subscribing to or assigning a non-existent
    ///     topic. The broker must also be configured with <c>auto.create.topics.enable=true</c> for this configuration to take effect.
    ///     Requires broker version &gt;= 0.11.0.0, for older broker versions only the broker configuration applies.
    /// </summary>
    public bool? AllowAutoCreateTopics
    {
        get => ClientConfig.AllowAutoCreateTopics;
        init => ClientConfig.AllowAutoCreateTopics = value;
    }

    /// <summary>
    ///     Gets the protocol to be used to communicate with the brokers.
    /// </summary>
    public SecurityProtocol? SecurityProtocol
    {
        get => ClientConfig.SecurityProtocol;
        init => ClientConfig.SecurityProtocol = value;
    }

    /// <summary>
    ///     Gets the SSL cipher suites.
    /// </summary>
    public string? SslCipherSuites
    {
        get => ClientConfig.SslCipherSuites;
        init => ClientConfig.SslCipherSuites = value;
    }

    /// <summary>
    ///     Gets the supported SSL curves.
    /// </summary>
    public string? SslCurvesList
    {
        get => ClientConfig.SslCurvesList;
        init => ClientConfig.SslCurvesList = value;
    }

    /// <summary>
    ///     Gets the supported SSL signature algorithms.
    /// </summary>
    public string? SslSigalgsList
    {
        get => ClientConfig.SslSigalgsList;
        init => ClientConfig.SslSigalgsList = value;
    }

    /// <summary>
    ///     Gets the path to the client's private key (PEM) used for the authentication.
    /// </summary>
    public string? SslKeyLocation
    {
        get => ClientConfig.SslKeyLocation;
        init => ClientConfig.SslKeyLocation = value;
    }

    /// <summary>
    ///     Gets the private key passphrase.
    /// </summary>
    public string? SslKeyPassword
    {
        get => ClientConfig.SslKeyPassword;
        init => ClientConfig.SslKeyPassword = value;
    }

    /// <summary>
    ///     Gets the client's private key string (in PEM format) used for the authentication.
    /// </summary>
    public string? SslKeyPem
    {
        get => ClientConfig.SslKeyPem;
        init => ClientConfig.SslKeyPem = value;
    }

    /// <summary>
    ///     Gets the path to the client's public key (PEM) used for the authentication.
    /// </summary>
    public string? SslCertificateLocation
    {
        get => ClientConfig.SslCertificateLocation;
        init => ClientConfig.SslCertificateLocation = value;
    }

    /// <summary>
    ///     Gets the client's public key string (in PEM format) used for the authentication.
    /// </summary>
    public string? SslCertificatePem
    {
        get => ClientConfig.SslCertificatePem;
        init => ClientConfig.SslCertificatePem = value;
    }

    /// <summary>
    ///     Gets the file or directory path to the CA certificate(s) for verifying the broker's key. Defaults: On Windows the system's CA certificates are automatically looked up in the Windows Root certificate store.
    ///     On Mac OSX this configuration defaults to <c>probe</c>. It is recommended to install openssl using Homebrew, to provide CA certificates. On Linux install the distribution's ca-certificates package.
    ///     If OpenSSL is statically linked or <see cref="SslCaLocation" /> is set to <c>probe</c> a list of standard paths will be probed and the first one found will be used as the default CA certificate location path.
    ///     If OpenSSL is dynamically linked the OpenSSL library's default path will be used (see <c>OPENSSLDIR</c> in <c>openssl version -a</c>).
    /// </summary>
    public string? SslCaLocation
    {
        get => ClientConfig.SslCaLocation;
        init => ClientConfig.SslCaLocation = value;
    }

    /// <summary>
    ///     Gets the CA certificate string (in PEM format) for verifying the broker's key.
    /// </summary>
    public string? SslCaPem
    {
        get => ClientConfig.SslCaPem;
        init => ClientConfig.SslCaPem = value;
    }

    /// <summary>
    ///     Gets a comma-separated list of Windows certificate stores to load CA certificates from. The certificates will be loaded in the same order
    ///     as stores are specified. If no certificates can be loaded from any of the specified stores an error is logged and the OpenSSL library's default
    ///     CA location is used instead. Store names are typically one or more of: MY, Root, Trust, CA.
    /// </summary>
    public string? SslCaCertificateStores
    {
        get => ClientConfig.SslCaCertificateStores;
        init => ClientConfig.SslCaCertificateStores = value;
    }

    /// <summary>
    ///     Gets the path to the certificate revocation list (CRL) for verifying broker's certificate validity.
    /// </summary>
    public string? SslCrlLocation
    {
        get => ClientConfig.SslCrlLocation;
        init => ClientConfig.SslCrlLocation = value;
    }

    /// <summary>
    ///     Gets the path to the client's keystore (PKCS#12) used for the authentication.
    /// </summary>
    public string? SslKeystoreLocation
    {
        get => ClientConfig.SslKeystoreLocation;
        init => ClientConfig.SslKeystoreLocation = value;
    }

    /// <summary>
    ///     Gets the client's keystore (PKCS#12) password.
    /// </summary>
    public string? SslKeystorePassword
    {
        get => ClientConfig.SslKeystorePassword;
        init => ClientConfig.SslKeystorePassword = value;
    }

    /// <summary>
    ///     Gets the comma-separated list of OpenSSL 3.0.x implementation providers.
    /// </summary>
    public string? SslProviders
    {
        get => ClientConfig.SslProviders;
        init => ClientConfig.SslProviders = value;
    }

    /// <summary>
    ///     Gets the path to the OpenSSL engine library. OpenSSL &gt;= 1.1.0 required.
    /// </summary>
    public string? SslEngineLocation
    {
        get => ClientConfig.SslEngineLocation;
        init => ClientConfig.SslEngineLocation = value;
    }

    /// <summary>
    ///     Gets the OpenSSL engine id (the name used for loading engine).
    /// </summary>
    public string? SslEngineId
    {
        get => ClientConfig.SslEngineId;
        init => ClientConfig.SslEngineId = value;
    }

    /// <summary>
    ///     Gets a value indicating whether the broker (server) certificate must be verified.
    /// </summary>
    public bool? EnableSslCertificateVerification
    {
        get => ClientConfig.EnableSslCertificateVerification;
        init => ClientConfig.EnableSslCertificateVerification = value;
    }

    /// <summary>
    ///     Gets the endpoint identification algorithm to be used to validate the broker hostname using the certificate. OpenSSL &gt;= 1.0.2 required.
    /// </summary>
    public SslEndpointIdentificationAlgorithm? SslEndpointIdentificationAlgorithm
    {
        get => ClientConfig.SslEndpointIdentificationAlgorithm;
        init => ClientConfig.SslEndpointIdentificationAlgorithm = value;
    }

    /// <summary>
    ///     Gets the Kerberos principal name that Kafka runs as, not including /hostname@REALM.
    /// </summary>
    public string? SaslKerberosServiceName
    {
        get => ClientConfig.SaslKerberosServiceName;
        init => ClientConfig.SaslKerberosServiceName = value;
    }

    /// <summary>
    ///     Gets the client's Kerberos principal name. (Not supported on Windows, will use the logon user's principal).
    /// </summary>
    public string? SaslKerberosPrincipal
    {
        get => ClientConfig.SaslKerberosPrincipal;
        init => ClientConfig.SaslKerberosPrincipal = value;
    }

    /// <summary>
    ///     Gets the shell command to be used to refresh or acquire the client's Kerberos ticket. This command is executed on client creation and every <see cref="SaslKerberosMinTimeBeforeRelogin" /> (0=disable).
    /// </summary>
    public string? SaslKerberosKinitCmd
    {
        get => ClientConfig.SaslKerberosKinitCmd;
        init => ClientConfig.SaslKerberosKinitCmd = value;
    }

    /// <summary>
    ///     Gets the path to the Kerberos keytab file. This configuration property is only used as a variable in <see cref="SaslKerberosKinitCmd" /> as <c>... -t "%{sasl.kerberos.keytab}"</c>.
    /// </summary>
    public string? SaslKerberosKeytab
    {
        get => ClientConfig.SaslKerberosKeytab;
        init => ClientConfig.SaslKerberosKeytab = value;
    }

    /// <summary>
    ///     Gets the minimum time in milliseconds between each key refresh attempts. Disable automatic key refresh by setting this property to 0.
    /// </summary>
    public int? SaslKerberosMinTimeBeforeRelogin
    {
        get => ClientConfig.SaslKerberosMinTimeBeforeRelogin;
        init => ClientConfig.SaslKerberosMinTimeBeforeRelogin = value;
    }

    /// <summary>
    ///     Gets the SASL username to use with the PLAIN and SASL-SCRAM-.. mechanisms.
    /// </summary>
    public string? SaslUsername
    {
        get => ClientConfig.SaslUsername;
        init => ClientConfig.SaslUsername = value;
    }

    /// <summary>
    ///     Gets the SASL password to use with the PLAIN and SASL-SCRAM-.. mechanisms.
    /// </summary>
    public string? SaslPassword
    {
        get => ClientConfig.SaslPassword;
        init => ClientConfig.SaslPassword = value;
    }

    /// <summary>
    ///     Gets the SASL/OAUTHBEARER configuration. The format is implementation-dependent and must be parsed accordingly. The default unsecured token implementation
    ///     (see https://tools.ietf.org/html/rfc7515#appendix-A.5) recognizes space-separated <c>name=value</c> pairs with valid names including <c>principalClaimName</c>,
    ///     <c>principal</c>, <c>scopeClaimName</c>, <c>scope</c>, and <c>lifeSeconds</c>. The default value for <c>principalClaimName</c> is <c>"sub"</c>, the default value
    ///     for <c>scopeClaimName</c> is <c>"scope"</c>, and the default value for <c>lifeSeconds</c> is 3600. The <c>scope</c> value is CSV format with the default value being
    ///     no/empty scope. For example: <c>principalClaimName=azp principal=admin scopeClaimName=roles scope=role1,role2 lifeSeconds=600</c>. In addition, SASL extensions can be
    ///     communicated to the broker via <c>extension_NAME=value</c>. For example: <c>principal=admin extension_traceId=123</c>.
    /// </summary>
    public string? SaslOauthbearerConfig
    {
        get => ClientConfig.SaslOauthbearerConfig;
        init => ClientConfig.SaslOauthbearerConfig = value;
    }

    /// <summary>
    ///     Gets a value indicating whether the builtin unsecure JWT OAUTHBEARER token handler must be enabled. This builtin handler should only be used for development or testing, and not in production.
    /// </summary>
    public bool? EnableSaslOauthbearerUnsecureJwt
    {
        get => ClientConfig.EnableSaslOauthbearerUnsecureJwt;
        init => ClientConfig.EnableSaslOauthbearerUnsecureJwt = value;
    }

    /// <summary>
    ///     Gets the login method to be used. If set to <see cref="Confluent.Kafka.SaslOauthbearerMethod.Oidc" />, the following properties must also be be specified: <see cref="SaslOauthbearerClientId" />,
    ///     <see cref="SaslOauthbearerClientSecret" />, and <see cref="SaslOauthbearerTokenEndpointUrl" />.
    /// </summary>
    public SaslOauthbearerMethod? SaslOauthbearerMethod
    {
        get => ClientConfig.SaslOauthbearerMethod;
        init => ClientConfig.SaslOauthbearerMethod = value;
    }

    /// <summary>
    ///     Gets the public identifier for the application. Must be unique across all clients that the authorization server handles. Only used when <see cref="SaslOauthbearerMethod" /> is set to <see cref="Confluent.Kafka.SaslOauthbearerMethod.Oidc" />.
    /// </summary>
    public string? SaslOauthbearerClientId
    {
        get => ClientConfig.SaslOauthbearerClientId;
        init => ClientConfig.SaslOauthbearerClientId = value;
    }

    /// <summary>
    ///     Gets the client secret only known to the application and the authorization server. This should be a sufficiently random string that is not guessable. Only used when <see cref="SaslOauthbearerMethod" /> is set to <see cref="Confluent.Kafka.SaslOauthbearerMethod.Oidc" />.
    /// </summary>
    public string? SaslOauthbearerClientSecret
    {
        get => ClientConfig.SaslOauthbearerClientSecret;
        init => ClientConfig.SaslOauthbearerClientSecret = value;
    }

    /// <summary>
    ///     Gets the scope of the access request to the broker. Only used when <see cref="SaslOauthbearerMethod" /> is set to <see cref="Confluent.Kafka.SaslOauthbearerMethod.Oidc" />.
    /// </summary>
    public string? SaslOauthbearerScope
    {
        get => ClientConfig.SaslOauthbearerScope;
        init => ClientConfig.SaslOauthbearerScope = value;
    }

    /// <summary>
    ///     Gets the additional information to be provided to the broker as a comma-separated list of <c>key=value</c> pairs (e.g. <c>supportFeatureX=true,organizationId=sales-emea</c>). Only used when <see cref="SaslOauthbearerMethod" /> is set to <see cref="Confluent.Kafka.SaslOauthbearerMethod.Oidc" />.
    /// </summary>
    public string? SaslOauthbearerExtensions
    {
        get => ClientConfig.SaslOauthbearerExtensions;
        init => ClientConfig.SaslOauthbearerExtensions = value;
    }

    /// <summary>
    ///     Gets the OAuth/OIDC issuer token endpoint HTTP(S) URI used to retrieve the token. Only used when <see cref="SaslOauthbearerMethod" /> is set to <see cref="Confluent.Kafka.SaslOauthbearerMethod.Oidc" />.
    /// </summary>
    [SuppressMessage("Design", "CA1056:URI-like properties should not be strings", Justification = "Generated according to wrapped class.")]
    public string? SaslOauthbearerTokenEndpointUrl
    {
        get => ClientConfig.SaslOauthbearerTokenEndpointUrl;
        init => ClientConfig.SaslOauthbearerTokenEndpointUrl = value;
    }

    /// <summary>
    ///     Gets the list of plugin libraries to load (<c>;</c> separated). The library search path is platform dependent. If no filename extension is specified the platform-specific extension (such as .dll or .so) will be appended automatically.
    /// </summary>
    public string? PluginLibraryPaths
    {
        get => ClientConfig.PluginLibraryPaths;
        init => ClientConfig.PluginLibraryPaths = value;
    }

    /// <summary>
    ///     Gets the rack identifier for this client. This can be any string value which indicates where this client is physically located.
    /// </summary>
    public string? ClientRack
    {
        get => ClientConfig.ClientRack;
        init => ClientConfig.ClientRack = value;
    }

    /// <summary>
    ///     Gets the maximum time (in milliseconds) before a cancellation request is acted on. Low values may result in measurably higher CPU usage.
    /// </summary>
    public int CancellationDelayMaxMs
    {
        init => ClientConfig.CancellationDelayMaxMs = value;
    }
}

/// <content>
///     The autogenerated part of the <see cref="KafkaConsumerConfiguration" /> class.
/// </content>
[SuppressMessage("StyleCop.CSharp.MaintainabilityRules", "SA1402:File may only contain a single type", Justification = "Autogenerated all at once")]
[SuppressMessage("Design", "CA1044:Properties should not be write only", Justification = "Accessors generated according to wrapped class")]
public partial record KafkaConsumerConfiguration
{
    /// <summary>
    ///     Gets a comma-separated list of fields that may be optionally set in <see cref="ConsumeResult{TKey,TValue}" /> objects returned by
    ///     the <see cref="Consumer{TKey,TValue}.Consume(System.TimeSpan)" /> method. Disabling fields that you do not require will improve
    ///     throughput and reduce memory consumption. Allowed values: <c>headers</c>, <c>timestamp</c>, <c>topic</c>, <c>all</c>, <c>none</c>.
    /// </summary>
    public string? ConsumeResultFields
    {
        init => ClientConfig.ConsumeResultFields = value;
    }

    /// <summary>
    ///     Gets the action to take when there is no initial offset in the offset store or the desired offset is out of range:
    ///     <see cref="Confluent.Kafka.AutoOffsetReset.Earliest" /> to automatically reset to the smallest offset,
    ///     <see cref="Confluent.Kafka.AutoOffsetReset.Latest" /> to automatically reset to the largest offset, and
    ///     <see cref="Confluent.Kafka.AutoOffsetReset.Error" /> to trigger an error (ERR__AUTO_OFFSET_RESET).
    /// </summary>
    public AutoOffsetReset? AutoOffsetReset
    {
        get => ClientConfig.AutoOffsetReset;
        init => ClientConfig.AutoOffsetReset = value;
    }

    /// <summary>
    ///     Gets the static instance id used to enable static group membership. Static group members are able to leave and rejoin a group within
    ///     the configured <see cref="SessionTimeoutMs" /> without prompting a group rebalance. This should be used in combination with a larger
    ///     <see cref="SessionTimeoutMs" /> to avoid group rebalances caused by transient unavailability (e.g. process restarts).
    ///     Requires broker version &gt;= 2.3.0.
    /// </summary>
    public string? GroupInstanceId
    {
        get => ClientConfig.GroupInstanceId;
        init => ClientConfig.GroupInstanceId = value;
    }

    /// <summary>
    ///     Gets the partition assignment strategy: <see cref="Confluent.Kafka.PartitionAssignmentStrategy.Range" /> to co-localize the partitions
    ///     of several topics, <see cref="Confluent.Kafka.PartitionAssignmentStrategy.RoundRobin" /> to evenly distribute the partitions among
    ///     the consumer group members, <see cref="Confluent.Kafka.PartitionAssignmentStrategy.CooperativeSticky" /> to evenly distribute the
    ///     partitions and limit minimize the partitions movements. The default is <see cref="Confluent.Kafka.PartitionAssignmentStrategy.Range" />.
    /// </summary>
    public PartitionAssignmentStrategy? PartitionAssignmentStrategy
    {
        get => ClientConfig.PartitionAssignmentStrategy;
        init => ClientConfig.PartitionAssignmentStrategy = value;
    }

    /// <summary>
    ///     Gets the client group session and failure detection timeout (in milliseconds). The consumer sends periodic heartbeats
    ///     <see cref="HeartbeatIntervalMs" /> to indicate its liveness to the broker. If no heartbeat is received by the broker for a group
    ///     member within the session timeout, the broker will remove the consumer from the group and trigger a rebalance. Also see
    ///     <see cref="MaxPollIntervalMs" />.
    /// </summary>
    public int? SessionTimeoutMs
    {
        get => ClientConfig.SessionTimeoutMs;
        init => ClientConfig.SessionTimeoutMs = value;
    }

    /// <summary>
    ///     Gets the interval (in milliseconds) at which the heartbeats have to be sent to the broker.
    /// </summary>
    public int? HeartbeatIntervalMs
    {
        get => ClientConfig.HeartbeatIntervalMs;
        init => ClientConfig.HeartbeatIntervalMs = value;
    }

    /// <summary>
    ///     Gets the group protocol type.
    /// </summary>
    public string? GroupProtocolType
    {
        get => ClientConfig.GroupProtocolType;
        init => ClientConfig.GroupProtocolType = value;
    }

    /// <summary>
    ///     Gets the interval (in milliseconds) at which the current group coordinator must be queried. If the currently assigned coordinator
    ///     is down the configured query interval will be divided by ten to more quickly recover in case of coordinator reassignment.
    /// </summary>
    public int? CoordinatorQueryIntervalMs
    {
        get => ClientConfig.CoordinatorQueryIntervalMs;
        init => ClientConfig.CoordinatorQueryIntervalMs = value;
    }

    /// <summary>
    ///     Gets the maximum allowed time (in milliseconds) between calls to consume messages. If this interval is exceeded the consumer is
    ///     considered failed and the group will rebalance in order to reassign the partitions to another consumer group member.<br />
    ///     Warning: Offset commits may be not possible at this point.
    /// </summary>
    public int? MaxPollIntervalMs
    {
        get => ClientConfig.MaxPollIntervalMs;
        init => ClientConfig.MaxPollIntervalMs = value;
    }

    /// <summary>
    ///     Gets the frequency in milliseconds at which the consumer offsets are committed.
    /// </summary>
    public int? AutoCommitIntervalMs
    {
        get => ClientConfig.AutoCommitIntervalMs;
        init => ClientConfig.AutoCommitIntervalMs = value;
    }

    /// <summary>
    ///     Gets the minimum number of messages per topic and partition that the underlying library must try to maintain in the local consumer queue.
    /// </summary>
    public int? QueuedMinMessages
    {
        get => ClientConfig.QueuedMinMessages;
        init => ClientConfig.QueuedMinMessages = value;
    }

    /// <summary>
    ///     Gets the maximum number of kilobytes of queued pre-fetched messages to store in the local consumer queue. This setting applies to
    ///     the single consumer queue, regardless of the number of partitions. This value may be overshot by <see cref="FetchMaxBytes" />. This
    ///     property has higher priority than <see cref="QueuedMinMessages" />.
    /// </summary>
    public int? QueuedMaxMessagesKbytes
    {
        get => ClientConfig.QueuedMaxMessagesKbytes;
        init => ClientConfig.QueuedMaxMessagesKbytes = value;
    }

    /// <summary>
    ///     Gets the maximum time (in milliseconds) that the broker may wait to fill the fetch response with enough messages to match the
    ///     size specified by <see cref="FetchMinBytes" />.
    /// </summary>
    public int? FetchWaitMaxMs
    {
        get => ClientConfig.FetchWaitMaxMs;
        init => ClientConfig.FetchWaitMaxMs = value;
    }

    /// <summary>
    ///     Gets the initial maximum number of bytes per topic and partition to request when fetching messages from the broker. If the client
    ///     encounters a message larger than this value it will gradually try to increase it until the entire message can be fetched.
    /// </summary>
    public int? MaxPartitionFetchBytes
    {
        get => ClientConfig.MaxPartitionFetchBytes;
        init => ClientConfig.MaxPartitionFetchBytes = value;
    }

    /// <summary>
    ///     Gets the maximum amount of data the broker shall return for a fetch request. The messages are fetched in batches by the consumer
    ///     and if the first message batch in the first non-empty partition of the fetch request is larger than this value, then the message
    ///     batch will still be returned to ensure that the consumer can make progress. The maximum message batch size accepted by the broker
    ///     is defined via <c>message.max.bytes</c> (broker config) or <c>max.message.bytes</c> (broker topic config). This value is automatically
    ///     adjusted upwards to be at least <c>message.max.bytes</c> (consumer config).
    /// </summary>
    public int? FetchMaxBytes
    {
        get => ClientConfig.FetchMaxBytes;
        init => ClientConfig.FetchMaxBytes = value;
    }

    /// <summary>
    ///     Gets the minimum number of bytes that the broker must respond with. If <see cref="FetchWaitMaxMs" /> expires the accumulated data
    ///     will be sent to the client regardless of this setting.
    /// </summary>
    public int? FetchMinBytes
    {
        get => ClientConfig.FetchMinBytes;
        init => ClientConfig.FetchMinBytes = value;
    }

    /// <summary>
    ///     Gets how long to postpone the next fetch request for a topic and partition in case of a fetch error.
    /// </summary>
    public int? FetchErrorBackoffMs
    {
        get => ClientConfig.FetchErrorBackoffMs;
        init => ClientConfig.FetchErrorBackoffMs = value;
    }

    /// <summary>
    ///     Gets a value indicating how to read the messages written inside a transaction: <see cref="Confluent.Kafka.IsolationLevel.ReadCommitted" />
    ///     to only return transactional messages which have been committed, or <see cref="Confluent.Kafka.IsolationLevel.ReadUncommitted" /> to
    ///     return all messages, even transactional messages which have been aborted.
    /// </summary>
    public IsolationLevel? IsolationLevel
    {
        get => ClientConfig.IsolationLevel;
        init => ClientConfig.IsolationLevel = value;
    }

    /// <summary>
    ///     Gets a value indicating whether the partition EOF event must be emitted whenever the consumer reaches the end of a partition.
    /// </summary>
    public bool? EnablePartitionEof
    {
        get => ClientConfig.EnablePartitionEof;
        init => ClientConfig.EnablePartitionEof = value;
    }

    /// <summary>
    ///     Gets a value indicating whether the CRC32 of the consumed messages must be verified, ensuring no on-the-wire or on-disk corruption
    ///     to the messages occurred. This check comes at slightly increased CPU usage.
    /// </summary>
    public bool? CheckCrcs
    {
        get => ClientConfig.CheckCrcs;
        init => ClientConfig.CheckCrcs = value;
    }
}

/// <content>
///     The autogenerated part of the <see cref="KafkaProducerConfiguration" /> class.
/// </content>
[SuppressMessage("StyleCop.CSharp.MaintainabilityRules", "SA1402:File may only contain a single type", Justification = "Autogenerated all at once")]
[SuppressMessage("Design", "CA1044:Properties should not be write only", Justification = "Accessors generated according to wrapped class")]
public partial record KafkaProducerConfiguration
{
    /// <summary>
    ///     Gets a value indicating whether delivery reports must be sent. Typically you should set this parameter to <c>true</c>. Set it to
    ///     <c>false</c> for "fire and forget" semantics and a small boost in performance.
    /// </summary>
    public bool? EnableDeliveryReports
    {
        get => ClientConfig.EnableDeliveryReports;
        init => ClientConfig.EnableDeliveryReports = value;
    }

    /// <summary>
    ///     Gets the ack timeout of the producer request in milliseconds. This value is only enforced by the broker and relies on
    ///     <c>request.required.acks</c> being != 0.
    /// </summary>
    public int? RequestTimeoutMs
    {
        get => ClientConfig.RequestTimeoutMs;
        init => ClientConfig.RequestTimeoutMs = value;
    }

    /// <summary>
    ///     Gets the local message timeout (in milliseconds). This value is only enforced locally and limits the time a produced message waits
    ///     for successful delivery. A time of 0 is infinite. This is the maximum time to deliver a message (including retries) and a delivery
    ///     error will occur when either the retry count or the message timeout are exceeded. The message timeout is automatically adjusted to
    ///     <see cref="TransactionTimeoutMs" /> if  <see cref="TransactionalId" /> is set.
    /// </summary>
    public int? MessageTimeoutMs
    {
        get => ClientConfig.MessageTimeoutMs;
        init => ClientConfig.MessageTimeoutMs = value;
    }

    /// <summary>
    ///     Gets the partitioner to be used to decide the target partition for a message: <see cref="Confluent.Kafka.Partitioner.Random" />
    ///     to randomly distribute the messages, <see cref="Confluent.Kafka.Partitioner.Consistent" /> to use the CRC32 hash of the message key
    ///     (empty and null keys are mapped to a single partition), <see cref="Confluent.Kafka.Partitioner.ConsistentRandom" /> to use the CRC32
    ///     hash of the message key (but empty and null keys are randomly partitioned), <see cref="Confluent.Kafka.Partitioner.Murmur2" /> to use
    ///     a Java Producer compatible Murmur2 hash of the message key (null keys are mapped to a single partition), or
    ///     <see cref="Confluent.Kafka.Partitioner.Murmur2Random" /> to use a Java Producer compatible Murmur2 hash of the message key (but null
    ///     keys are randomly partitioned).<br />
    ///     The default is <see cref="Confluent.Kafka.Partitioner.ConsistentRandom" />, while <see cref="Confluent.Kafka.Partitioner.Murmur2Random" />
    ///     is functionally equivalent to the default partitioner in the Java Producer.
    /// </summary>
    public Partitioner? Partitioner
    {
        get => ClientConfig.Partitioner;
        init => ClientConfig.Partitioner = value;
    }

    /// <summary>
    ///     Gets the compression level parameter for the algorithm selected by configuration property <see cref="CompressionType" />. Higher
    ///     values will result in better compression at the cost of higher CPU usage. Usable range is algorithm-dependent: [0-9] for gzip,
    ///     [0-12] for lz4, only 0 for snappy. -1 = codec-dependent default compression level.
    /// </summary>
    public int? CompressionLevel
    {
        get => ClientConfig.CompressionLevel;
        init => ClientConfig.CompressionLevel = value;
    }

    /// <summary>
    ///     Gets the identifier to be used to identify the same transactional producer instance across process restarts. This is required to
    ///     enable the transactional producer and it allows the producer to guarantee that transactions corresponding to earlier instances of
    ///     the same producer have been finalized prior to starting any new transaction, and that any zombie instances are fenced off. If no
    ///     <see cref="TransactionalId" /> is provided, then the producer is limited to idempotent delivery (see <see cref="EnableIdempotence" />).
    ///     Requires broker version &gt;= 0.11.0.
    /// </summary>
    public string? TransactionalId
    {
        get => ClientConfig.TransactionalId;
        init => ClientConfig.TransactionalId = value;
    }

    /// <summary>
    ///     Gets the maximum amount of time in milliseconds that the transaction coordinator will wait for a transaction status update from
    ///     the producer before proactively aborting the ongoing transaction. If this value is larger than the <c>transaction.max.timeout.ms</c>
    ///     setting in the broker, the init transaction call will fail with ERR_INVALID_TRANSACTION_TIMEOUT. The transaction timeout automatically
    ///     adjusts <see cref="MessageTimeoutMs" /> and <see cref="KafkaClientConfiguration{TClientConfig}.SocketTimeoutMs" /> unless explicitly configured in which case
    ///     they must not exceed the transaction timeout (<see cref="KafkaClientConfiguration{TClientConfig}.SocketTimeoutMs" /> must be at least 100ms lower than
    ///     <see cref="TransactionTimeoutMs" />).
    /// </summary>
    public int? TransactionTimeoutMs
    {
        get => ClientConfig.TransactionTimeoutMs;
        init => ClientConfig.TransactionTimeoutMs = value;
    }

    /// <summary>
    ///     Gets a value indicating whether the producer must ensure that messages are successfully produced exactly once and in the original
    ///     produce order. The following configuration properties are adjusted automatically (if not modified by the user) when idempotence is
    ///     enabled: <see cref="KafkaClientConfiguration{TClientConfig}.MaxInFlight" /> to 5 (must be less than or equal to 5),
    ///     <see cref="MessageSendMaxRetries" /> to <c>Int32.MaxValue</c> (must be greater than 0),
    ///     <see cref="KafkaClientConfiguration{TClientConfig}.Acks" /> to <see cref="Acks.All" />. The producer instantiation will fail if user-supplied configuration
    ///     is incompatible.
    /// </summary>
    public bool? EnableIdempotence
    {
        get => ClientConfig.EnableIdempotence;
        init => ClientConfig.EnableIdempotence = value;
    }

    /// <summary>
    ///     Gets a value indicating whether an error that could result in a gap in the produced message series when a batch of messages fails,
    ///     must raise a fatal error (ERR_GAPLESS_GUARANTEE) and stop the producer. Messages failing due to <see cref="MessageTimeoutMs" /> are
    ///     not covered by this guarantee. Requires <see cref="EnableIdempotence" />=true.
    /// </summary>
    public bool? EnableGaplessGuarantee
    {
        get => ClientConfig.EnableGaplessGuarantee;
        init => ClientConfig.EnableGaplessGuarantee = value;
    }

    /// <summary>
    ///     Gets the maximum number of messages allowed on the producer queue. This queue is shared by all topics and partitions.
    /// </summary>
    public int? QueueBufferingMaxMessages
    {
        get => ClientConfig.QueueBufferingMaxMessages;
        init => ClientConfig.QueueBufferingMaxMessages = value;
    }

    /// <summary>
    ///     Gets the maximum total message size sum allowed on the producer queue. This queue is shared by all topics and partitions. This
    ///     property has higher priority than <see cref="QueueBufferingMaxMessages" />.
    /// </summary>
    public int? QueueBufferingMaxKbytes
    {
        get => ClientConfig.QueueBufferingMaxKbytes;
        init => ClientConfig.QueueBufferingMaxKbytes = value;
    }

    /// <summary>
    ///     Gets the delay in milliseconds to wait for messages in the producer queue to accumulate before constructing message batches to
    ///     transmit to brokers. A higher value allows larger and more effective (less overhead, improved compression) batches of messages to
    ///     accumulate at the expense of increased message delivery latency.
    /// </summary>
    public double? LingerMs
    {
        get => ClientConfig.LingerMs;
        init => ClientConfig.LingerMs = value;
    }

    /// <summary>
    ///     Gets how many times to retry sending a failing message.<br />
    ///     Note: retrying may cause reordering unless <see cref="EnableIdempotence" /> is set to <c>true</c>.
    /// </summary>
    public int? MessageSendMaxRetries
    {
        get => ClientConfig.MessageSendMaxRetries;
        init => ClientConfig.MessageSendMaxRetries = value;
    }

    /// <summary>
    ///     Gets the backoff time in milliseconds before retrying a request.
    /// </summary>
    public int? RetryBackoffMs
    {
        get => ClientConfig.RetryBackoffMs;
        init => ClientConfig.RetryBackoffMs = value;
    }

    /// <summary>
    ///     Gets the threshold of outstanding not yet transmitted broker requests needed to backpressure the producer's message accumulator.
    ///     If the number of not yet transmitted requests equals or exceeds this number, produce request creation that would have otherwise
    ///     been triggered (for example, in accordance with <see cref="LingerMs" />) will be delayed. A lower number yields larger and more
    ///     effective batches. A higher value can improve latency when using compression on slow machines.
    /// </summary>
    public int? QueueBufferingBackpressureThreshold
    {
        get => ClientConfig.QueueBufferingBackpressureThreshold;
        init => ClientConfig.QueueBufferingBackpressureThreshold = value;
    }

    /// <summary>
    ///     Gets the compression codec to be used to compress message sets. This is the default value for all topics, may be overridden by the
    ///     topic configuration property <c>compression.codec</c>.
    /// </summary>
    public CompressionType? CompressionType
    {
        get => ClientConfig.CompressionType;
        init => ClientConfig.CompressionType = value;
    }

    /// <summary>
    ///     Gets the maximum number of messages batched in one message set. The total message set size is also limited by <see cref="BatchSize" />
    ///     and <see cref="KafkaClientConfiguration{TClientConfig}.MessageMaxBytes" />.
    /// </summary>
    public int? BatchNumMessages
    {
        get => ClientConfig.BatchNumMessages;
        init => ClientConfig.BatchNumMessages = value;
    }

    /// <summary>
    ///     Gets the maximum size (in bytes) of all messages batched in one message set, including the protocol framing overhead. This limit
    ///     is applied after the first message has been added to the batch, regardless of the first message size, this is to ensure that messages
    ///     that exceed the <see cref="BatchSize" /> are still produced. The total message set size is also limited by <see cref="BatchNumMessages" />
    ///     and <see cref="KafkaClientConfiguration{TClientConfig}.MessageMaxBytes" />.
    /// </summary>
    public int? BatchSize
    {
        get => ClientConfig.BatchSize;
        init => ClientConfig.BatchSize = value;
    }

    /// <summary>
    ///     Gets the delay in milliseconds to wait to assign new sticky partitions for each topic. By default this is set to double the time
    ///     of <see cref="LingerMs" />. To disable sticky behavior, set it to 0. This behavior affects messages with the key <c>null</c> in all
    ///     cases, and messages with key lengths of zero when the <see cref="Confluent.Kafka.Partitioner.ConsistentRandom" /> partitioner is in
    ///     use. These messages would otherwise be assigned randomly. A higher value allows for more effective batching of these messages.
    /// </summary>
    public int? StickyPartitioningLingerMs
    {
        get => ClientConfig.StickyPartitioningLingerMs;
        init => ClientConfig.StickyPartitioningLingerMs = value;
    }
}

/// <summary>
///     Builds the <see cref="KafkaProducerConfiguration" /> or <see cref="KafkaConsumerConfiguration" />.
/// </summary>
[SuppressMessage("StyleCop.CSharp.MaintainabilityRules", "SA1402:File may only contain a single type", Justification = "Autogenerated all at once")]
[SuppressMessage("StyleCop.CSharp.DocumentationRules", "SA1600:Elements should be documented", Justification = "Internal interface")]
[SuppressMessage("StyleCop.CSharp.OrderingRules", "SA1201:Elements should appear in the correct order", Justification = "Autogenerated")]
internal interface IKafkaClientConfigurationBuilder
{
    void WithSaslMechanism(SaslMechanism? saslMechanism);

    void WithAcks(Acks? acks);

    void WithClientId(string? clientId);

    void WithBootstrapServers(string? bootstrapServers);

    void WithMessageMaxBytes(int? messageMaxBytes);

    void WithMessageCopyMaxBytes(int? messageCopyMaxBytes);

    void WithReceiveMessageMaxBytes(int? receiveMessageMaxBytes);

    void WithMaxInFlight(int? maxInFlight);

    void WithTopicMetadataRefreshIntervalMs(int? topicMetadataRefreshIntervalMs);

    void WithMetadataMaxAgeMs(int? metadataMaxAgeMs);

    void WithTopicMetadataRefreshFastIntervalMs(int? topicMetadataRefreshFastIntervalMs);

    void WithTopicMetadataRefreshSparse(bool? topicMetadataRefreshSparse);

    void WithTopicMetadataPropagationMaxMs(int? topicMetadataPropagationMaxMs);

    void WithTopicBlacklist(string? topicBlacklist);

    void WithDebug(string? debug);

    void WithSocketTimeoutMs(int? socketTimeoutMs);

    void WithSocketSendBufferBytes(int? socketSendBufferBytes);

    void WithSocketReceiveBufferBytes(int? socketReceiveBufferBytes);

    void WithSocketKeepaliveEnable(bool? socketKeepaliveEnable);

    void WithSocketNagleDisable(bool? socketNagleDisable);

    void WithSocketMaxFails(int? socketMaxFails);

    void WithBrokerAddressTtl(int? brokerAddressTtl);

    void WithBrokerAddressFamily(BrokerAddressFamily? brokerAddressFamily);

    void WithSocketConnectionSetupTimeoutMs(int? socketConnectionSetupTimeoutMs);

    void WithConnectionsMaxIdleMs(int? connectionsMaxIdleMs);

    void WithReconnectBackoffMs(int? reconnectBackoffMs);

    void WithReconnectBackoffMaxMs(int? reconnectBackoffMaxMs);

    void WithStatisticsIntervalMs(int? statisticsIntervalMs);

    void WithApiVersionRequest(bool? apiVersionRequest);

    void WithApiVersionRequestTimeoutMs(int? apiVersionRequestTimeoutMs);

    void WithApiVersionFallbackMs(int? apiVersionFallbackMs);

    void WithBrokerVersionFallback(string? brokerVersionFallback);

    void WithAllowAutoCreateTopics(bool? allowAutoCreateTopics);

    void WithSecurityProtocol(SecurityProtocol? securityProtocol);

    void WithSslCipherSuites(string? sslCipherSuites);

    void WithSslCurvesList(string? sslCurvesList);

    void WithSslSigalgsList(string? sslSigalgsList);

    void WithSslKeyLocation(string? sslKeyLocation);

    void WithSslKeyPassword(string? sslKeyPassword);

    void WithSslKeyPem(string? sslKeyPem);

    void WithSslCertificateLocation(string? sslCertificateLocation);

    void WithSslCertificatePem(string? sslCertificatePem);

    void WithSslCaLocation(string? sslCaLocation);

    void WithSslCaPem(string? sslCaPem);

    void WithSslCaCertificateStores(string? sslCaCertificateStores);

    void WithSslCrlLocation(string? sslCrlLocation);

    void WithSslKeystoreLocation(string? sslKeystoreLocation);

    void WithSslKeystorePassword(string? sslKeystorePassword);

    void WithSslProviders(string? sslProviders);

    void WithSslEngineLocation(string? sslEngineLocation);

    void WithSslEngineId(string? sslEngineId);

    void WithEnableSslCertificateVerification(bool? enableSslCertificateVerification);

    void WithSslEndpointIdentificationAlgorithm(SslEndpointIdentificationAlgorithm? sslEndpointIdentificationAlgorithm);

    void WithSaslKerberosServiceName(string? saslKerberosServiceName);

    void WithSaslKerberosPrincipal(string? saslKerberosPrincipal);

    void WithSaslKerberosKinitCmd(string? saslKerberosKinitCmd);

    void WithSaslKerberosKeytab(string? saslKerberosKeytab);

    void WithSaslKerberosMinTimeBeforeRelogin(int? saslKerberosMinTimeBeforeRelogin);

    void WithSaslUsername(string? saslUsername);

    void WithSaslPassword(string? saslPassword);

    void WithSaslOauthbearerConfig(string? saslOauthbearerConfig);

    void WithEnableSaslOauthbearerUnsecureJwt(bool? enableSaslOauthbearerUnsecureJwt);

    void WithSaslOauthbearerMethod(SaslOauthbearerMethod? saslOauthbearerMethod);

    void WithSaslOauthbearerClientId(string? saslOauthbearerClientId);

    void WithSaslOauthbearerClientSecret(string? saslOauthbearerClientSecret);

    void WithSaslOauthbearerScope(string? saslOauthbearerScope);

    void WithSaslOauthbearerExtensions(string? saslOauthbearerExtensions);

    void WithSaslOauthbearerTokenEndpointUrl(string? saslOauthbearerTokenEndpointUrl);

    void WithPluginLibraryPaths(string? pluginLibraryPaths);

    void WithClientRack(string? clientRack);

    void WithCancellationDelayMaxMs(int cancellationDelayMaxMs);
}

/// <content>
///     The autogenerated part of the <see cref="KafkaClientsConfigurationBuilder" /> class.
/// </content>
[SuppressMessage("StyleCop.CSharp.MaintainabilityRules", "SA1402:File may only contain a single type", Justification = "Autogenerated all at once")]
[SuppressMessage("StyleCop.CSharp.DocumentationRules", "SA1600:Elements should be documented", Justification = "Documented in other partial")]
[SuppressMessage("StyleCop.CSharp.DocumentationRules", "SA1601:Partial elements should be documented", Justification = "Autogenerated")]
public partial class KafkaClientsConfigurationBuilder
{
    public partial KafkaClientsConfigurationBuilder WithSaslMechanism(SaslMechanism? saslMechanism)
    {
        _sharedConfigurationActions.Add(builder => builder.WithSaslMechanism(saslMechanism));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithAcks(Acks? acks)
    {
        _sharedConfigurationActions.Add(builder => builder.WithAcks(acks));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithBootstrapServers(string? bootstrapServers)
    {
        _sharedConfigurationActions.Add(builder => builder.WithBootstrapServers(bootstrapServers));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithMessageMaxBytes(int? messageMaxBytes)
    {
        _sharedConfigurationActions.Add(builder => builder.WithMessageMaxBytes(messageMaxBytes));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithMessageCopyMaxBytes(int? messageCopyMaxBytes)
    {
        _sharedConfigurationActions.Add(builder => builder.WithMessageCopyMaxBytes(messageCopyMaxBytes));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithReceiveMessageMaxBytes(int? receiveMessageMaxBytes)
    {
        _sharedConfigurationActions.Add(builder => builder.WithReceiveMessageMaxBytes(receiveMessageMaxBytes));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithMaxInFlight(int? maxInFlight)
    {
        _sharedConfigurationActions.Add(builder => builder.WithMaxInFlight(maxInFlight));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithTopicMetadataRefreshIntervalMs(int? topicMetadataRefreshIntervalMs)
    {
        _sharedConfigurationActions.Add(builder => builder.WithTopicMetadataRefreshIntervalMs(topicMetadataRefreshIntervalMs));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithMetadataMaxAgeMs(int? metadataMaxAgeMs)
    {
        _sharedConfigurationActions.Add(builder => builder.WithMetadataMaxAgeMs(metadataMaxAgeMs));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithTopicMetadataRefreshFastIntervalMs(int? topicMetadataRefreshFastIntervalMs)
    {
        _sharedConfigurationActions.Add(builder => builder.WithTopicMetadataRefreshFastIntervalMs(topicMetadataRefreshFastIntervalMs));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithTopicMetadataPropagationMaxMs(int? topicMetadataPropagationMaxMs)
    {
        _sharedConfigurationActions.Add(builder => builder.WithTopicMetadataPropagationMaxMs(topicMetadataPropagationMaxMs));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithTopicBlacklist(string? topicBlacklist)
    {
        _sharedConfigurationActions.Add(builder => builder.WithTopicBlacklist(topicBlacklist));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithDebug(string? debug)
    {
        _sharedConfigurationActions.Add(builder => builder.WithDebug(debug));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithSocketTimeoutMs(int? socketTimeoutMs)
    {
        _sharedConfigurationActions.Add(builder => builder.WithSocketTimeoutMs(socketTimeoutMs));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithSocketSendBufferBytes(int? socketSendBufferBytes)
    {
        _sharedConfigurationActions.Add(builder => builder.WithSocketSendBufferBytes(socketSendBufferBytes));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithSocketReceiveBufferBytes(int? socketReceiveBufferBytes)
    {
        _sharedConfigurationActions.Add(builder => builder.WithSocketReceiveBufferBytes(socketReceiveBufferBytes));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithSocketMaxFails(int? socketMaxFails)
    {
        _sharedConfigurationActions.Add(builder => builder.WithSocketMaxFails(socketMaxFails));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithBrokerAddressTtl(int? brokerAddressTtl)
    {
        _sharedConfigurationActions.Add(builder => builder.WithBrokerAddressTtl(brokerAddressTtl));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithBrokerAddressFamily(BrokerAddressFamily? brokerAddressFamily)
    {
        _sharedConfigurationActions.Add(builder => builder.WithBrokerAddressFamily(brokerAddressFamily));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithSocketConnectionSetupTimeoutMs(int? socketConnectionSetupTimeoutMs)
    {
        _sharedConfigurationActions.Add(builder => builder.WithSocketConnectionSetupTimeoutMs(socketConnectionSetupTimeoutMs));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithConnectionsMaxIdleMs(int? connectionsMaxIdleMs)
    {
        _sharedConfigurationActions.Add(builder => builder.WithConnectionsMaxIdleMs(connectionsMaxIdleMs));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithReconnectBackoffMs(int? reconnectBackoffMs)
    {
        _sharedConfigurationActions.Add(builder => builder.WithReconnectBackoffMs(reconnectBackoffMs));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithReconnectBackoffMaxMs(int? reconnectBackoffMaxMs)
    {
        _sharedConfigurationActions.Add(builder => builder.WithReconnectBackoffMaxMs(reconnectBackoffMaxMs));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithStatisticsIntervalMs(int? statisticsIntervalMs)
    {
        _sharedConfigurationActions.Add(builder => builder.WithStatisticsIntervalMs(statisticsIntervalMs));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithApiVersionRequestTimeoutMs(int? apiVersionRequestTimeoutMs)
    {
        _sharedConfigurationActions.Add(builder => builder.WithApiVersionRequestTimeoutMs(apiVersionRequestTimeoutMs));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithApiVersionFallbackMs(int? apiVersionFallbackMs)
    {
        _sharedConfigurationActions.Add(builder => builder.WithApiVersionFallbackMs(apiVersionFallbackMs));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithBrokerVersionFallback(string? brokerVersionFallback)
    {
        _sharedConfigurationActions.Add(builder => builder.WithBrokerVersionFallback(brokerVersionFallback));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithSecurityProtocol(SecurityProtocol? securityProtocol)
    {
        _sharedConfigurationActions.Add(builder => builder.WithSecurityProtocol(securityProtocol));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithSslCipherSuites(string? sslCipherSuites)
    {
        _sharedConfigurationActions.Add(builder => builder.WithSslCipherSuites(sslCipherSuites));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithSslCurvesList(string? sslCurvesList)
    {
        _sharedConfigurationActions.Add(builder => builder.WithSslCurvesList(sslCurvesList));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithSslSigalgsList(string? sslSigalgsList)
    {
        _sharedConfigurationActions.Add(builder => builder.WithSslSigalgsList(sslSigalgsList));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithSslKeyLocation(string? sslKeyLocation)
    {
        _sharedConfigurationActions.Add(builder => builder.WithSslKeyLocation(sslKeyLocation));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithSslKeyPassword(string? sslKeyPassword)
    {
        _sharedConfigurationActions.Add(builder => builder.WithSslKeyPassword(sslKeyPassword));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithSslKeyPem(string? sslKeyPem)
    {
        _sharedConfigurationActions.Add(builder => builder.WithSslKeyPem(sslKeyPem));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithSslCertificateLocation(string? sslCertificateLocation)
    {
        _sharedConfigurationActions.Add(builder => builder.WithSslCertificateLocation(sslCertificateLocation));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithSslCertificatePem(string? sslCertificatePem)
    {
        _sharedConfigurationActions.Add(builder => builder.WithSslCertificatePem(sslCertificatePem));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithSslCaLocation(string? sslCaLocation)
    {
        _sharedConfigurationActions.Add(builder => builder.WithSslCaLocation(sslCaLocation));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithSslCaPem(string? sslCaPem)
    {
        _sharedConfigurationActions.Add(builder => builder.WithSslCaPem(sslCaPem));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithSslCaCertificateStores(string? sslCaCertificateStores)
    {
        _sharedConfigurationActions.Add(builder => builder.WithSslCaCertificateStores(sslCaCertificateStores));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithSslCrlLocation(string? sslCrlLocation)
    {
        _sharedConfigurationActions.Add(builder => builder.WithSslCrlLocation(sslCrlLocation));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithSslKeystoreLocation(string? sslKeystoreLocation)
    {
        _sharedConfigurationActions.Add(builder => builder.WithSslKeystoreLocation(sslKeystoreLocation));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithSslKeystorePassword(string? sslKeystorePassword)
    {
        _sharedConfigurationActions.Add(builder => builder.WithSslKeystorePassword(sslKeystorePassword));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithSslProviders(string? sslProviders)
    {
        _sharedConfigurationActions.Add(builder => builder.WithSslProviders(sslProviders));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithSslEngineLocation(string? sslEngineLocation)
    {
        _sharedConfigurationActions.Add(builder => builder.WithSslEngineLocation(sslEngineLocation));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithSslEngineId(string? sslEngineId)
    {
        _sharedConfigurationActions.Add(builder => builder.WithSslEngineId(sslEngineId));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithSslEndpointIdentificationAlgorithm(SslEndpointIdentificationAlgorithm? sslEndpointIdentificationAlgorithm)
    {
        _sharedConfigurationActions.Add(builder => builder.WithSslEndpointIdentificationAlgorithm(sslEndpointIdentificationAlgorithm));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithSaslKerberosServiceName(string? saslKerberosServiceName)
    {
        _sharedConfigurationActions.Add(builder => builder.WithSaslKerberosServiceName(saslKerberosServiceName));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithSaslKerberosPrincipal(string? saslKerberosPrincipal)
    {
        _sharedConfigurationActions.Add(builder => builder.WithSaslKerberosPrincipal(saslKerberosPrincipal));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithSaslKerberosKinitCmd(string? saslKerberosKinitCmd)
    {
        _sharedConfigurationActions.Add(builder => builder.WithSaslKerberosKinitCmd(saslKerberosKinitCmd));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithSaslKerberosKeytab(string? saslKerberosKeytab)
    {
        _sharedConfigurationActions.Add(builder => builder.WithSaslKerberosKeytab(saslKerberosKeytab));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithSaslKerberosMinTimeBeforeRelogin(int? saslKerberosMinTimeBeforeRelogin)
    {
        _sharedConfigurationActions.Add(builder => builder.WithSaslKerberosMinTimeBeforeRelogin(saslKerberosMinTimeBeforeRelogin));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithSaslUsername(string? saslUsername)
    {
        _sharedConfigurationActions.Add(builder => builder.WithSaslUsername(saslUsername));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithSaslPassword(string? saslPassword)
    {
        _sharedConfigurationActions.Add(builder => builder.WithSaslPassword(saslPassword));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithSaslOauthbearerConfig(string? saslOauthbearerConfig)
    {
        _sharedConfigurationActions.Add(builder => builder.WithSaslOauthbearerConfig(saslOauthbearerConfig));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithSaslOauthbearerMethod(SaslOauthbearerMethod? saslOauthbearerMethod)
    {
        _sharedConfigurationActions.Add(builder => builder.WithSaslOauthbearerMethod(saslOauthbearerMethod));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithSaslOauthbearerClientId(string? saslOauthbearerClientId)
    {
        _sharedConfigurationActions.Add(builder => builder.WithSaslOauthbearerClientId(saslOauthbearerClientId));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithSaslOauthbearerClientSecret(string? saslOauthbearerClientSecret)
    {
        _sharedConfigurationActions.Add(builder => builder.WithSaslOauthbearerClientSecret(saslOauthbearerClientSecret));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithSaslOauthbearerScope(string? saslOauthbearerScope)
    {
        _sharedConfigurationActions.Add(builder => builder.WithSaslOauthbearerScope(saslOauthbearerScope));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithSaslOauthbearerExtensions(string? saslOauthbearerExtensions)
    {
        _sharedConfigurationActions.Add(builder => builder.WithSaslOauthbearerExtensions(saslOauthbearerExtensions));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithSaslOauthbearerTokenEndpointUrl(string? saslOauthbearerTokenEndpointUrl)
    {
        _sharedConfigurationActions.Add(builder => builder.WithSaslOauthbearerTokenEndpointUrl(saslOauthbearerTokenEndpointUrl));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithPluginLibraryPaths(string? pluginLibraryPaths)
    {
        _sharedConfigurationActions.Add(builder => builder.WithPluginLibraryPaths(pluginLibraryPaths));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithClientRack(string? clientRack)
    {
        _sharedConfigurationActions.Add(builder => builder.WithClientRack(clientRack));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithCancellationDelayMaxMs(int cancellationDelayMaxMs)
    {
        _sharedConfigurationActions.Add(builder => builder.WithCancellationDelayMaxMs(cancellationDelayMaxMs));
        return this;
    }

    internal KafkaClientsConfigurationBuilder WithTopicMetadataRefreshSparse(bool? topicMetadataRefreshSparse)
    {
        _sharedConfigurationActions.Add(builder => builder.WithTopicMetadataRefreshSparse(topicMetadataRefreshSparse));
        return this;
    }

    internal KafkaClientsConfigurationBuilder WithSocketKeepaliveEnable(bool? socketKeepaliveEnable)
    {
        _sharedConfigurationActions.Add(builder => builder.WithSocketKeepaliveEnable(socketKeepaliveEnable));
        return this;
    }

    internal KafkaClientsConfigurationBuilder WithSocketNagleDisable(bool? socketNagleDisable)
    {
        _sharedConfigurationActions.Add(builder => builder.WithSocketNagleDisable(socketNagleDisable));
        return this;
    }

    internal KafkaClientsConfigurationBuilder WithApiVersionRequest(bool? apiVersionRequest)
    {
        _sharedConfigurationActions.Add(builder => builder.WithApiVersionRequest(apiVersionRequest));
        return this;
    }

    internal KafkaClientsConfigurationBuilder WithAllowAutoCreateTopics(bool? allowAutoCreateTopics)
    {
        _sharedConfigurationActions.Add(builder => builder.WithAllowAutoCreateTopics(allowAutoCreateTopics));
        return this;
    }

    internal KafkaClientsConfigurationBuilder WithEnableSslCertificateVerification(bool? enableSslCertificateVerification)
    {
        _sharedConfigurationActions.Add(builder => builder.WithEnableSslCertificateVerification(enableSslCertificateVerification));
        return this;
    }

    internal KafkaClientsConfigurationBuilder WithEnableSaslOauthbearerUnsecureJwt(bool? enableSaslOauthbearerUnsecureJwt)
    {
        _sharedConfigurationActions.Add(builder => builder.WithEnableSaslOauthbearerUnsecureJwt(enableSaslOauthbearerUnsecureJwt));
        return this;
    }
}

/// <content>
///     The autogenerated part of the <see cref="KafkaClientConfigurationBuilder{TClientConfig,TBuilder}" /> class.
/// </content>
[SuppressMessage("StyleCop.CSharp.MaintainabilityRules", "SA1402:File may only contain a single type", Justification = "Autogenerated all at once")]
[SuppressMessage("StyleCop.CSharp.OrderingRules", "SA1202: 'public' members should come before 'internal' members", Justification = "Autogenerated")]
[SuppressMessage("StyleCop.CSharp.DocumentationRules", "SA1600:Elements should be documented", Justification = "Documented in other partial")]
[SuppressMessage("StyleCop.CSharp.DocumentationRules", "SA1601:Partial elements should be documented", Justification = "Autogenerated")]
public partial class KafkaClientConfigurationBuilder<TClientConfig, TBuilder> : IKafkaClientConfigurationBuilder
{
    public partial TBuilder WithSaslMechanism(SaslMechanism? saslMechanism)
    {
        ClientConfig.SaslMechanism = saslMechanism;
        return This;
    }

    public partial TBuilder WithAcks(Acks? acks)
    {
        ClientConfig.Acks = acks;
        return This;
    }

    public partial TBuilder WithClientId(string? clientId)
    {
        ClientConfig.ClientId = clientId;
        return This;
    }

    public partial TBuilder WithBootstrapServers(string? bootstrapServers)
    {
        ClientConfig.BootstrapServers = bootstrapServers;
        return This;
    }

    public partial TBuilder WithMessageMaxBytes(int? messageMaxBytes)
    {
        ClientConfig.MessageMaxBytes = messageMaxBytes;
        return This;
    }

    public partial TBuilder WithMessageCopyMaxBytes(int? messageCopyMaxBytes)
    {
        ClientConfig.MessageCopyMaxBytes = messageCopyMaxBytes;
        return This;
    }

    public partial TBuilder WithReceiveMessageMaxBytes(int? receiveMessageMaxBytes)
    {
        ClientConfig.ReceiveMessageMaxBytes = receiveMessageMaxBytes;
        return This;
    }

    public partial TBuilder WithMaxInFlight(int? maxInFlight)
    {
        ClientConfig.MaxInFlight = maxInFlight;
        return This;
    }

    public partial TBuilder WithTopicMetadataRefreshIntervalMs(int? topicMetadataRefreshIntervalMs)
    {
        ClientConfig.TopicMetadataRefreshIntervalMs = topicMetadataRefreshIntervalMs;
        return This;
    }

    public partial TBuilder WithMetadataMaxAgeMs(int? metadataMaxAgeMs)
    {
        ClientConfig.MetadataMaxAgeMs = metadataMaxAgeMs;
        return This;
    }

    public partial TBuilder WithTopicMetadataRefreshFastIntervalMs(int? topicMetadataRefreshFastIntervalMs)
    {
        ClientConfig.TopicMetadataRefreshFastIntervalMs = topicMetadataRefreshFastIntervalMs;
        return This;
    }

    public partial TBuilder WithTopicMetadataPropagationMaxMs(int? topicMetadataPropagationMaxMs)
    {
        ClientConfig.TopicMetadataPropagationMaxMs = topicMetadataPropagationMaxMs;
        return This;
    }

    public partial TBuilder WithTopicBlacklist(string? topicBlacklist)
    {
        ClientConfig.TopicBlacklist = topicBlacklist;
        return This;
    }

    public partial TBuilder WithDebug(string? debug)
    {
        ClientConfig.Debug = debug;
        return This;
    }

    public partial TBuilder WithSocketTimeoutMs(int? socketTimeoutMs)
    {
        ClientConfig.SocketTimeoutMs = socketTimeoutMs;
        return This;
    }

    public partial TBuilder WithSocketSendBufferBytes(int? socketSendBufferBytes)
    {
        ClientConfig.SocketSendBufferBytes = socketSendBufferBytes;
        return This;
    }

    public partial TBuilder WithSocketReceiveBufferBytes(int? socketReceiveBufferBytes)
    {
        ClientConfig.SocketReceiveBufferBytes = socketReceiveBufferBytes;
        return This;
    }

    public partial TBuilder WithSocketMaxFails(int? socketMaxFails)
    {
        ClientConfig.SocketMaxFails = socketMaxFails;
        return This;
    }

    public partial TBuilder WithBrokerAddressTtl(int? brokerAddressTtl)
    {
        ClientConfig.BrokerAddressTtl = brokerAddressTtl;
        return This;
    }

    public partial TBuilder WithBrokerAddressFamily(BrokerAddressFamily? brokerAddressFamily)
    {
        ClientConfig.BrokerAddressFamily = brokerAddressFamily;
        return This;
    }

    public partial TBuilder WithSocketConnectionSetupTimeoutMs(int? socketConnectionSetupTimeoutMs)
    {
        ClientConfig.SocketConnectionSetupTimeoutMs = socketConnectionSetupTimeoutMs;
        return This;
    }

    public partial TBuilder WithConnectionsMaxIdleMs(int? connectionsMaxIdleMs)
    {
        ClientConfig.ConnectionsMaxIdleMs = connectionsMaxIdleMs;
        return This;
    }

    public partial TBuilder WithReconnectBackoffMs(int? reconnectBackoffMs)
    {
        ClientConfig.ReconnectBackoffMs = reconnectBackoffMs;
        return This;
    }

    public partial TBuilder WithReconnectBackoffMaxMs(int? reconnectBackoffMaxMs)
    {
        ClientConfig.ReconnectBackoffMaxMs = reconnectBackoffMaxMs;
        return This;
    }

    public partial TBuilder WithStatisticsIntervalMs(int? statisticsIntervalMs)
    {
        ClientConfig.StatisticsIntervalMs = statisticsIntervalMs;
        return This;
    }

    public partial TBuilder WithApiVersionRequestTimeoutMs(int? apiVersionRequestTimeoutMs)
    {
        ClientConfig.ApiVersionRequestTimeoutMs = apiVersionRequestTimeoutMs;
        return This;
    }

    public partial TBuilder WithApiVersionFallbackMs(int? apiVersionFallbackMs)
    {
        ClientConfig.ApiVersionFallbackMs = apiVersionFallbackMs;
        return This;
    }

    public partial TBuilder WithBrokerVersionFallback(string? brokerVersionFallback)
    {
        ClientConfig.BrokerVersionFallback = brokerVersionFallback;
        return This;
    }

    public partial TBuilder WithSecurityProtocol(SecurityProtocol? securityProtocol)
    {
        ClientConfig.SecurityProtocol = securityProtocol;
        return This;
    }

    public partial TBuilder WithSslCipherSuites(string? sslCipherSuites)
    {
        ClientConfig.SslCipherSuites = sslCipherSuites;
        return This;
    }

    public partial TBuilder WithSslCurvesList(string? sslCurvesList)
    {
        ClientConfig.SslCurvesList = sslCurvesList;
        return This;
    }

    public partial TBuilder WithSslSigalgsList(string? sslSigalgsList)
    {
        ClientConfig.SslSigalgsList = sslSigalgsList;
        return This;
    }

    public partial TBuilder WithSslKeyLocation(string? sslKeyLocation)
    {
        ClientConfig.SslKeyLocation = sslKeyLocation;
        return This;
    }

    public partial TBuilder WithSslKeyPassword(string? sslKeyPassword)
    {
        ClientConfig.SslKeyPassword = sslKeyPassword;
        return This;
    }

    public partial TBuilder WithSslKeyPem(string? sslKeyPem)
    {
        ClientConfig.SslKeyPem = sslKeyPem;
        return This;
    }

    public partial TBuilder WithSslCertificateLocation(string? sslCertificateLocation)
    {
        ClientConfig.SslCertificateLocation = sslCertificateLocation;
        return This;
    }

    public partial TBuilder WithSslCertificatePem(string? sslCertificatePem)
    {
        ClientConfig.SslCertificatePem = sslCertificatePem;
        return This;
    }

    public partial TBuilder WithSslCaLocation(string? sslCaLocation)
    {
        ClientConfig.SslCaLocation = sslCaLocation;
        return This;
    }

    public partial TBuilder WithSslCaPem(string? sslCaPem)
    {
        ClientConfig.SslCaPem = sslCaPem;
        return This;
    }

    public partial TBuilder WithSslCaCertificateStores(string? sslCaCertificateStores)
    {
        ClientConfig.SslCaCertificateStores = sslCaCertificateStores;
        return This;
    }

    public partial TBuilder WithSslCrlLocation(string? sslCrlLocation)
    {
        ClientConfig.SslCrlLocation = sslCrlLocation;
        return This;
    }

    public partial TBuilder WithSslKeystoreLocation(string? sslKeystoreLocation)
    {
        ClientConfig.SslKeystoreLocation = sslKeystoreLocation;
        return This;
    }

    public partial TBuilder WithSslKeystorePassword(string? sslKeystorePassword)
    {
        ClientConfig.SslKeystorePassword = sslKeystorePassword;
        return This;
    }

    public partial TBuilder WithSslProviders(string? sslProviders)
    {
        ClientConfig.SslProviders = sslProviders;
        return This;
    }

    public partial TBuilder WithSslEngineLocation(string? sslEngineLocation)
    {
        ClientConfig.SslEngineLocation = sslEngineLocation;
        return This;
    }

    public partial TBuilder WithSslEngineId(string? sslEngineId)
    {
        ClientConfig.SslEngineId = sslEngineId;
        return This;
    }

    public partial TBuilder WithSslEndpointIdentificationAlgorithm(SslEndpointIdentificationAlgorithm? sslEndpointIdentificationAlgorithm)
    {
        ClientConfig.SslEndpointIdentificationAlgorithm = sslEndpointIdentificationAlgorithm;
        return This;
    }

    public partial TBuilder WithSaslKerberosServiceName(string? saslKerberosServiceName)
    {
        ClientConfig.SaslKerberosServiceName = saslKerberosServiceName;
        return This;
    }

    public partial TBuilder WithSaslKerberosPrincipal(string? saslKerberosPrincipal)
    {
        ClientConfig.SaslKerberosPrincipal = saslKerberosPrincipal;
        return This;
    }

    public partial TBuilder WithSaslKerberosKinitCmd(string? saslKerberosKinitCmd)
    {
        ClientConfig.SaslKerberosKinitCmd = saslKerberosKinitCmd;
        return This;
    }

    public partial TBuilder WithSaslKerberosKeytab(string? saslKerberosKeytab)
    {
        ClientConfig.SaslKerberosKeytab = saslKerberosKeytab;
        return This;
    }

    public partial TBuilder WithSaslKerberosMinTimeBeforeRelogin(int? saslKerberosMinTimeBeforeRelogin)
    {
        ClientConfig.SaslKerberosMinTimeBeforeRelogin = saslKerberosMinTimeBeforeRelogin;
        return This;
    }

    public partial TBuilder WithSaslUsername(string? saslUsername)
    {
        ClientConfig.SaslUsername = saslUsername;
        return This;
    }

    public partial TBuilder WithSaslPassword(string? saslPassword)
    {
        ClientConfig.SaslPassword = saslPassword;
        return This;
    }

    public partial TBuilder WithSaslOauthbearerConfig(string? saslOauthbearerConfig)
    {
        ClientConfig.SaslOauthbearerConfig = saslOauthbearerConfig;
        return This;
    }

    public partial TBuilder WithSaslOauthbearerMethod(SaslOauthbearerMethod? saslOauthbearerMethod)
    {
        ClientConfig.SaslOauthbearerMethod = saslOauthbearerMethod;
        return This;
    }

    public partial TBuilder WithSaslOauthbearerClientId(string? saslOauthbearerClientId)
    {
        ClientConfig.SaslOauthbearerClientId = saslOauthbearerClientId;
        return This;
    }

    public partial TBuilder WithSaslOauthbearerClientSecret(string? saslOauthbearerClientSecret)
    {
        ClientConfig.SaslOauthbearerClientSecret = saslOauthbearerClientSecret;
        return This;
    }

    public partial TBuilder WithSaslOauthbearerScope(string? saslOauthbearerScope)
    {
        ClientConfig.SaslOauthbearerScope = saslOauthbearerScope;
        return This;
    }

    public partial TBuilder WithSaslOauthbearerExtensions(string? saslOauthbearerExtensions)
    {
        ClientConfig.SaslOauthbearerExtensions = saslOauthbearerExtensions;
        return This;
    }

    public partial TBuilder WithSaslOauthbearerTokenEndpointUrl(string? saslOauthbearerTokenEndpointUrl)
    {
        ClientConfig.SaslOauthbearerTokenEndpointUrl = saslOauthbearerTokenEndpointUrl;
        return This;
    }

    public partial TBuilder WithPluginLibraryPaths(string? pluginLibraryPaths)
    {
        ClientConfig.PluginLibraryPaths = pluginLibraryPaths;
        return This;
    }

    public partial TBuilder WithClientRack(string? clientRack)
    {
        ClientConfig.ClientRack = clientRack;
        return This;
    }

    public partial TBuilder WithCancellationDelayMaxMs(int cancellationDelayMaxMs)
    {
        ClientConfig.CancellationDelayMaxMs = cancellationDelayMaxMs;
        return This;
    }

    internal TBuilder WithTopicMetadataRefreshSparse(bool? topicMetadataRefreshSparse)
    {
        ClientConfig.TopicMetadataRefreshSparse = topicMetadataRefreshSparse;
        return This;
    }

    internal TBuilder WithSocketKeepaliveEnable(bool? socketKeepaliveEnable)
    {
        ClientConfig.SocketKeepaliveEnable = socketKeepaliveEnable;
        return This;
    }

    internal TBuilder WithSocketNagleDisable(bool? socketNagleDisable)
    {
        ClientConfig.SocketNagleDisable = socketNagleDisable;
        return This;
    }

    internal TBuilder WithApiVersionRequest(bool? apiVersionRequest)
    {
        ClientConfig.ApiVersionRequest = apiVersionRequest;
        return This;
    }

    internal TBuilder WithAllowAutoCreateTopics(bool? allowAutoCreateTopics)
    {
        ClientConfig.AllowAutoCreateTopics = allowAutoCreateTopics;
        return This;
    }

    internal TBuilder WithEnableSslCertificateVerification(bool? enableSslCertificateVerification)
    {
        ClientConfig.EnableSslCertificateVerification = enableSslCertificateVerification;
        return This;
    }

    internal TBuilder WithEnableSaslOauthbearerUnsecureJwt(bool? enableSaslOauthbearerUnsecureJwt)
    {
        ClientConfig.EnableSaslOauthbearerUnsecureJwt = enableSaslOauthbearerUnsecureJwt;
        return This;
    }

    void IKafkaClientConfigurationBuilder.WithSaslMechanism(SaslMechanism? saslMechanism) => WithSaslMechanism(saslMechanism);

    void IKafkaClientConfigurationBuilder.WithAcks(Acks? acks) => WithAcks(acks);

    void IKafkaClientConfigurationBuilder.WithClientId(string? clientId) => WithClientId(clientId);

    void IKafkaClientConfigurationBuilder.WithBootstrapServers(string? bootstrapServers) => WithBootstrapServers(bootstrapServers);

    void IKafkaClientConfigurationBuilder.WithMessageMaxBytes(int? messageMaxBytes) => WithMessageMaxBytes(messageMaxBytes);

    void IKafkaClientConfigurationBuilder.WithMessageCopyMaxBytes(int? messageCopyMaxBytes) => WithMessageCopyMaxBytes(messageCopyMaxBytes);

    void IKafkaClientConfigurationBuilder.WithReceiveMessageMaxBytes(int? receiveMessageMaxBytes) => WithReceiveMessageMaxBytes(receiveMessageMaxBytes);

    void IKafkaClientConfigurationBuilder.WithMaxInFlight(int? maxInFlight) => WithMaxInFlight(maxInFlight);

    void IKafkaClientConfigurationBuilder.WithTopicMetadataRefreshIntervalMs(int? topicMetadataRefreshIntervalMs) => WithTopicMetadataRefreshIntervalMs(topicMetadataRefreshIntervalMs);

    void IKafkaClientConfigurationBuilder.WithMetadataMaxAgeMs(int? metadataMaxAgeMs) => WithMetadataMaxAgeMs(metadataMaxAgeMs);

    void IKafkaClientConfigurationBuilder.WithTopicMetadataRefreshFastIntervalMs(int? topicMetadataRefreshFastIntervalMs) => WithTopicMetadataRefreshFastIntervalMs(topicMetadataRefreshFastIntervalMs);

    void IKafkaClientConfigurationBuilder.WithTopicMetadataRefreshSparse(bool? topicMetadataRefreshSparse) => WithTopicMetadataRefreshSparse(topicMetadataRefreshSparse);

    void IKafkaClientConfigurationBuilder.WithTopicMetadataPropagationMaxMs(int? topicMetadataPropagationMaxMs) => WithTopicMetadataPropagationMaxMs(topicMetadataPropagationMaxMs);

    void IKafkaClientConfigurationBuilder.WithTopicBlacklist(string? topicBlacklist) => WithTopicBlacklist(topicBlacklist);

    void IKafkaClientConfigurationBuilder.WithDebug(string? debug) => WithDebug(debug);

    void IKafkaClientConfigurationBuilder.WithSocketTimeoutMs(int? socketTimeoutMs) => WithSocketTimeoutMs(socketTimeoutMs);

    void IKafkaClientConfigurationBuilder.WithSocketSendBufferBytes(int? socketSendBufferBytes) => WithSocketSendBufferBytes(socketSendBufferBytes);

    void IKafkaClientConfigurationBuilder.WithSocketReceiveBufferBytes(int? socketReceiveBufferBytes) => WithSocketReceiveBufferBytes(socketReceiveBufferBytes);

    void IKafkaClientConfigurationBuilder.WithSocketKeepaliveEnable(bool? socketKeepaliveEnable) => WithSocketKeepaliveEnable(socketKeepaliveEnable);

    void IKafkaClientConfigurationBuilder.WithSocketNagleDisable(bool? socketNagleDisable) => WithSocketNagleDisable(socketNagleDisable);

    void IKafkaClientConfigurationBuilder.WithSocketMaxFails(int? socketMaxFails) => WithSocketMaxFails(socketMaxFails);

    void IKafkaClientConfigurationBuilder.WithBrokerAddressTtl(int? brokerAddressTtl) => WithBrokerAddressTtl(brokerAddressTtl);

    void IKafkaClientConfigurationBuilder.WithBrokerAddressFamily(BrokerAddressFamily? brokerAddressFamily) => WithBrokerAddressFamily(brokerAddressFamily);

    void IKafkaClientConfigurationBuilder.WithSocketConnectionSetupTimeoutMs(int? socketConnectionSetupTimeoutMs) => WithSocketConnectionSetupTimeoutMs(socketConnectionSetupTimeoutMs);

    void IKafkaClientConfigurationBuilder.WithConnectionsMaxIdleMs(int? connectionsMaxIdleMs) => WithConnectionsMaxIdleMs(connectionsMaxIdleMs);

    void IKafkaClientConfigurationBuilder.WithReconnectBackoffMs(int? reconnectBackoffMs) => WithReconnectBackoffMs(reconnectBackoffMs);

    void IKafkaClientConfigurationBuilder.WithReconnectBackoffMaxMs(int? reconnectBackoffMaxMs) => WithReconnectBackoffMaxMs(reconnectBackoffMaxMs);

    void IKafkaClientConfigurationBuilder.WithStatisticsIntervalMs(int? statisticsIntervalMs) => WithStatisticsIntervalMs(statisticsIntervalMs);

    void IKafkaClientConfigurationBuilder.WithApiVersionRequest(bool? apiVersionRequest) => WithApiVersionRequest(apiVersionRequest);

    void IKafkaClientConfigurationBuilder.WithApiVersionRequestTimeoutMs(int? apiVersionRequestTimeoutMs) => WithApiVersionRequestTimeoutMs(apiVersionRequestTimeoutMs);

    void IKafkaClientConfigurationBuilder.WithApiVersionFallbackMs(int? apiVersionFallbackMs) => WithApiVersionFallbackMs(apiVersionFallbackMs);

    void IKafkaClientConfigurationBuilder.WithBrokerVersionFallback(string? brokerVersionFallback) => WithBrokerVersionFallback(brokerVersionFallback);

    void IKafkaClientConfigurationBuilder.WithAllowAutoCreateTopics(bool? allowAutoCreateTopics) => WithAllowAutoCreateTopics(allowAutoCreateTopics);

    void IKafkaClientConfigurationBuilder.WithSecurityProtocol(SecurityProtocol? securityProtocol) => WithSecurityProtocol(securityProtocol);

    void IKafkaClientConfigurationBuilder.WithSslCipherSuites(string? sslCipherSuites) => WithSslCipherSuites(sslCipherSuites);

    void IKafkaClientConfigurationBuilder.WithSslCurvesList(string? sslCurvesList) => WithSslCurvesList(sslCurvesList);

    void IKafkaClientConfigurationBuilder.WithSslSigalgsList(string? sslSigalgsList) => WithSslSigalgsList(sslSigalgsList);

    void IKafkaClientConfigurationBuilder.WithSslKeyLocation(string? sslKeyLocation) => WithSslKeyLocation(sslKeyLocation);

    void IKafkaClientConfigurationBuilder.WithSslKeyPassword(string? sslKeyPassword) => WithSslKeyPassword(sslKeyPassword);

    void IKafkaClientConfigurationBuilder.WithSslKeyPem(string? sslKeyPem) => WithSslKeyPem(sslKeyPem);

    void IKafkaClientConfigurationBuilder.WithSslCertificateLocation(string? sslCertificateLocation) => WithSslCertificateLocation(sslCertificateLocation);

    void IKafkaClientConfigurationBuilder.WithSslCertificatePem(string? sslCertificatePem) => WithSslCertificatePem(sslCertificatePem);

    void IKafkaClientConfigurationBuilder.WithSslCaLocation(string? sslCaLocation) => WithSslCaLocation(sslCaLocation);

    void IKafkaClientConfigurationBuilder.WithSslCaPem(string? sslCaPem) => WithSslCaPem(sslCaPem);

    void IKafkaClientConfigurationBuilder.WithSslCaCertificateStores(string? sslCaCertificateStores) => WithSslCaCertificateStores(sslCaCertificateStores);

    void IKafkaClientConfigurationBuilder.WithSslCrlLocation(string? sslCrlLocation) => WithSslCrlLocation(sslCrlLocation);

    void IKafkaClientConfigurationBuilder.WithSslKeystoreLocation(string? sslKeystoreLocation) => WithSslKeystoreLocation(sslKeystoreLocation);

    void IKafkaClientConfigurationBuilder.WithSslKeystorePassword(string? sslKeystorePassword) => WithSslKeystorePassword(sslKeystorePassword);

    void IKafkaClientConfigurationBuilder.WithSslProviders(string? sslProviders) => WithSslProviders(sslProviders);

    void IKafkaClientConfigurationBuilder.WithSslEngineLocation(string? sslEngineLocation) => WithSslEngineLocation(sslEngineLocation);

    void IKafkaClientConfigurationBuilder.WithSslEngineId(string? sslEngineId) => WithSslEngineId(sslEngineId);

    void IKafkaClientConfigurationBuilder.WithEnableSslCertificateVerification(bool? enableSslCertificateVerification) => WithEnableSslCertificateVerification(enableSslCertificateVerification);

    void IKafkaClientConfigurationBuilder.WithSslEndpointIdentificationAlgorithm(SslEndpointIdentificationAlgorithm? sslEndpointIdentificationAlgorithm) => WithSslEndpointIdentificationAlgorithm(sslEndpointIdentificationAlgorithm);

    void IKafkaClientConfigurationBuilder.WithSaslKerberosServiceName(string? saslKerberosServiceName) => WithSaslKerberosServiceName(saslKerberosServiceName);

    void IKafkaClientConfigurationBuilder.WithSaslKerberosPrincipal(string? saslKerberosPrincipal) => WithSaslKerberosPrincipal(saslKerberosPrincipal);

    void IKafkaClientConfigurationBuilder.WithSaslKerberosKinitCmd(string? saslKerberosKinitCmd) => WithSaslKerberosKinitCmd(saslKerberosKinitCmd);

    void IKafkaClientConfigurationBuilder.WithSaslKerberosKeytab(string? saslKerberosKeytab) => WithSaslKerberosKeytab(saslKerberosKeytab);

    void IKafkaClientConfigurationBuilder.WithSaslKerberosMinTimeBeforeRelogin(int? saslKerberosMinTimeBeforeRelogin) => WithSaslKerberosMinTimeBeforeRelogin(saslKerberosMinTimeBeforeRelogin);

    void IKafkaClientConfigurationBuilder.WithSaslUsername(string? saslUsername) => WithSaslUsername(saslUsername);

    void IKafkaClientConfigurationBuilder.WithSaslPassword(string? saslPassword) => WithSaslPassword(saslPassword);

    void IKafkaClientConfigurationBuilder.WithSaslOauthbearerConfig(string? saslOauthbearerConfig) => WithSaslOauthbearerConfig(saslOauthbearerConfig);

    void IKafkaClientConfigurationBuilder.WithEnableSaslOauthbearerUnsecureJwt(bool? enableSaslOauthbearerUnsecureJwt) => WithEnableSaslOauthbearerUnsecureJwt(enableSaslOauthbearerUnsecureJwt);

    void IKafkaClientConfigurationBuilder.WithSaslOauthbearerMethod(SaslOauthbearerMethod? saslOauthbearerMethod) => WithSaslOauthbearerMethod(saslOauthbearerMethod);

    void IKafkaClientConfigurationBuilder.WithSaslOauthbearerClientId(string? saslOauthbearerClientId) => WithSaslOauthbearerClientId(saslOauthbearerClientId);

    void IKafkaClientConfigurationBuilder.WithSaslOauthbearerClientSecret(string? saslOauthbearerClientSecret) => WithSaslOauthbearerClientSecret(saslOauthbearerClientSecret);

    void IKafkaClientConfigurationBuilder.WithSaslOauthbearerScope(string? saslOauthbearerScope) => WithSaslOauthbearerScope(saslOauthbearerScope);

    void IKafkaClientConfigurationBuilder.WithSaslOauthbearerExtensions(string? saslOauthbearerExtensions) => WithSaslOauthbearerExtensions(saslOauthbearerExtensions);

    void IKafkaClientConfigurationBuilder.WithSaslOauthbearerTokenEndpointUrl(string? saslOauthbearerTokenEndpointUrl) => WithSaslOauthbearerTokenEndpointUrl(saslOauthbearerTokenEndpointUrl);

    void IKafkaClientConfigurationBuilder.WithPluginLibraryPaths(string? pluginLibraryPaths) => WithPluginLibraryPaths(pluginLibraryPaths);

    void IKafkaClientConfigurationBuilder.WithClientRack(string? clientRack) => WithClientRack(clientRack);

    void IKafkaClientConfigurationBuilder.WithCancellationDelayMaxMs(int cancellationDelayMaxMs) => WithCancellationDelayMaxMs(cancellationDelayMaxMs);
}

/// <content>
///     The autogenerated part of the <see cref="KafkaConsumerConfigurationBuilder" /> class.
/// </content>
[SuppressMessage("StyleCop.CSharp.MaintainabilityRules", "SA1402:File may only contain a single type", Justification = "Autogenerated all at once")]
[SuppressMessage("StyleCop.CSharp.OrderingRules", "SA1202: 'public' members should come before 'internal' members", Justification = "Autogenerated")]
[SuppressMessage("StyleCop.CSharp.DocumentationRules", "SA1600:Elements should be documented", Justification = "Documented in other partial")]
[SuppressMessage("StyleCop.CSharp.DocumentationRules", "SA1601:Partial elements should be documented", Justification = "Autogenerated")]
public partial class KafkaConsumerConfigurationBuilder
{
    public partial KafkaConsumerConfigurationBuilder WithConsumeResultFields(string? consumeResultFields)
    {
        ClientConfig.ConsumeResultFields = consumeResultFields;
        return This;
    }

    public partial KafkaConsumerConfigurationBuilder WithAutoOffsetReset(AutoOffsetReset? autoOffsetReset)
    {
        ClientConfig.AutoOffsetReset = autoOffsetReset;
        return This;
    }

    public partial KafkaConsumerConfigurationBuilder WithGroupInstanceId(string? groupInstanceId)
    {
        ClientConfig.GroupInstanceId = groupInstanceId;
        return This;
    }

    public partial KafkaConsumerConfigurationBuilder WithPartitionAssignmentStrategy(PartitionAssignmentStrategy? partitionAssignmentStrategy)
    {
        ClientConfig.PartitionAssignmentStrategy = partitionAssignmentStrategy;
        return This;
    }

    public partial KafkaConsumerConfigurationBuilder WithSessionTimeoutMs(int? sessionTimeoutMs)
    {
        ClientConfig.SessionTimeoutMs = sessionTimeoutMs;
        return This;
    }

    public partial KafkaConsumerConfigurationBuilder WithHeartbeatIntervalMs(int? heartbeatIntervalMs)
    {
        ClientConfig.HeartbeatIntervalMs = heartbeatIntervalMs;
        return This;
    }

    public partial KafkaConsumerConfigurationBuilder WithGroupProtocolType(string? groupProtocolType)
    {
        ClientConfig.GroupProtocolType = groupProtocolType;
        return This;
    }

    public partial KafkaConsumerConfigurationBuilder WithCoordinatorQueryIntervalMs(int? coordinatorQueryIntervalMs)
    {
        ClientConfig.CoordinatorQueryIntervalMs = coordinatorQueryIntervalMs;
        return This;
    }

    public partial KafkaConsumerConfigurationBuilder WithMaxPollIntervalMs(int? maxPollIntervalMs)
    {
        ClientConfig.MaxPollIntervalMs = maxPollIntervalMs;
        return This;
    }

    public partial KafkaConsumerConfigurationBuilder WithAutoCommitIntervalMs(int? autoCommitIntervalMs)
    {
        ClientConfig.AutoCommitIntervalMs = autoCommitIntervalMs;
        return This;
    }

    public partial KafkaConsumerConfigurationBuilder WithQueuedMinMessages(int? queuedMinMessages)
    {
        ClientConfig.QueuedMinMessages = queuedMinMessages;
        return This;
    }

    public partial KafkaConsumerConfigurationBuilder WithQueuedMaxMessagesKbytes(int? queuedMaxMessagesKbytes)
    {
        ClientConfig.QueuedMaxMessagesKbytes = queuedMaxMessagesKbytes;
        return This;
    }

    public partial KafkaConsumerConfigurationBuilder WithFetchWaitMaxMs(int? fetchWaitMaxMs)
    {
        ClientConfig.FetchWaitMaxMs = fetchWaitMaxMs;
        return This;
    }

    public partial KafkaConsumerConfigurationBuilder WithMaxPartitionFetchBytes(int? maxPartitionFetchBytes)
    {
        ClientConfig.MaxPartitionFetchBytes = maxPartitionFetchBytes;
        return This;
    }

    public partial KafkaConsumerConfigurationBuilder WithFetchMaxBytes(int? fetchMaxBytes)
    {
        ClientConfig.FetchMaxBytes = fetchMaxBytes;
        return This;
    }

    public partial KafkaConsumerConfigurationBuilder WithFetchMinBytes(int? fetchMinBytes)
    {
        ClientConfig.FetchMinBytes = fetchMinBytes;
        return This;
    }

    public partial KafkaConsumerConfigurationBuilder WithFetchErrorBackoffMs(int? fetchErrorBackoffMs)
    {
        ClientConfig.FetchErrorBackoffMs = fetchErrorBackoffMs;
        return This;
    }

    public partial KafkaConsumerConfigurationBuilder WithIsolationLevel(IsolationLevel? isolationLevel)
    {
        ClientConfig.IsolationLevel = isolationLevel;
        return This;
    }

    internal KafkaConsumerConfigurationBuilder WithEnableAutoCommit(bool? enableAutoCommit)
    {
        ClientConfig.EnableAutoCommit = enableAutoCommit;
        return This;
    }

    internal KafkaConsumerConfigurationBuilder WithEnablePartitionEof(bool? enablePartitionEof)
    {
        ClientConfig.EnablePartitionEof = enablePartitionEof;
        return This;
    }

    internal KafkaConsumerConfigurationBuilder WithCheckCrcs(bool? checkCrcs)
    {
        ClientConfig.CheckCrcs = checkCrcs;
        return This;
    }
}

/// <content>
///     The autogenerated part of the <see cref="KafkaProducerConfigurationBuilder" /> class.
/// </content>
[SuppressMessage("StyleCop.CSharp.MaintainabilityRules", "SA1402:File may only contain a single type", Justification = "Autogenerated all at once")]
[SuppressMessage("StyleCop.CSharp.OrderingRules", "SA1202: 'public' members should come before 'internal' members", Justification = "Autogenerated")]
[SuppressMessage("StyleCop.CSharp.DocumentationRules", "SA1600:Elements should be documented", Justification = "Documented in other partial")]
[SuppressMessage("StyleCop.CSharp.DocumentationRules", "SA1601:Partial elements should be documented", Justification = "Autogenerated")]
public partial class KafkaProducerConfigurationBuilder
{
    public partial KafkaProducerConfigurationBuilder WithRequestTimeoutMs(int? requestTimeoutMs)
    {
        ClientConfig.RequestTimeoutMs = requestTimeoutMs;
        return This;
    }

    public partial KafkaProducerConfigurationBuilder WithMessageTimeoutMs(int? messageTimeoutMs)
    {
        ClientConfig.MessageTimeoutMs = messageTimeoutMs;
        return This;
    }

    public partial KafkaProducerConfigurationBuilder WithPartitioner(Partitioner? partitioner)
    {
        ClientConfig.Partitioner = partitioner;
        return This;
    }

    public partial KafkaProducerConfigurationBuilder WithCompressionLevel(int? compressionLevel)
    {
        ClientConfig.CompressionLevel = compressionLevel;
        return This;
    }

    internal KafkaProducerConfigurationBuilder WithTransactionalId(string? transactionalId)
    {
        ClientConfig.TransactionalId = transactionalId;
        return This;
    }

    public partial KafkaProducerConfigurationBuilder WithTransactionTimeoutMs(int? transactionTimeoutMs)
    {
        ClientConfig.TransactionTimeoutMs = transactionTimeoutMs;
        return This;
    }

    public partial KafkaProducerConfigurationBuilder WithQueueBufferingMaxMessages(int? queueBufferingMaxMessages)
    {
        ClientConfig.QueueBufferingMaxMessages = queueBufferingMaxMessages;
        return This;
    }

    public partial KafkaProducerConfigurationBuilder WithQueueBufferingMaxKbytes(int? queueBufferingMaxKbytes)
    {
        ClientConfig.QueueBufferingMaxKbytes = queueBufferingMaxKbytes;
        return This;
    }

    public partial KafkaProducerConfigurationBuilder WithLingerMs(double? lingerMs)
    {
        ClientConfig.LingerMs = lingerMs;
        return This;
    }

    public partial KafkaProducerConfigurationBuilder WithMessageSendMaxRetries(int? messageSendMaxRetries)
    {
        ClientConfig.MessageSendMaxRetries = messageSendMaxRetries;
        return This;
    }

    public partial KafkaProducerConfigurationBuilder WithRetryBackoffMs(int? retryBackoffMs)
    {
        ClientConfig.RetryBackoffMs = retryBackoffMs;
        return This;
    }

    public partial KafkaProducerConfigurationBuilder WithQueueBufferingBackpressureThreshold(int? queueBufferingBackpressureThreshold)
    {
        ClientConfig.QueueBufferingBackpressureThreshold = queueBufferingBackpressureThreshold;
        return This;
    }

    public partial KafkaProducerConfigurationBuilder WithCompressionType(CompressionType? compressionType)
    {
        ClientConfig.CompressionType = compressionType;
        return This;
    }

    public partial KafkaProducerConfigurationBuilder WithBatchNumMessages(int? batchNumMessages)
    {
        ClientConfig.BatchNumMessages = batchNumMessages;
        return This;
    }

    public partial KafkaProducerConfigurationBuilder WithBatchSize(int? batchSize)
    {
        ClientConfig.BatchSize = batchSize;
        return This;
    }

    public partial KafkaProducerConfigurationBuilder WithStickyPartitioningLingerMs(int? stickyPartitioningLingerMs)
    {
        ClientConfig.StickyPartitioningLingerMs = stickyPartitioningLingerMs;
        return This;
    }

    internal KafkaProducerConfigurationBuilder WithEnableDeliveryReports(bool? enableDeliveryReports)
    {
        ClientConfig.EnableDeliveryReports = enableDeliveryReports;
        return This;
    }

    internal KafkaProducerConfigurationBuilder WithEnableIdempotence(bool? enableIdempotence)
    {
        ClientConfig.EnableIdempotence = enableIdempotence;
        return This;
    }

    internal KafkaProducerConfigurationBuilder WithEnableGaplessGuarantee(bool? enableGaplessGuarantee)
    {
        ClientConfig.EnableGaplessGuarantee = enableGaplessGuarantee;
        return This;
    }
}
