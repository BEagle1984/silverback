// Copyright (c) 2025 Sergio Aquilini
// This code is licensed under MIT license (see LICENSE file for details)

/*******************************************************************************************
  Note: These proxies are generated using Silverback.Tools.KafkaConfigClassGenerator
        located under /tools/
********************************************************************************************/

using System.Diagnostics.CodeAnalysis;
using Confluent.Kafka;

namespace Silverback.Messaging.Configuration.Kafka;

/// <content>
///     The autogenerated part of the <see cref="KafkaClientConfiguration{TConfluentConfig}" /> class.
/// </content>
[SuppressMessage("StyleCop.CSharp.MaintainabilityRules", "SA1402:File may only contain a single type", Justification = "Autogenerated all at once")]
[SuppressMessage("Design", "CA1044:Properties should not be write only", Justification = "Accessors generated according to wrapped class")]
public partial record KafkaClientConfiguration<TConfluentConfig>
{
    /// <summary>
    ///     Gets the SASL mechanism to use for authentication. Supported: GSSAPI, PLAIN, SCRAM-SHA-256, SCRAM-SHA-512.
    /// </summary>
    public SaslMechanism? SaslMechanism { get; init; }

    /// <summary>
    ///     Gets the number of acknowledgements that the leader broker must receive from the in-sync replicas before responding to the request:
    ///     <see cref="Confluent.Kafka.Acks.None" /> (no response/ack is sent to the client), <see cref="Confluent.Kafka.Acks.Leader" /> (the leader will write the record to
    ///     its local log but will respond without awaiting full acknowledgement from all followers, or <see cref="Confluent.Kafka.Acks.All" /> (the broker
    ///     will block until the message is committed by all in-sync replicas. If there are less than <c>min.insync.replicas</c> (broker configuration)
    ///     in the in-sync replicas set the produce request will fail.
    /// </summary>
    public Acks? Acks { get; init; }

    /// <summary>
    ///     Gets the client identifier.
    /// </summary>
    public string? ClientId { get; init; }

    /// <summary>
    ///     Gets the comma-separated list of brokers (host or host:port).
    /// </summary>
    public string? BootstrapServers { get; init; }

    /// <summary>
    ///     Gets the maximum message size.
    /// </summary>
    public int? MessageMaxBytes { get; init; }

    /// <summary>
    ///     Gets the maximum size for a message to be copied into the buffer. Messages larger than this will be passed by reference (zero-copy)
    ///     at the expense of larger iovecs.
    /// </summary>
    public int? MessageCopyMaxBytes { get; init; }

    /// <summary>
    ///     Gets the maximum response message size. This serves as a safety precaution to avoid memory exhaustion in case of protocol hickups.
    ///     This value must be at least <see cref="KafkaConsumerConfiguration.FetchMaxBytes" /> + 512 to allow for protocol overhead.
    ///     The value is adjusted automatically unless the configuration property is explicitly set.
    /// </summary>
    public int? ReceiveMessageMaxBytes { get; init; }

    /// <summary>
    ///     Gets the maximum number of in-flight requests per broker connection. This is a generic property applied to all broker communication,
    ///     however it is primarily relevant to produce requests. In particular, note that other mechanisms limit the number of outstanding consumer
    ///     fetch request per broker to one.
    /// </summary>
    public int? MaxInFlight { get; init; }

    /// <summary>
    ///     Gets the interval (in milliseconds) at which the topic and broker metadata is refreshed in order to proactively discover any new
    ///     brokers, topics, partitions or partition leader changes. Use -1 to disable the intervalled refresh (not recommended). If there are
    ///     no locally referenced topics (no topic objects created, no messages produced, no subscription or no assignment) then only the broker
    ///     list will be refreshed every interval but no more often than every 10s.
    /// </summary>
    public int? TopicMetadataRefreshIntervalMs { get; init; }

    /// <summary>
    ///     Gets the metadata cache max age (in milliseconds). Defaults to <see cref="TopicMetadataRefreshIntervalMs" />.
    /// </summary>
    public int? MetadataMaxAgeMs { get; init; }

    /// <summary>
    ///     Gets the refresh interval (in milliseconds) to be applied instead of the <see cref="TopicMetadataRefreshIntervalMs" />
    ///     when a topic loses its leader and a new metadata request will be enqueued. This initial interval will be exponentially increased
    ///     until the topic metadata has been refreshed. This is used to recover quickly from transitioning leader brokers.
    /// </summary>
    public int? TopicMetadataRefreshFastIntervalMs { get; init; }

    /// <summary>
    ///     Gets a value indicating whether less metadata requests must be performed (consuming less network bandwidth).
    /// </summary>
    public bool? TopicMetadataRefreshSparse { get; init; }

    /// <summary>
    ///     Gets the delay (in milliseconds) to be applied before marking a topic as non-existent. The maximum propagation time is calculated
    ///     from the time the topic is first referenced in the client.
    /// </summary>
    public int? TopicMetadataPropagationMaxMs { get; init; }

    /// <summary>
    ///     Gets a comma-separated list of regular expressions for matching topic names that should be ignored in broker metadata information
    ///     as if the topics did not exist.
    /// </summary>
    public string? TopicBlacklist { get; init; }

    /// <summary>
    ///     Gets a comma-separated list of debug contexts to enable.
    ///     Detailed producer debugging: <c>broker,topic,msg</c>.
    ///     Detailed consumer debugging: <c>consumer,cgrp,topic,fetch</c>.
    /// </summary>
    public string? Debug { get; init; }

    /// <summary>
    ///     Gets the default timeout (in milliseconds) for network requests.
    /// </summary>
    public int? SocketTimeoutMs { get; init; }

    /// <summary>
    ///     Gets the socket send buffer size. The system default is used if 0.
    /// </summary>
    public int? SocketSendBufferBytes { get; init; }

    /// <summary>
    ///     Gets the socket receive buffer size. The system default is used if 0.
    /// </summary>
    public int? SocketReceiveBufferBytes { get; init; }

    /// <summary>
    ///     Gets a value indicating whether TCP keep-alive (SO_KEEPALIVE) must be enabled on the broker sockets.
    /// </summary>
    public bool? SocketKeepaliveEnable { get; init; }

    /// <summary>
    ///     Gets a value indicating whether the Nagle's algorithm (TCP_NODELAY) must be disabled on broker sockets.
    /// </summary>
    public bool? SocketNagleDisable { get; init; }

    /// <summary>
    ///     Gets the maximum number of send failures (e.g. timed out requests) before disconnecting. Disable with 0.<br />
    ///     Warning: It is highly recommended to leave this setting at its default value of 1 to avoid the client and broker to
    ///     become desynchronized in case of request timeouts.<br />
    ///     Note: The connection is automatically re-established.
    /// </summary>
    public int? SocketMaxFails { get; init; }

    /// <summary>
    ///     Gets the duration in milliseconds of the cache of the broker address resolving results.
    /// </summary>
    public int? BrokerAddressTtl { get; init; }

    /// <summary>
    ///     Gets the allowed broker IP address families.
    /// </summary>
    public BrokerAddressFamily? BrokerAddressFamily { get; init; }

    /// <summary>
    ///     Gets the maximum time (in milliseconds) allowed for the setup of the broker connection (TCP connection setup and SSL/SASL handshake).
    ///     The connection to the broker will be closed and retried, if the timeout elapses before it is fully functional.
    /// </summary>
    public int? SocketConnectionSetupTimeoutMs { get; init; }

    /// <summary>
    ///     Gets the maximum time of inactivity (in milliseconds) before closing the broker connections. Disable with 0.
    ///     If this property is left at its default value some heuristics are performed to determine a suitable default value.
    /// </summary>
    public int? ConnectionsMaxIdleMs { get; init; }

    /// <summary>
    ///     Gets the initial time (in milliseconds) to wait before reconnecting to a broker after the connection has been closed. The time is increased
    ///     exponentially until <see cref="ReconnectBackoffMaxMs" /> is reached. -25% to +50% jitter is applied to each reconnect backoff.
    ///     A value of 0 disables the backoff and reconnects immediately.
    /// </summary>
    public int? ReconnectBackoffMs { get; init; }

    /// <summary>
    ///     Gets the maximum time (in milliseconds) to wait before reconnecting to a broker after the connection has been closed.
    /// </summary>
    public int? ReconnectBackoffMaxMs { get; init; }

    /// <summary>
    ///     Gets the statistics emit interval (in milliseconds). The granularity is 1000ms. A value of 0 disables statistics.
    /// </summary>
    public int? StatisticsIntervalMs { get; init; }

    /// <summary>
    ///     Gets a value indicating whether the broker's supported API versions must be requested to adjust the functionality to the available protocol features.
    ///     If set to <c>false</c>, or the API version request fails, the fallback version <see cref="BrokerVersionFallback" /> will be used.
    /// </summary>
    public bool? ApiVersionRequest { get; init; }

    /// <summary>
    ///     Gets the timeout (in milliseconds) for the broker API version requests.
    /// </summary>
    public int? ApiVersionRequestTimeoutMs { get; init; }

    /// <summary>
    ///     Gets how long the <see cref="BrokerVersionFallback" /> is used in the case the API version request fails.
    /// </summary>
    public int? ApiVersionFallbackMs { get; init; }

    /// <summary>
    ///     Gets the broker API version to be used when the API version request fails or it's disabled. Older broker versions (before 0.10.0) don't support
    ///     the API version request. Valid values are: 0.9.0, 0.8.2, 0.8.1, 0.8.0. Any other value &gt;= 0.10, such as 0.10.2.1, enables the <see cref="ApiVersionRequest" />.
    /// </summary>
    public string? BrokerVersionFallback { get; init; }

    /// <summary>
    ///     Gets a value indicating whether topics can be automatically created on the broker when subscribing to or assigning a non-existent
    ///     topic. The broker must also be configured with <c>auto.create.topics.enable=true</c> for this configuration to take effect.
    ///     Requires broker version &gt;= 0.11.0.0, for older broker versions only the broker configuration applies.
    /// </summary>
    public bool? AllowAutoCreateTopics { get; init; }

    /// <summary>
    ///     Gets the protocol to be used to communicate with the brokers.
    /// </summary>
    public SecurityProtocol? SecurityProtocol { get; init; }

    /// <summary>
    ///     Gets the SSL cipher suites.
    /// </summary>
    public string? SslCipherSuites { get; init; }

    /// <summary>
    ///     Gets the supported SSL curves.
    /// </summary>
    public string? SslCurvesList { get; init; }

    /// <summary>
    ///     Gets the supported SSL signature algorithms.
    /// </summary>
    public string? SslSigalgsList { get; init; }

    /// <summary>
    ///     Gets the path to the client's private key (PEM) used for the authentication.
    /// </summary>
    public string? SslKeyLocation { get; init; }

    /// <summary>
    ///     Gets the private key passphrase.
    /// </summary>
    public string? SslKeyPassword { get; init; }

    /// <summary>
    ///     Gets the client's private key string (in PEM format) used for the authentication.
    /// </summary>
    public string? SslKeyPem { get; init; }

    /// <summary>
    ///     Gets the path to the client's public key (PEM) used for the authentication.
    /// </summary>
    public string? SslCertificateLocation { get; init; }

    /// <summary>
    ///     Gets the client's public key string (in PEM format) used for the authentication.
    /// </summary>
    public string? SslCertificatePem { get; init; }

    /// <summary>
    ///     Gets the file or directory path to the CA certificate(s) for verifying the broker's key. Defaults: On Windows the system's CA certificates are automatically looked up in the Windows Root certificate store.
    ///     On Mac OSX this configuration defaults to <c>probe</c>. It is recommended to install openssl using Homebrew, to provide CA certificates. On Linux install the distribution's ca-certificates package.
    ///     If OpenSSL is statically linked or <see cref="SslCaLocation" /> is set to <c>probe</c> a list of standard paths will be probed and the first one found will be used as the default CA certificate location path.
    ///     If OpenSSL is dynamically linked the OpenSSL library's default path will be used (see <c>OPENSSLDIR</c> in <c>openssl version -a</c>).
    /// </summary>
    public string? SslCaLocation { get; init; }

    /// <summary>
    ///     Gets the CA certificate string (in PEM format) for verifying the broker's key.
    /// </summary>
    public string? SslCaPem { get; init; }

    /// <summary>
    ///     Gets a comma-separated list of Windows certificate stores to load CA certificates from. The certificates will be loaded in the same order
    ///     as stores are specified. If no certificates can be loaded from any of the specified stores an error is logged and the OpenSSL library's default
    ///     CA location is used instead. Store names are typically one or more of: MY, Root, Trust, CA.
    /// </summary>
    public string? SslCaCertificateStores { get; init; }

    /// <summary>
    ///     Gets the path to the certificate revocation list (CRL) for verifying broker's certificate validity.
    /// </summary>
    public string? SslCrlLocation { get; init; }

    /// <summary>
    ///     Gets the path to the client's keystore (PKCS#12) used for the authentication.
    /// </summary>
    public string? SslKeystoreLocation { get; init; }

    /// <summary>
    ///     Gets the client's keystore (PKCS#12) password.
    /// </summary>
    public string? SslKeystorePassword { get; init; }

    /// <summary>
    ///     Gets the comma-separated list of OpenSSL 3.0.x implementation providers.
    /// </summary>
    public string? SslProviders { get; init; }

    /// <summary>
    ///     Gets the path to the OpenSSL engine library. OpenSSL &gt;= 1.1.0 required.
    /// </summary>
    public string? SslEngineLocation { get; init; }

    /// <summary>
    ///     Gets the OpenSSL engine id (the name used for loading engine).
    /// </summary>
    public string? SslEngineId { get; init; }

    /// <summary>
    ///     Gets a value indicating whether the broker (server) certificate must be verified.
    /// </summary>
    public bool? EnableSslCertificateVerification { get; init; }

    /// <summary>
    ///     Gets the endpoint identification algorithm to be used to validate the broker hostname using the certificate. OpenSSL &gt;= 1.0.2 required.
    /// </summary>
    public SslEndpointIdentificationAlgorithm? SslEndpointIdentificationAlgorithm { get; init; }

    /// <summary>
    ///     Gets the Kerberos principal name that Kafka runs as, not including /hostname@REALM.
    /// </summary>
    public string? SaslKerberosServiceName { get; init; }

    /// <summary>
    ///     Gets the client's Kerberos principal name. (Not supported on Windows, will use the logon user's principal).
    /// </summary>
    public string? SaslKerberosPrincipal { get; init; }

    /// <summary>
    ///     Gets the shell command to be used to refresh or acquire the client's Kerberos ticket. This command is executed on client creation and every <see cref="SaslKerberosMinTimeBeforeRelogin" /> (0=disable).
    /// </summary>
    public string? SaslKerberosKinitCmd { get; init; }

    /// <summary>
    ///     Gets the path to the Kerberos keytab file. This configuration property is only used as a variable in <see cref="SaslKerberosKinitCmd" /> as <c>... -t "%{sasl.kerberos.keytab}"</c>.
    /// </summary>
    public string? SaslKerberosKeytab { get; init; }

    /// <summary>
    ///     Gets the minimum time in milliseconds between each key refresh attempts. Disable automatic key refresh by setting this property to 0.
    /// </summary>
    public int? SaslKerberosMinTimeBeforeRelogin { get; init; }

    /// <summary>
    ///     Gets the SASL username to use with the PLAIN and SASL-SCRAM-.. mechanisms.
    /// </summary>
    public string? SaslUsername { get; init; }

    /// <summary>
    ///     Gets the SASL password to use with the PLAIN and SASL-SCRAM-.. mechanisms.
    /// </summary>
    public string? SaslPassword { get; init; }

    /// <summary>
    ///     Gets the SASL/OAUTHBEARER configuration. The format is implementation-dependent and must be parsed accordingly. The default unsecured token implementation
    ///     (see https://tools.ietf.org/html/rfc7515#appendix-A.5) recognizes space-separated <c>name=value</c> pairs with valid names including <c>principalClaimName</c>,
    ///     <c>principal</c>, <c>scopeClaimName</c>, <c>scope</c>, and <c>lifeSeconds</c>. The default value for <c>principalClaimName</c> is <c>"sub"</c>, the default value
    ///     for <c>scopeClaimName</c> is <c>"scope"</c>, and the default value for <c>lifeSeconds</c> is 3600. The <c>scope</c> value is CSV format with the default value being
    ///     no/empty scope. For example: <c>principalClaimName=azp principal=admin scopeClaimName=roles scope=role1,role2 lifeSeconds=600</c>. In addition, SASL extensions can be
    ///     communicated to the broker via <c>extension_NAME=value</c>. For example: <c>principal=admin extension_traceId=123</c>.
    /// </summary>
    public string? SaslOauthbearerConfig { get; init; }

    /// <summary>
    ///     Gets a value indicating whether the builtin unsecure JWT OAUTHBEARER token handler must be enabled. This builtin handler should only be used for development or testing, and not in production.
    /// </summary>
    public bool? EnableSaslOauthbearerUnsecureJwt { get; init; }

    /// <summary>
    ///     Gets the login method to be used. If set to <see cref="Confluent.Kafka.SaslOauthbearerMethod.Oidc" />, the following properties must also be be specified: <see cref="SaslOauthbearerClientId" />,
    ///     <see cref="SaslOauthbearerClientSecret" />, and <see cref="SaslOauthbearerTokenEndpointUrl" />.
    /// </summary>
    public SaslOauthbearerMethod? SaslOauthbearerMethod { get; init; }

    /// <summary>
    ///     Gets the public identifier for the application. Must be unique across all clients that the authorization server handles. Only used when <see cref="SaslOauthbearerMethod" /> is set to <see cref="Confluent.Kafka.SaslOauthbearerMethod.Oidc" />.
    /// </summary>
    public string? SaslOauthbearerClientId { get; init; }

    /// <summary>
    ///     Gets the client secret only known to the application and the authorization server. This should be a sufficiently random string that is not guessable. Only used when <see cref="SaslOauthbearerMethod" /> is set to <see cref="Confluent.Kafka.SaslOauthbearerMethod.Oidc" />.
    /// </summary>
    public string? SaslOauthbearerClientSecret { get; init; }

    /// <summary>
    ///     Gets the scope of the access request to the broker. Only used when <see cref="SaslOauthbearerMethod" /> is set to <see cref="Confluent.Kafka.SaslOauthbearerMethod.Oidc" />.
    /// </summary>
    public string? SaslOauthbearerScope { get; init; }

    /// <summary>
    ///     Gets the additional information to be provided to the broker as a comma-separated list of <c>key=value</c> pairs (e.g. <c>supportFeatureX=true,organizationId=sales-emea</c>). Only used when <see cref="SaslOauthbearerMethod" /> is set to <see cref="Confluent.Kafka.SaslOauthbearerMethod.Oidc" />.
    /// </summary>
    public string? SaslOauthbearerExtensions { get; init; }

    /// <summary>
    ///     Gets the OAuth/OIDC issuer token endpoint HTTP(S) URI used to retrieve the token. Only used when <see cref="SaslOauthbearerMethod" /> is set to <see cref="Confluent.Kafka.SaslOauthbearerMethod.Oidc" />.
    /// </summary>
    [SuppressMessage("Design", "CA1056:URI-like properties should not be strings", Justification = "Generated according to wrapped class.")]
    public string? SaslOauthbearerTokenEndpointUrl { get; init; }

    /// <summary>
    ///     Gets the list of plugin libraries to load (<c>;</c> separated). The library search path is platform dependent. If no filename extension is specified the platform-specific extension (such as .dll or .so) will be appended automatically.
    /// </summary>
    public string? PluginLibraryPaths { get; init; }

    /// <summary>
    ///     Gets the rack identifier for this client. This can be any string value which indicates where this client is physically located.
    /// </summary>
    public string? ClientRack { get; init; }

    /// <summary>
    ///     Gets the backoff time in milliseconds before retrying a protocol request, this is the first backoff time, and will be backed off exponentially until number of retries is exhausted,
    ///     and it's capped by <see cref="RetryBackoffMaxMs" />.
    /// </summary>
    public int? RetryBackoffMs { get; init; }

    /// <summary>
    ///     Gets the maximum backoff time in milliseconds before retrying a protocol request, this is the maximum backoff allowed for exponentially backed off requests.
    /// </summary>
    public int? RetryBackoffMaxMs { get; init; }

    /// <summary>
    ///     Gets a value indicating how the client uses DNS lookups. By default, when the lookup returns multiple IP addresses for a hostname, they will all be attempted for connection before the
    ///     connection is considered failed. This applies to both bootstrap and advertised servers. If the value is set to <see cref="ClientDnsLookup.ResolveCanonicalBootstrapServersOnly" />, each
    ///     entry will be resolved and expanded into a list of canonical names. Warning: <see cref="ClientDnsLookup.ResolveCanonicalBootstrapServersOnly" /> must only be used with <see cref="SaslMechanism.Gssapi" />
    ///     (Kerberos) as <see cref="SaslMechanism" />, as it's the only purpose of this configuration value. Note: Default here is different from the Java client's default behavior, which connects
    ///     only to the first IP address returned for a hostname.
    /// </summary>
    public ClientDnsLookup? ClientDnsLookup { get; init; }

    /// <summary>
    ///     Gets a value indicating whether to enable pushing of client metrics to the cluster, if the cluster has a client metrics subscription which matches this client.
    /// </summary>
    public bool? EnableMetricsPush { get; init; }

    /// <summary>
    ///     Gets the maximum time (in milliseconds) before a cancellation request is acted on. Low values may result in measurably higher CPU usage.
    /// </summary>
    public int? CancellationDelayMaxMs { get; init; }

    /// <summary>
    ///     Maps to the Confluent client configuration.
    /// </summary>
    /// <returns>
    ///     The Confluent client configuration.
    /// </returns>
    protected virtual TConfluentConfig MapCore()
    {
        TConfluentConfig confluentConfig = new()
        {
            SaslMechanism = SaslMechanism,
            Acks = Acks,
            ClientId = ClientId,
            BootstrapServers = BootstrapServers,
            MessageMaxBytes = MessageMaxBytes,
            MessageCopyMaxBytes = MessageCopyMaxBytes,
            ReceiveMessageMaxBytes = ReceiveMessageMaxBytes,
            MaxInFlight = MaxInFlight,
            TopicMetadataRefreshIntervalMs = TopicMetadataRefreshIntervalMs,
            MetadataMaxAgeMs = MetadataMaxAgeMs,
            TopicMetadataRefreshFastIntervalMs = TopicMetadataRefreshFastIntervalMs,
            TopicMetadataRefreshSparse = TopicMetadataRefreshSparse,
            TopicMetadataPropagationMaxMs = TopicMetadataPropagationMaxMs,
            TopicBlacklist = TopicBlacklist,
            Debug = Debug,
            SocketTimeoutMs = SocketTimeoutMs,
            SocketSendBufferBytes = SocketSendBufferBytes,
            SocketReceiveBufferBytes = SocketReceiveBufferBytes,
            SocketKeepaliveEnable = SocketKeepaliveEnable,
            SocketNagleDisable = SocketNagleDisable,
            SocketMaxFails = SocketMaxFails,
            BrokerAddressTtl = BrokerAddressTtl,
            BrokerAddressFamily = BrokerAddressFamily,
            SocketConnectionSetupTimeoutMs = SocketConnectionSetupTimeoutMs,
            ConnectionsMaxIdleMs = ConnectionsMaxIdleMs,
            ReconnectBackoffMs = ReconnectBackoffMs,
            ReconnectBackoffMaxMs = ReconnectBackoffMaxMs,
            StatisticsIntervalMs = StatisticsIntervalMs,
            ApiVersionRequest = ApiVersionRequest,
            ApiVersionRequestTimeoutMs = ApiVersionRequestTimeoutMs,
            ApiVersionFallbackMs = ApiVersionFallbackMs,
            BrokerVersionFallback = BrokerVersionFallback,
            AllowAutoCreateTopics = AllowAutoCreateTopics,
            SecurityProtocol = SecurityProtocol,
            SslCipherSuites = SslCipherSuites,
            SslCurvesList = SslCurvesList,
            SslSigalgsList = SslSigalgsList,
            SslKeyLocation = SslKeyLocation,
            SslKeyPassword = SslKeyPassword,
            SslKeyPem = SslKeyPem,
            SslCertificateLocation = SslCertificateLocation,
            SslCertificatePem = SslCertificatePem,
            SslCaLocation = SslCaLocation,
            SslCaPem = SslCaPem,
            SslCaCertificateStores = SslCaCertificateStores,
            SslCrlLocation = SslCrlLocation,
            SslKeystoreLocation = SslKeystoreLocation,
            SslKeystorePassword = SslKeystorePassword,
            SslProviders = SslProviders,
            SslEngineLocation = SslEngineLocation,
            SslEngineId = SslEngineId,
            EnableSslCertificateVerification = EnableSslCertificateVerification,
            SslEndpointIdentificationAlgorithm = SslEndpointIdentificationAlgorithm,
            SaslKerberosServiceName = SaslKerberosServiceName,
            SaslKerberosPrincipal = SaslKerberosPrincipal,
            SaslKerberosKinitCmd = SaslKerberosKinitCmd,
            SaslKerberosKeytab = SaslKerberosKeytab,
            SaslKerberosMinTimeBeforeRelogin = SaslKerberosMinTimeBeforeRelogin,
            SaslUsername = SaslUsername,
            SaslPassword = SaslPassword,
            SaslOauthbearerConfig = SaslOauthbearerConfig,
            EnableSaslOauthbearerUnsecureJwt = EnableSaslOauthbearerUnsecureJwt,
            SaslOauthbearerMethod = SaslOauthbearerMethod,
            SaslOauthbearerClientId = SaslOauthbearerClientId,
            SaslOauthbearerClientSecret = SaslOauthbearerClientSecret,
            SaslOauthbearerScope = SaslOauthbearerScope,
            SaslOauthbearerExtensions = SaslOauthbearerExtensions,
            SaslOauthbearerTokenEndpointUrl = SaslOauthbearerTokenEndpointUrl,
            PluginLibraryPaths = PluginLibraryPaths,
            ClientRack = ClientRack,
            RetryBackoffMs = RetryBackoffMs,
            RetryBackoffMaxMs = RetryBackoffMaxMs,
            ClientDnsLookup = ClientDnsLookup,
            EnableMetricsPush = EnableMetricsPush
        };

        if (CancellationDelayMaxMs.HasValue)
            confluentConfig.CancellationDelayMaxMs = CancellationDelayMaxMs.Value;

        return confluentConfig;
    }
}

/// <content>
///     The autogenerated part of the <see cref="KafkaConsumerConfiguration" /> class.
/// </content>
[SuppressMessage("StyleCop.CSharp.MaintainabilityRules", "SA1402:File may only contain a single type", Justification = "Autogenerated all at once")]
[SuppressMessage("Design", "CA1044:Properties should not be write only", Justification = "Accessors generated according to wrapped class")]
public partial record KafkaConsumerConfiguration
{
    /// <summary>
    ///     Gets a comma-separated list of fields that may be optionally set in <see cref="ConsumeResult{TKey,TValue}" /> objects returned by
    ///     the <see cref="Consumer{TKey,TValue}.Consume(System.TimeSpan)" /> method. Disabling fields that you do not require will improve
    ///     throughput and reduce memory consumption. Allowed values: <c>headers</c>, <c>timestamp</c>, <c>topic</c>, <c>all</c>, <c>none</c>.
    /// </summary>
    public string? ConsumeResultFields { get; init; }

    /// <summary>
    ///     Gets the action to take when there is no initial offset in the offset store or the desired offset is out of range:
    ///     <see cref="Confluent.Kafka.AutoOffsetReset.Earliest" /> to automatically reset to the smallest offset,
    ///     <see cref="Confluent.Kafka.AutoOffsetReset.Latest" /> to automatically reset to the largest offset, and
    ///     <see cref="Confluent.Kafka.AutoOffsetReset.Error" /> to trigger an error (ERR__AUTO_OFFSET_RESET).
    /// </summary>
    public AutoOffsetReset? AutoOffsetReset { get; init; }

    /// <summary>
    ///     Gets the static instance id used to enable static group membership. Static group members are able to leave and rejoin a group within
    ///     the configured <see cref="SessionTimeoutMs" /> without prompting a group rebalance. This should be used in combination with a larger
    ///     <see cref="SessionTimeoutMs" /> to avoid group rebalances caused by transient unavailability (e.g. process restarts).
    ///     Requires broker version &gt;= 2.3.0.
    /// </summary>
    public string? GroupInstanceId { get; init; }

    /// <summary>
    ///     Gets the partition assignment strategy: <see cref="Confluent.Kafka.PartitionAssignmentStrategy.Range" /> to co-localize the partitions
    ///     of several topics, <see cref="Confluent.Kafka.PartitionAssignmentStrategy.RoundRobin" /> to evenly distribute the partitions among
    ///     the consumer group members, <see cref="Confluent.Kafka.PartitionAssignmentStrategy.CooperativeSticky" /> to evenly distribute the
    ///     partitions and limit minimize the partitions movements. The default is <see cref="Confluent.Kafka.PartitionAssignmentStrategy.Range" />.
    /// </summary>
    public PartitionAssignmentStrategy? PartitionAssignmentStrategy { get; init; }

    /// <summary>
    ///     Gets the client group session and failure detection timeout (in milliseconds). The consumer sends periodic heartbeats
    ///     <see cref="HeartbeatIntervalMs" /> to indicate its liveness to the broker. If no heartbeat is received by the broker for a group
    ///     member within the session timeout, the broker will remove the consumer from the group and trigger a rebalance. Also see
    ///     <see cref="MaxPollIntervalMs" />.
    /// </summary>
    public int? SessionTimeoutMs { get; init; }

    /// <summary>
    ///     Gets the interval (in milliseconds) at which the heartbeats have to be sent to the broker.
    /// </summary>
    public int? HeartbeatIntervalMs { get; init; }

    /// <summary>
    ///     Gets the group protocol type.
    /// </summary>
    public string? GroupProtocolType { get; init; }

    /// <summary>
    ///     Gets the group protocol to use. Use <see cref="GroupProtocol.Classic" /> for the original protocol and <see cref="GroupProtocol.Consumer" /> for the new protocol introduced in KIP-848.
    ///     Default is <see cref="GroupProtocol.Classic" />, but will change to <see cref="GroupProtocol.Consumer" /> in next releases.
    /// </summary>
    public GroupProtocol? GroupProtocol { get; init; }

    /// <summary>
    ///     Gets the server-side assignor to use. Keep it <c>null</c> to make the server select a suitable assignor for the group. Available assignors: uniform or range.
    /// </summary>
    public string? GroupRemoteAssignor { get; init; }

    /// <summary>
    ///     Gets the interval (in milliseconds) at which the current group coordinator must be queried. If the currently assigned coordinator
    ///     is down the configured query interval will be divided by ten to more quickly recover in case of coordinator reassignment.
    /// </summary>
    public int? CoordinatorQueryIntervalMs { get; init; }

    /// <summary>
    ///     Gets the maximum allowed time (in milliseconds) between calls to consume messages. If this interval is exceeded the consumer is
    ///     considered failed and the group will rebalance in order to reassign the partitions to another consumer group member.<br />
    ///     Warning: Offset commits may be not possible at this point.
    /// </summary>
    public int? MaxPollIntervalMs { get; init; }

    /// <summary>
    ///     Gets the frequency in milliseconds at which the consumer offsets are committed.
    /// </summary>
    public int? AutoCommitIntervalMs { get; init; }

    /// <summary>
    ///     Gets the minimum number of messages per topic and partition that the underlying library must try to maintain in the local consumer queue.
    /// </summary>
    public int? QueuedMinMessages { get; init; }

    /// <summary>
    ///     Gets the maximum number of kilobytes of queued pre-fetched messages to store in the local consumer queue. This setting applies to
    ///     the single consumer queue, regardless of the number of partitions. This value may be overshot by <see cref="FetchMaxBytes" />. This
    ///     property has higher priority than <see cref="QueuedMinMessages" />.
    /// </summary>
    public int? QueuedMaxMessagesKbytes { get; init; }

    /// <summary>
    ///     Gets the maximum time (in milliseconds) that the broker may wait to fill the fetch response with enough messages to match the
    ///     size specified by <see cref="FetchMinBytes" />.
    /// </summary>
    public int? FetchWaitMaxMs { get; init; }

    /// <summary>
    ///     Gets the maximum time in milliseconds to postpone the next fetch request for a topic+partition in case the current fetch queue thresholds (<see cref="QueuedMinMessages" />
    ///     or <see cref="QueuedMaxMessagesKbytes" />) have been exceeded. This property may need to be decreased if the queue thresholds are set low and the application is experiencing long (~1s)
    ///     delays between messages. Low values may increase CPU utilization.
    /// </summary>
    public int? FetchQueueBackoffMs { get; init; }

    /// <summary>
    ///     Gets the initial maximum number of bytes per topic and partition to request when fetching messages from the broker. If the client
    ///     encounters a message larger than this value it will gradually try to increase it until the entire message can be fetched.
    /// </summary>
    public int? MaxPartitionFetchBytes { get; init; }

    /// <summary>
    ///     Gets the maximum amount of data the broker shall return for a fetch request. The messages are fetched in batches by the consumer
    ///     and if the first message batch in the first non-empty partition of the fetch request is larger than this value, then the message
    ///     batch will still be returned to ensure that the consumer can make progress. The maximum message batch size accepted by the broker
    ///     is defined via <c>message.max.bytes</c> (broker config) or <c>max.message.bytes</c> (broker topic config). This value is automatically
    ///     adjusted upwards to be at least <c>message.max.bytes</c> (consumer config).
    /// </summary>
    public int? FetchMaxBytes { get; init; }

    /// <summary>
    ///     Gets the minimum number of bytes that the broker must respond with. If <see cref="FetchWaitMaxMs" /> expires the accumulated data
    ///     will be sent to the client regardless of this setting.
    /// </summary>
    public int? FetchMinBytes { get; init; }

    /// <summary>
    ///     Gets how long to postpone the next fetch request for a topic and partition in case of a fetch error.
    /// </summary>
    public int? FetchErrorBackoffMs { get; init; }

    /// <summary>
    ///     Gets a value indicating how to read the messages written inside a transaction: <see cref="Confluent.Kafka.IsolationLevel.ReadCommitted" />
    ///     to only return transactional messages which have been committed, or <see cref="Confluent.Kafka.IsolationLevel.ReadUncommitted" /> to
    ///     return all messages, even transactional messages which have been aborted.
    /// </summary>
    public IsolationLevel? IsolationLevel { get; init; }

    /// <summary>
    ///     Gets a value indicating whether the partition EOF event must be emitted whenever the consumer reaches the end of a partition.
    /// </summary>
    public bool? EnablePartitionEof { get; init; }

    /// <summary>
    ///     Gets a value indicating whether the CRC32 of the consumed messages must be verified, ensuring no on-the-wire or on-disk corruption
    ///     to the messages occurred. This check comes at slightly increased CPU usage.
    /// </summary>
    public bool? CheckCrcs { get; init; }

    /// <summary>
    ///     Maps to the Confluent client configuration.
    /// </summary>
    /// <returns>
    ///     The Confluent client configuration.
    /// </returns>
    protected override ConsumerConfig MapCore()
    {
        ConsumerConfig confluentConfig = base.MapCore();

        confluentConfig.ConsumeResultFields = ConsumeResultFields;
        confluentConfig.AutoOffsetReset = AutoOffsetReset;
        confluentConfig.GroupInstanceId = GroupInstanceId;
        confluentConfig.PartitionAssignmentStrategy = PartitionAssignmentStrategy;
        confluentConfig.SessionTimeoutMs = SessionTimeoutMs;
        confluentConfig.HeartbeatIntervalMs = HeartbeatIntervalMs;
        confluentConfig.GroupProtocolType = GroupProtocolType;
        confluentConfig.GroupProtocol = GroupProtocol;
        confluentConfig.GroupRemoteAssignor = GroupRemoteAssignor;
        confluentConfig.CoordinatorQueryIntervalMs = CoordinatorQueryIntervalMs;
        confluentConfig.MaxPollIntervalMs = MaxPollIntervalMs;
        confluentConfig.AutoCommitIntervalMs = AutoCommitIntervalMs;
        confluentConfig.QueuedMinMessages = QueuedMinMessages;
        confluentConfig.QueuedMaxMessagesKbytes = QueuedMaxMessagesKbytes;
        confluentConfig.FetchWaitMaxMs = FetchWaitMaxMs;
        confluentConfig.FetchQueueBackoffMs = FetchQueueBackoffMs;
        confluentConfig.MaxPartitionFetchBytes = MaxPartitionFetchBytes;
        confluentConfig.FetchMaxBytes = FetchMaxBytes;
        confluentConfig.FetchMinBytes = FetchMinBytes;
        confluentConfig.FetchErrorBackoffMs = FetchErrorBackoffMs;
        confluentConfig.IsolationLevel = IsolationLevel;
        confluentConfig.EnablePartitionEof = EnablePartitionEof;
        confluentConfig.CheckCrcs = CheckCrcs;

        return confluentConfig;
    }
}

/// <content>
///     The autogenerated part of the <see cref="KafkaProducerConfiguration" /> class.
/// </content>
[SuppressMessage("StyleCop.CSharp.MaintainabilityRules", "SA1402:File may only contain a single type", Justification = "Autogenerated all at once")]
[SuppressMessage("Design", "CA1044:Properties should not be write only", Justification = "Accessors generated according to wrapped class")]
public partial record KafkaProducerConfiguration
{
    /// <summary>
    ///     Gets a value indicating whether delivery reports must be sent. Typically you should set this parameter to <c>true</c>. Set it to
    ///     <c>false</c> for "fire and forget" semantics and a small boost in performance.
    /// </summary>
    public bool? EnableDeliveryReports { get; init; }

    /// <summary>
    ///     Gets the ack timeout of the producer request in milliseconds. This value is only enforced by the broker and relies on
    ///     <c>request.required.acks</c> being != 0.
    /// </summary>
    public int? RequestTimeoutMs { get; init; }

    /// <summary>
    ///     Gets the local message timeout (in milliseconds). This value is only enforced locally and limits the time a produced message waits
    ///     for successful delivery. A time of 0 is infinite. This is the maximum time to deliver a message (including retries) and a delivery
    ///     error will occur when either the retry count or the message timeout are exceeded. The message timeout is automatically adjusted to
    ///     <see cref="TransactionTimeoutMs" /> if  <see cref="TransactionalId" /> is set.
    /// </summary>
    public int? MessageTimeoutMs { get; init; }

    /// <summary>
    ///     Gets the partitioner to be used to decide the target partition for a message: <see cref="Confluent.Kafka.Partitioner.Random" />
    ///     to randomly distribute the messages, <see cref="Confluent.Kafka.Partitioner.Consistent" /> to use the CRC32 hash of the message key
    ///     (empty and null keys are mapped to a single partition), <see cref="Confluent.Kafka.Partitioner.ConsistentRandom" /> to use the CRC32
    ///     hash of the message key (but empty and null keys are randomly partitioned), <see cref="Confluent.Kafka.Partitioner.Murmur2" /> to use
    ///     a Java Producer compatible Murmur2 hash of the message key (null keys are mapped to a single partition), or
    ///     <see cref="Confluent.Kafka.Partitioner.Murmur2Random" /> to use a Java Producer compatible Murmur2 hash of the message key (but null
    ///     keys are randomly partitioned).<br />
    ///     The default is <see cref="Confluent.Kafka.Partitioner.ConsistentRandom" />, while <see cref="Confluent.Kafka.Partitioner.Murmur2Random" />
    ///     is functionally equivalent to the default partitioner in the Java Producer.
    /// </summary>
    public Partitioner? Partitioner { get; init; }

    /// <summary>
    ///     Gets the compression level parameter for the algorithm selected by configuration property <see cref="CompressionType" />. Higher
    ///     values will result in better compression at the cost of higher CPU usage. Usable range is algorithm-dependent: [0-9] for gzip,
    ///     [0-12] for lz4, only 0 for snappy. -1 = codec-dependent default compression level.
    /// </summary>
    public int? CompressionLevel { get; init; }

    /// <summary>
    ///     Gets the identifier to be used to identify the same transactional producer instance across process restarts. This is required to
    ///     enable the transactional producer and it allows the producer to guarantee that transactions corresponding to earlier instances of
    ///     the same producer have been finalized prior to starting any new transaction, and that any zombie instances are fenced off. If no
    ///     <see cref="TransactionalId" /> is provided, then the producer is limited to idempotent delivery (see <see cref="EnableIdempotence" />).
    ///     Requires broker version &gt;= 0.11.0.
    /// </summary>
    public string? TransactionalId { get; init; }

    /// <summary>
    ///     Gets the maximum amount of time in milliseconds that the transaction coordinator will wait for a transaction status update from
    ///     the producer before proactively aborting the ongoing transaction. If this value is larger than the <c>transaction.max.timeout.ms</c>
    ///     setting in the broker, the init transaction call will fail with ERR_INVALID_TRANSACTION_TIMEOUT. The transaction timeout automatically
    ///     adjusts <see cref="MessageTimeoutMs" /> and <see cref="KafkaClientConfiguration{TClientConfig}.SocketTimeoutMs" /> unless explicitly configured in which case
    ///     they must not exceed the transaction timeout (<see cref="KafkaClientConfiguration{TClientConfig}.SocketTimeoutMs" /> must be at least 100ms lower than
    ///     <see cref="TransactionTimeoutMs" />).
    /// </summary>
    public int? TransactionTimeoutMs { get; init; }

    /// <summary>
    ///     Gets a value indicating whether the producer must ensure that messages are successfully produced exactly once and in the original
    ///     produce order. The following configuration properties are adjusted automatically (if not modified by the user) when idempotence is
    ///     enabled: <see cref="KafkaClientConfiguration{TClientConfig}.MaxInFlight" /> to 5 (must be less than or equal to 5),
    ///     <see cref="MessageSendMaxRetries" /> to <c>Int32.MaxValue</c> (must be greater than 0),
    ///     <see cref="KafkaClientConfiguration{TClientConfig}.Acks" /> to <see cref="Acks.All" />. The producer instantiation will fail if user-supplied configuration
    ///     is incompatible.
    /// </summary>
    public bool? EnableIdempotence { get; init; }

    /// <summary>
    ///     Gets a value indicating whether an error that could result in a gap in the produced message series when a batch of messages fails,
    ///     must raise a fatal error (ERR_GAPLESS_GUARANTEE) and stop the producer. Messages failing due to <see cref="MessageTimeoutMs" /> are
    ///     not covered by this guarantee. Requires <see cref="EnableIdempotence" />=true.
    /// </summary>
    public bool? EnableGaplessGuarantee { get; init; }

    /// <summary>
    ///     Gets the maximum number of messages allowed on the producer queue. This queue is shared by all topics and partitions.
    /// </summary>
    public int? QueueBufferingMaxMessages { get; init; }

    /// <summary>
    ///     Gets the maximum total message size sum allowed on the producer queue. This queue is shared by all topics and partitions. This
    ///     property has higher priority than <see cref="QueueBufferingMaxMessages" />.
    /// </summary>
    public int? QueueBufferingMaxKbytes { get; init; }

    /// <summary>
    ///     Gets the delay in milliseconds to wait for messages in the producer queue to accumulate before constructing message batches to
    ///     transmit to brokers. A higher value allows larger and more effective (less overhead, improved compression) batches of messages to
    ///     accumulate at the expense of increased message delivery latency.
    /// </summary>
    public double? LingerMs { get; init; }

    /// <summary>
    ///     Gets how many times to retry sending a failing message.<br />
    ///     Note: retrying may cause reordering unless <see cref="EnableIdempotence" /> is set to <c>true</c>.
    /// </summary>
    public int? MessageSendMaxRetries { get; init; }

    /// <summary>
    ///     Gets the threshold of outstanding not yet transmitted broker requests needed to backpressure the producer's message accumulator.
    ///     If the number of not yet transmitted requests equals or exceeds this number, produce request creation that would have otherwise
    ///     been triggered (for example, in accordance with <see cref="LingerMs" />) will be delayed. A lower number yields larger and more
    ///     effective batches. A higher value can improve latency when using compression on slow machines.
    /// </summary>
    public int? QueueBufferingBackpressureThreshold { get; init; }

    /// <summary>
    ///     Gets the compression codec to be used to compress message sets. This is the default value for all topics, may be overridden by the
    ///     topic configuration property <c>compression.codec</c>.
    /// </summary>
    public CompressionType? CompressionType { get; init; }

    /// <summary>
    ///     Gets the maximum number of messages batched in one message set. The total message set size is also limited by <see cref="BatchSize" />
    ///     and <see cref="KafkaClientConfiguration{TClientConfig}.MessageMaxBytes" />.
    /// </summary>
    public int? BatchNumMessages { get; init; }

    /// <summary>
    ///     Gets the maximum size (in bytes) of all messages batched in one message set, including the protocol framing overhead. This limit
    ///     is applied after the first message has been added to the batch, regardless of the first message size, this is to ensure that messages
    ///     that exceed the <see cref="BatchSize" /> are still produced. The total message set size is also limited by <see cref="BatchNumMessages" />
    ///     and <see cref="KafkaClientConfiguration{TClientConfig}.MessageMaxBytes" />.
    /// </summary>
    public int? BatchSize { get; init; }

    /// <summary>
    ///     Gets the delay in milliseconds to wait to assign new sticky partitions for each topic. By default this is set to double the time
    ///     of <see cref="LingerMs" />. To disable sticky behavior, set it to 0. This behavior affects messages with the key <c>null</c> in all
    ///     cases, and messages with key lengths of zero when the <see cref="Confluent.Kafka.Partitioner.ConsistentRandom" /> partitioner is in
    ///     use. These messages would otherwise be assigned randomly. A higher value allows for more effective batching of these messages.
    /// </summary>
    public int? StickyPartitioningLingerMs { get; init; }

    /// <summary>
    ///     Maps to the Confluent client configuration.
    /// </summary>
    /// <returns>
    ///     The Confluent client configuration.
    /// </returns>
    protected override ProducerConfig MapCore()
    {
        ProducerConfig confluentConfig = base.MapCore();

        confluentConfig.EnableDeliveryReports = EnableDeliveryReports;
        confluentConfig.RequestTimeoutMs = RequestTimeoutMs;
        confluentConfig.MessageTimeoutMs = MessageTimeoutMs;
        confluentConfig.Partitioner = Partitioner;
        confluentConfig.CompressionLevel = CompressionLevel;
        confluentConfig.TransactionalId = TransactionalId;
        confluentConfig.TransactionTimeoutMs = TransactionTimeoutMs;
        confluentConfig.EnableIdempotence = EnableIdempotence;
        confluentConfig.EnableGaplessGuarantee = EnableGaplessGuarantee;
        confluentConfig.QueueBufferingMaxMessages = QueueBufferingMaxMessages;
        confluentConfig.QueueBufferingMaxKbytes = QueueBufferingMaxKbytes;
        confluentConfig.LingerMs = LingerMs;
        confluentConfig.MessageSendMaxRetries = MessageSendMaxRetries;
        confluentConfig.QueueBufferingBackpressureThreshold = QueueBufferingBackpressureThreshold;
        confluentConfig.CompressionType = CompressionType;
        confluentConfig.BatchNumMessages = BatchNumMessages;
        confluentConfig.BatchSize = BatchSize;
        confluentConfig.StickyPartitioningLingerMs = StickyPartitioningLingerMs;

        return confluentConfig;
    }
}

/// <summary>
///     Builds the <see cref="KafkaProducerConfiguration" /> or <see cref="KafkaConsumerConfiguration" />.
/// </summary>
[SuppressMessage("StyleCop.CSharp.MaintainabilityRules", "SA1402:File may only contain a single type", Justification = "Autogenerated all at once")]
[SuppressMessage("StyleCop.CSharp.DocumentationRules", "SA1600:Elements should be documented", Justification = "Internal interface")]
[SuppressMessage("StyleCop.CSharp.OrderingRules", "SA1201:Elements should appear in the correct order", Justification = "Autogenerated")]
internal interface IKafkaClientConfigurationBuilder
{
    void WithSaslMechanism(SaslMechanism? saslMechanism);

    void WithAcks(Acks? acks);

    void WithClientId(string? clientId);

    void WithBootstrapServers(string? bootstrapServers);

    void WithMessageMaxBytes(int? messageMaxBytes);

    void WithMessageCopyMaxBytes(int? messageCopyMaxBytes);

    void WithReceiveMessageMaxBytes(int? receiveMessageMaxBytes);

    void WithMaxInFlight(int? maxInFlight);

    void WithTopicMetadataRefreshIntervalMs(int? topicMetadataRefreshIntervalMs);

    void WithMetadataMaxAgeMs(int? metadataMaxAgeMs);

    void WithTopicMetadataRefreshFastIntervalMs(int? topicMetadataRefreshFastIntervalMs);

    void WithTopicMetadataRefreshSparse(bool? topicMetadataRefreshSparse);

    void WithTopicMetadataPropagationMaxMs(int? topicMetadataPropagationMaxMs);

    void WithTopicBlacklist(string? topicBlacklist);

    void WithDebug(string? debug);

    void WithSocketTimeoutMs(int? socketTimeoutMs);

    void WithSocketSendBufferBytes(int? socketSendBufferBytes);

    void WithSocketReceiveBufferBytes(int? socketReceiveBufferBytes);

    void WithSocketKeepaliveEnable(bool? socketKeepaliveEnable);

    void WithSocketNagleDisable(bool? socketNagleDisable);

    void WithSocketMaxFails(int? socketMaxFails);

    void WithBrokerAddressTtl(int? brokerAddressTtl);

    void WithBrokerAddressFamily(BrokerAddressFamily? brokerAddressFamily);

    void WithSocketConnectionSetupTimeoutMs(int? socketConnectionSetupTimeoutMs);

    void WithConnectionsMaxIdleMs(int? connectionsMaxIdleMs);

    void WithReconnectBackoffMs(int? reconnectBackoffMs);

    void WithReconnectBackoffMaxMs(int? reconnectBackoffMaxMs);

    void WithStatisticsIntervalMs(int? statisticsIntervalMs);

    void WithApiVersionRequest(bool? apiVersionRequest);

    void WithApiVersionRequestTimeoutMs(int? apiVersionRequestTimeoutMs);

    void WithApiVersionFallbackMs(int? apiVersionFallbackMs);

    void WithBrokerVersionFallback(string? brokerVersionFallback);

    void WithAllowAutoCreateTopics(bool? allowAutoCreateTopics);

    void WithSecurityProtocol(SecurityProtocol? securityProtocol);

    void WithSslCipherSuites(string? sslCipherSuites);

    void WithSslCurvesList(string? sslCurvesList);

    void WithSslSigalgsList(string? sslSigalgsList);

    void WithSslKeyLocation(string? sslKeyLocation);

    void WithSslKeyPassword(string? sslKeyPassword);

    void WithSslKeyPem(string? sslKeyPem);

    void WithSslCertificateLocation(string? sslCertificateLocation);

    void WithSslCertificatePem(string? sslCertificatePem);

    void WithSslCaLocation(string? sslCaLocation);

    void WithSslCaPem(string? sslCaPem);

    void WithSslCaCertificateStores(string? sslCaCertificateStores);

    void WithSslCrlLocation(string? sslCrlLocation);

    void WithSslKeystoreLocation(string? sslKeystoreLocation);

    void WithSslKeystorePassword(string? sslKeystorePassword);

    void WithSslProviders(string? sslProviders);

    void WithSslEngineLocation(string? sslEngineLocation);

    void WithSslEngineId(string? sslEngineId);

    void WithEnableSslCertificateVerification(bool? enableSslCertificateVerification);

    void WithSslEndpointIdentificationAlgorithm(SslEndpointIdentificationAlgorithm? sslEndpointIdentificationAlgorithm);

    void WithSaslKerberosServiceName(string? saslKerberosServiceName);

    void WithSaslKerberosPrincipal(string? saslKerberosPrincipal);

    void WithSaslKerberosKinitCmd(string? saslKerberosKinitCmd);

    void WithSaslKerberosKeytab(string? saslKerberosKeytab);

    void WithSaslKerberosMinTimeBeforeRelogin(int? saslKerberosMinTimeBeforeRelogin);

    void WithSaslUsername(string? saslUsername);

    void WithSaslPassword(string? saslPassword);

    void WithSaslOauthbearerConfig(string? saslOauthbearerConfig);

    void WithEnableSaslOauthbearerUnsecureJwt(bool? enableSaslOauthbearerUnsecureJwt);

    void WithSaslOauthbearerMethod(SaslOauthbearerMethod? saslOauthbearerMethod);

    void WithSaslOauthbearerClientId(string? saslOauthbearerClientId);

    void WithSaslOauthbearerClientSecret(string? saslOauthbearerClientSecret);

    void WithSaslOauthbearerScope(string? saslOauthbearerScope);

    void WithSaslOauthbearerExtensions(string? saslOauthbearerExtensions);

    void WithSaslOauthbearerTokenEndpointUrl(string? saslOauthbearerTokenEndpointUrl);

    void WithPluginLibraryPaths(string? pluginLibraryPaths);

    void WithClientRack(string? clientRack);

    void WithRetryBackoffMs(int? retryBackoffMs);

    void WithRetryBackoffMaxMs(int? retryBackoffMaxMs);

    void WithClientDnsLookup(ClientDnsLookup? clientDnsLookup);

    void WithEnableMetricsPush(bool? enableMetricsPush);

    void WithCancellationDelayMaxMs(int cancellationDelayMaxMs);
}

/// <content>
///     The autogenerated part of the <see cref="KafkaClientsConfigurationBuilder" /> class.
/// </content>
[SuppressMessage("StyleCop.CSharp.MaintainabilityRules", "SA1402:File may only contain a single type", Justification = "Autogenerated all at once")]
[SuppressMessage("StyleCop.CSharp.DocumentationRules", "SA1600:Elements should be documented", Justification = "Documented in other partial")]
[SuppressMessage("StyleCop.CSharp.DocumentationRules", "SA1601:Partial elements should be documented", Justification = "Autogenerated")]
public partial class KafkaClientsConfigurationBuilder
{
    public partial KafkaClientsConfigurationBuilder WithSaslMechanism(SaslMechanism? saslMechanism)
    {
        _sharedConfigurationActions.Add(builder => builder.WithSaslMechanism(saslMechanism));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithAcks(Acks? acks)
    {
        _sharedConfigurationActions.Add(builder => builder.WithAcks(acks));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithBootstrapServers(string? bootstrapServers)
    {
        _sharedConfigurationActions.Add(builder => builder.WithBootstrapServers(bootstrapServers));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithMessageMaxBytes(int? messageMaxBytes)
    {
        _sharedConfigurationActions.Add(builder => builder.WithMessageMaxBytes(messageMaxBytes));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithMessageCopyMaxBytes(int? messageCopyMaxBytes)
    {
        _sharedConfigurationActions.Add(builder => builder.WithMessageCopyMaxBytes(messageCopyMaxBytes));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithReceiveMessageMaxBytes(int? receiveMessageMaxBytes)
    {
        _sharedConfigurationActions.Add(builder => builder.WithReceiveMessageMaxBytes(receiveMessageMaxBytes));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithMaxInFlight(int? maxInFlight)
    {
        _sharedConfigurationActions.Add(builder => builder.WithMaxInFlight(maxInFlight));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithTopicMetadataRefreshIntervalMs(int? topicMetadataRefreshIntervalMs)
    {
        _sharedConfigurationActions.Add(builder => builder.WithTopicMetadataRefreshIntervalMs(topicMetadataRefreshIntervalMs));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithMetadataMaxAgeMs(int? metadataMaxAgeMs)
    {
        _sharedConfigurationActions.Add(builder => builder.WithMetadataMaxAgeMs(metadataMaxAgeMs));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithTopicMetadataRefreshFastIntervalMs(int? topicMetadataRefreshFastIntervalMs)
    {
        _sharedConfigurationActions.Add(builder => builder.WithTopicMetadataRefreshFastIntervalMs(topicMetadataRefreshFastIntervalMs));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithTopicMetadataPropagationMaxMs(int? topicMetadataPropagationMaxMs)
    {
        _sharedConfigurationActions.Add(builder => builder.WithTopicMetadataPropagationMaxMs(topicMetadataPropagationMaxMs));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithTopicBlacklist(string? topicBlacklist)
    {
        _sharedConfigurationActions.Add(builder => builder.WithTopicBlacklist(topicBlacklist));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithDebug(string? debug)
    {
        _sharedConfigurationActions.Add(builder => builder.WithDebug(debug));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithSocketTimeoutMs(int? socketTimeoutMs)
    {
        _sharedConfigurationActions.Add(builder => builder.WithSocketTimeoutMs(socketTimeoutMs));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithSocketSendBufferBytes(int? socketSendBufferBytes)
    {
        _sharedConfigurationActions.Add(builder => builder.WithSocketSendBufferBytes(socketSendBufferBytes));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithSocketReceiveBufferBytes(int? socketReceiveBufferBytes)
    {
        _sharedConfigurationActions.Add(builder => builder.WithSocketReceiveBufferBytes(socketReceiveBufferBytes));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithSocketMaxFails(int? socketMaxFails)
    {
        _sharedConfigurationActions.Add(builder => builder.WithSocketMaxFails(socketMaxFails));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithBrokerAddressTtl(int? brokerAddressTtl)
    {
        _sharedConfigurationActions.Add(builder => builder.WithBrokerAddressTtl(brokerAddressTtl));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithBrokerAddressFamily(BrokerAddressFamily? brokerAddressFamily)
    {
        _sharedConfigurationActions.Add(builder => builder.WithBrokerAddressFamily(brokerAddressFamily));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithSocketConnectionSetupTimeoutMs(int? socketConnectionSetupTimeoutMs)
    {
        _sharedConfigurationActions.Add(builder => builder.WithSocketConnectionSetupTimeoutMs(socketConnectionSetupTimeoutMs));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithConnectionsMaxIdleMs(int? connectionsMaxIdleMs)
    {
        _sharedConfigurationActions.Add(builder => builder.WithConnectionsMaxIdleMs(connectionsMaxIdleMs));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithReconnectBackoffMs(int? reconnectBackoffMs)
    {
        _sharedConfigurationActions.Add(builder => builder.WithReconnectBackoffMs(reconnectBackoffMs));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithReconnectBackoffMaxMs(int? reconnectBackoffMaxMs)
    {
        _sharedConfigurationActions.Add(builder => builder.WithReconnectBackoffMaxMs(reconnectBackoffMaxMs));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithStatisticsIntervalMs(int? statisticsIntervalMs)
    {
        _sharedConfigurationActions.Add(builder => builder.WithStatisticsIntervalMs(statisticsIntervalMs));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithApiVersionRequestTimeoutMs(int? apiVersionRequestTimeoutMs)
    {
        _sharedConfigurationActions.Add(builder => builder.WithApiVersionRequestTimeoutMs(apiVersionRequestTimeoutMs));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithApiVersionFallbackMs(int? apiVersionFallbackMs)
    {
        _sharedConfigurationActions.Add(builder => builder.WithApiVersionFallbackMs(apiVersionFallbackMs));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithBrokerVersionFallback(string? brokerVersionFallback)
    {
        _sharedConfigurationActions.Add(builder => builder.WithBrokerVersionFallback(brokerVersionFallback));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithSecurityProtocol(SecurityProtocol? securityProtocol)
    {
        _sharedConfigurationActions.Add(builder => builder.WithSecurityProtocol(securityProtocol));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithSslCipherSuites(string? sslCipherSuites)
    {
        _sharedConfigurationActions.Add(builder => builder.WithSslCipherSuites(sslCipherSuites));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithSslCurvesList(string? sslCurvesList)
    {
        _sharedConfigurationActions.Add(builder => builder.WithSslCurvesList(sslCurvesList));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithSslSigalgsList(string? sslSigalgsList)
    {
        _sharedConfigurationActions.Add(builder => builder.WithSslSigalgsList(sslSigalgsList));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithSslKeyLocation(string? sslKeyLocation)
    {
        _sharedConfigurationActions.Add(builder => builder.WithSslKeyLocation(sslKeyLocation));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithSslKeyPassword(string? sslKeyPassword)
    {
        _sharedConfigurationActions.Add(builder => builder.WithSslKeyPassword(sslKeyPassword));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithSslKeyPem(string? sslKeyPem)
    {
        _sharedConfigurationActions.Add(builder => builder.WithSslKeyPem(sslKeyPem));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithSslCertificateLocation(string? sslCertificateLocation)
    {
        _sharedConfigurationActions.Add(builder => builder.WithSslCertificateLocation(sslCertificateLocation));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithSslCertificatePem(string? sslCertificatePem)
    {
        _sharedConfigurationActions.Add(builder => builder.WithSslCertificatePem(sslCertificatePem));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithSslCaLocation(string? sslCaLocation)
    {
        _sharedConfigurationActions.Add(builder => builder.WithSslCaLocation(sslCaLocation));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithSslCaPem(string? sslCaPem)
    {
        _sharedConfigurationActions.Add(builder => builder.WithSslCaPem(sslCaPem));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithSslCaCertificateStores(string? sslCaCertificateStores)
    {
        _sharedConfigurationActions.Add(builder => builder.WithSslCaCertificateStores(sslCaCertificateStores));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithSslCrlLocation(string? sslCrlLocation)
    {
        _sharedConfigurationActions.Add(builder => builder.WithSslCrlLocation(sslCrlLocation));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithSslKeystoreLocation(string? sslKeystoreLocation)
    {
        _sharedConfigurationActions.Add(builder => builder.WithSslKeystoreLocation(sslKeystoreLocation));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithSslKeystorePassword(string? sslKeystorePassword)
    {
        _sharedConfigurationActions.Add(builder => builder.WithSslKeystorePassword(sslKeystorePassword));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithSslProviders(string? sslProviders)
    {
        _sharedConfigurationActions.Add(builder => builder.WithSslProviders(sslProviders));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithSslEngineLocation(string? sslEngineLocation)
    {
        _sharedConfigurationActions.Add(builder => builder.WithSslEngineLocation(sslEngineLocation));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithSslEngineId(string? sslEngineId)
    {
        _sharedConfigurationActions.Add(builder => builder.WithSslEngineId(sslEngineId));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithSslEndpointIdentificationAlgorithm(SslEndpointIdentificationAlgorithm? sslEndpointIdentificationAlgorithm)
    {
        _sharedConfigurationActions.Add(builder => builder.WithSslEndpointIdentificationAlgorithm(sslEndpointIdentificationAlgorithm));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithSaslKerberosServiceName(string? saslKerberosServiceName)
    {
        _sharedConfigurationActions.Add(builder => builder.WithSaslKerberosServiceName(saslKerberosServiceName));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithSaslKerberosPrincipal(string? saslKerberosPrincipal)
    {
        _sharedConfigurationActions.Add(builder => builder.WithSaslKerberosPrincipal(saslKerberosPrincipal));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithSaslKerberosKinitCmd(string? saslKerberosKinitCmd)
    {
        _sharedConfigurationActions.Add(builder => builder.WithSaslKerberosKinitCmd(saslKerberosKinitCmd));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithSaslKerberosKeytab(string? saslKerberosKeytab)
    {
        _sharedConfigurationActions.Add(builder => builder.WithSaslKerberosKeytab(saslKerberosKeytab));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithSaslKerberosMinTimeBeforeRelogin(int? saslKerberosMinTimeBeforeRelogin)
    {
        _sharedConfigurationActions.Add(builder => builder.WithSaslKerberosMinTimeBeforeRelogin(saslKerberosMinTimeBeforeRelogin));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithSaslUsername(string? saslUsername)
    {
        _sharedConfigurationActions.Add(builder => builder.WithSaslUsername(saslUsername));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithSaslPassword(string? saslPassword)
    {
        _sharedConfigurationActions.Add(builder => builder.WithSaslPassword(saslPassword));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithSaslOauthbearerConfig(string? saslOauthbearerConfig)
    {
        _sharedConfigurationActions.Add(builder => builder.WithSaslOauthbearerConfig(saslOauthbearerConfig));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithSaslOauthbearerMethod(SaslOauthbearerMethod? saslOauthbearerMethod)
    {
        _sharedConfigurationActions.Add(builder => builder.WithSaslOauthbearerMethod(saslOauthbearerMethod));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithSaslOauthbearerClientId(string? saslOauthbearerClientId)
    {
        _sharedConfigurationActions.Add(builder => builder.WithSaslOauthbearerClientId(saslOauthbearerClientId));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithSaslOauthbearerClientSecret(string? saslOauthbearerClientSecret)
    {
        _sharedConfigurationActions.Add(builder => builder.WithSaslOauthbearerClientSecret(saslOauthbearerClientSecret));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithSaslOauthbearerScope(string? saslOauthbearerScope)
    {
        _sharedConfigurationActions.Add(builder => builder.WithSaslOauthbearerScope(saslOauthbearerScope));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithSaslOauthbearerExtensions(string? saslOauthbearerExtensions)
    {
        _sharedConfigurationActions.Add(builder => builder.WithSaslOauthbearerExtensions(saslOauthbearerExtensions));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithSaslOauthbearerTokenEndpointUrl(string? saslOauthbearerTokenEndpointUrl)
    {
        _sharedConfigurationActions.Add(builder => builder.WithSaslOauthbearerTokenEndpointUrl(saslOauthbearerTokenEndpointUrl));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithPluginLibraryPaths(string? pluginLibraryPaths)
    {
        _sharedConfigurationActions.Add(builder => builder.WithPluginLibraryPaths(pluginLibraryPaths));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithClientRack(string? clientRack)
    {
        _sharedConfigurationActions.Add(builder => builder.WithClientRack(clientRack));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithRetryBackoffMs(int? retryBackoffMs)
    {
        _sharedConfigurationActions.Add(builder => builder.WithRetryBackoffMs(retryBackoffMs));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithRetryBackoffMaxMs(int? retryBackoffMaxMs)
    {
        _sharedConfigurationActions.Add(builder => builder.WithRetryBackoffMaxMs(retryBackoffMaxMs));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithClientDnsLookup(ClientDnsLookup? clientDnsLookup)
    {
        _sharedConfigurationActions.Add(builder => builder.WithClientDnsLookup(clientDnsLookup));
        return this;
    }

    public partial KafkaClientsConfigurationBuilder WithCancellationDelayMaxMs(int cancellationDelayMaxMs)
    {
        _sharedConfigurationActions.Add(builder => builder.WithCancellationDelayMaxMs(cancellationDelayMaxMs));
        return this;
    }

    internal KafkaClientsConfigurationBuilder WithTopicMetadataRefreshSparse(bool? topicMetadataRefreshSparse)
    {
        _sharedConfigurationActions.Add(builder => builder.WithTopicMetadataRefreshSparse(topicMetadataRefreshSparse));
        return this;
    }

    internal KafkaClientsConfigurationBuilder WithSocketKeepaliveEnable(bool? socketKeepaliveEnable)
    {
        _sharedConfigurationActions.Add(builder => builder.WithSocketKeepaliveEnable(socketKeepaliveEnable));
        return this;
    }

    internal KafkaClientsConfigurationBuilder WithSocketNagleDisable(bool? socketNagleDisable)
    {
        _sharedConfigurationActions.Add(builder => builder.WithSocketNagleDisable(socketNagleDisable));
        return this;
    }

    internal KafkaClientsConfigurationBuilder WithApiVersionRequest(bool? apiVersionRequest)
    {
        _sharedConfigurationActions.Add(builder => builder.WithApiVersionRequest(apiVersionRequest));
        return this;
    }

    internal KafkaClientsConfigurationBuilder WithAllowAutoCreateTopics(bool? allowAutoCreateTopics)
    {
        _sharedConfigurationActions.Add(builder => builder.WithAllowAutoCreateTopics(allowAutoCreateTopics));
        return this;
    }

    internal KafkaClientsConfigurationBuilder WithEnableSslCertificateVerification(bool? enableSslCertificateVerification)
    {
        _sharedConfigurationActions.Add(builder => builder.WithEnableSslCertificateVerification(enableSslCertificateVerification));
        return this;
    }

    internal KafkaClientsConfigurationBuilder WithEnableSaslOauthbearerUnsecureJwt(bool? enableSaslOauthbearerUnsecureJwt)
    {
        _sharedConfigurationActions.Add(builder => builder.WithEnableSaslOauthbearerUnsecureJwt(enableSaslOauthbearerUnsecureJwt));
        return this;
    }

    internal KafkaClientsConfigurationBuilder WithEnableMetricsPush(bool? enableMetricsPush)
    {
        _sharedConfigurationActions.Add(builder => builder.WithEnableMetricsPush(enableMetricsPush));
        return this;
    }
}

/// <content>
///     The autogenerated part of the <see cref="KafkaClientConfigurationBuilder{TConfig, TConfluentConfig, TBuilder}" /> class.
/// </content>
[SuppressMessage("StyleCop.CSharp.MaintainabilityRules", "SA1402:File may only contain a single type", Justification = "Autogenerated all at once")]
[SuppressMessage("StyleCop.CSharp.OrderingRules", "SA1202: 'public' members should come before 'internal' members", Justification = "Autogenerated")]
[SuppressMessage("StyleCop.CSharp.DocumentationRules", "SA1600:Elements should be documented", Justification = "Documented in other partial")]
[SuppressMessage("StyleCop.CSharp.DocumentationRules", "SA1601:Partial elements should be documented", Justification = "Autogenerated")]
public partial class KafkaClientConfigurationBuilder<TConfig, TConfluentConfig, TBuilder> : IKafkaClientConfigurationBuilder
{
    private SaslMechanism? _saslMechanism;

    private Acks? _acks;

    private string? _clientId;

    private string? _bootstrapServers;

    private int? _messageMaxBytes;

    private int? _messageCopyMaxBytes;

    private int? _receiveMessageMaxBytes;

    private int? _maxInFlight;

    private int? _topicMetadataRefreshIntervalMs;

    private int? _metadataMaxAgeMs;

    private int? _topicMetadataRefreshFastIntervalMs;

    private bool? _topicMetadataRefreshSparse;

    private int? _topicMetadataPropagationMaxMs;

    private string? _topicBlacklist;

    private string? _debug;

    private int? _socketTimeoutMs;

    private int? _socketSendBufferBytes;

    private int? _socketReceiveBufferBytes;

    private bool? _socketKeepaliveEnable;

    private bool? _socketNagleDisable;

    private int? _socketMaxFails;

    private int? _brokerAddressTtl;

    private BrokerAddressFamily? _brokerAddressFamily;

    private int? _socketConnectionSetupTimeoutMs;

    private int? _connectionsMaxIdleMs;

    private int? _reconnectBackoffMs;

    private int? _reconnectBackoffMaxMs;

    private int? _statisticsIntervalMs;

    private bool? _apiVersionRequest;

    private int? _apiVersionRequestTimeoutMs;

    private int? _apiVersionFallbackMs;

    private string? _brokerVersionFallback;

    private bool? _allowAutoCreateTopics;

    private SecurityProtocol? _securityProtocol;

    private string? _sslCipherSuites;

    private string? _sslCurvesList;

    private string? _sslSigalgsList;

    private string? _sslKeyLocation;

    private string? _sslKeyPassword;

    private string? _sslKeyPem;

    private string? _sslCertificateLocation;

    private string? _sslCertificatePem;

    private string? _sslCaLocation;

    private string? _sslCaPem;

    private string? _sslCaCertificateStores;

    private string? _sslCrlLocation;

    private string? _sslKeystoreLocation;

    private string? _sslKeystorePassword;

    private string? _sslProviders;

    private string? _sslEngineLocation;

    private string? _sslEngineId;

    private bool? _enableSslCertificateVerification;

    private SslEndpointIdentificationAlgorithm? _sslEndpointIdentificationAlgorithm;

    private string? _saslKerberosServiceName;

    private string? _saslKerberosPrincipal;

    private string? _saslKerberosKinitCmd;

    private string? _saslKerberosKeytab;

    private int? _saslKerberosMinTimeBeforeRelogin;

    private string? _saslUsername;

    private string? _saslPassword;

    private string? _saslOauthbearerConfig;

    private bool? _enableSaslOauthbearerUnsecureJwt;

    private SaslOauthbearerMethod? _saslOauthbearerMethod;

    private string? _saslOauthbearerClientId;

    private string? _saslOauthbearerClientSecret;

    private string? _saslOauthbearerScope;

    private string? _saslOauthbearerExtensions;

    private string? _saslOauthbearerTokenEndpointUrl;

    private string? _pluginLibraryPaths;

    private string? _clientRack;

    private int? _retryBackoffMs;

    private int? _retryBackoffMaxMs;

    private ClientDnsLookup? _clientDnsLookup;

    private bool? _enableMetricsPush;

    private int? _cancellationDelayMaxMs;

    public partial TBuilder WithSaslMechanism(SaslMechanism? saslMechanism)
    {
        _saslMechanism = saslMechanism;
        return This;
    }

    public partial TBuilder WithAcks(Acks? acks)
    {
        _acks = acks;
        return This;
    }

    public partial TBuilder WithClientId(string? clientId)
    {
        _clientId = clientId;
        return This;
    }

    public partial TBuilder WithBootstrapServers(string? bootstrapServers)
    {
        _bootstrapServers = bootstrapServers;
        return This;
    }

    public partial TBuilder WithMessageMaxBytes(int? messageMaxBytes)
    {
        _messageMaxBytes = messageMaxBytes;
        return This;
    }

    public partial TBuilder WithMessageCopyMaxBytes(int? messageCopyMaxBytes)
    {
        _messageCopyMaxBytes = messageCopyMaxBytes;
        return This;
    }

    public partial TBuilder WithReceiveMessageMaxBytes(int? receiveMessageMaxBytes)
    {
        _receiveMessageMaxBytes = receiveMessageMaxBytes;
        return This;
    }

    public partial TBuilder WithMaxInFlight(int? maxInFlight)
    {
        _maxInFlight = maxInFlight;
        return This;
    }

    public partial TBuilder WithTopicMetadataRefreshIntervalMs(int? topicMetadataRefreshIntervalMs)
    {
        _topicMetadataRefreshIntervalMs = topicMetadataRefreshIntervalMs;
        return This;
    }

    public partial TBuilder WithMetadataMaxAgeMs(int? metadataMaxAgeMs)
    {
        _metadataMaxAgeMs = metadataMaxAgeMs;
        return This;
    }

    public partial TBuilder WithTopicMetadataRefreshFastIntervalMs(int? topicMetadataRefreshFastIntervalMs)
    {
        _topicMetadataRefreshFastIntervalMs = topicMetadataRefreshFastIntervalMs;
        return This;
    }

    public partial TBuilder WithTopicMetadataPropagationMaxMs(int? topicMetadataPropagationMaxMs)
    {
        _topicMetadataPropagationMaxMs = topicMetadataPropagationMaxMs;
        return This;
    }

    public partial TBuilder WithTopicBlacklist(string? topicBlacklist)
    {
        _topicBlacklist = topicBlacklist;
        return This;
    }

    public partial TBuilder WithDebug(string? debug)
    {
        _debug = debug;
        return This;
    }

    public partial TBuilder WithSocketTimeoutMs(int? socketTimeoutMs)
    {
        _socketTimeoutMs = socketTimeoutMs;
        return This;
    }

    public partial TBuilder WithSocketSendBufferBytes(int? socketSendBufferBytes)
    {
        _socketSendBufferBytes = socketSendBufferBytes;
        return This;
    }

    public partial TBuilder WithSocketReceiveBufferBytes(int? socketReceiveBufferBytes)
    {
        _socketReceiveBufferBytes = socketReceiveBufferBytes;
        return This;
    }

    public partial TBuilder WithSocketMaxFails(int? socketMaxFails)
    {
        _socketMaxFails = socketMaxFails;
        return This;
    }

    public partial TBuilder WithBrokerAddressTtl(int? brokerAddressTtl)
    {
        _brokerAddressTtl = brokerAddressTtl;
        return This;
    }

    public partial TBuilder WithBrokerAddressFamily(BrokerAddressFamily? brokerAddressFamily)
    {
        _brokerAddressFamily = brokerAddressFamily;
        return This;
    }

    public partial TBuilder WithSocketConnectionSetupTimeoutMs(int? socketConnectionSetupTimeoutMs)
    {
        _socketConnectionSetupTimeoutMs = socketConnectionSetupTimeoutMs;
        return This;
    }

    public partial TBuilder WithConnectionsMaxIdleMs(int? connectionsMaxIdleMs)
    {
        _connectionsMaxIdleMs = connectionsMaxIdleMs;
        return This;
    }

    public partial TBuilder WithReconnectBackoffMs(int? reconnectBackoffMs)
    {
        _reconnectBackoffMs = reconnectBackoffMs;
        return This;
    }

    public partial TBuilder WithReconnectBackoffMaxMs(int? reconnectBackoffMaxMs)
    {
        _reconnectBackoffMaxMs = reconnectBackoffMaxMs;
        return This;
    }

    public partial TBuilder WithStatisticsIntervalMs(int? statisticsIntervalMs)
    {
        _statisticsIntervalMs = statisticsIntervalMs;
        return This;
    }

    public partial TBuilder WithApiVersionRequestTimeoutMs(int? apiVersionRequestTimeoutMs)
    {
        _apiVersionRequestTimeoutMs = apiVersionRequestTimeoutMs;
        return This;
    }

    public partial TBuilder WithApiVersionFallbackMs(int? apiVersionFallbackMs)
    {
        _apiVersionFallbackMs = apiVersionFallbackMs;
        return This;
    }

    public partial TBuilder WithBrokerVersionFallback(string? brokerVersionFallback)
    {
        _brokerVersionFallback = brokerVersionFallback;
        return This;
    }

    public partial TBuilder WithSecurityProtocol(SecurityProtocol? securityProtocol)
    {
        _securityProtocol = securityProtocol;
        return This;
    }

    public partial TBuilder WithSslCipherSuites(string? sslCipherSuites)
    {
        _sslCipherSuites = sslCipherSuites;
        return This;
    }

    public partial TBuilder WithSslCurvesList(string? sslCurvesList)
    {
        _sslCurvesList = sslCurvesList;
        return This;
    }

    public partial TBuilder WithSslSigalgsList(string? sslSigalgsList)
    {
        _sslSigalgsList = sslSigalgsList;
        return This;
    }

    public partial TBuilder WithSslKeyLocation(string? sslKeyLocation)
    {
        _sslKeyLocation = sslKeyLocation;
        return This;
    }

    public partial TBuilder WithSslKeyPassword(string? sslKeyPassword)
    {
        _sslKeyPassword = sslKeyPassword;
        return This;
    }

    public partial TBuilder WithSslKeyPem(string? sslKeyPem)
    {
        _sslKeyPem = sslKeyPem;
        return This;
    }

    public partial TBuilder WithSslCertificateLocation(string? sslCertificateLocation)
    {
        _sslCertificateLocation = sslCertificateLocation;
        return This;
    }

    public partial TBuilder WithSslCertificatePem(string? sslCertificatePem)
    {
        _sslCertificatePem = sslCertificatePem;
        return This;
    }

    public partial TBuilder WithSslCaLocation(string? sslCaLocation)
    {
        _sslCaLocation = sslCaLocation;
        return This;
    }

    public partial TBuilder WithSslCaPem(string? sslCaPem)
    {
        _sslCaPem = sslCaPem;
        return This;
    }

    public partial TBuilder WithSslCaCertificateStores(string? sslCaCertificateStores)
    {
        _sslCaCertificateStores = sslCaCertificateStores;
        return This;
    }

    public partial TBuilder WithSslCrlLocation(string? sslCrlLocation)
    {
        _sslCrlLocation = sslCrlLocation;
        return This;
    }

    public partial TBuilder WithSslKeystoreLocation(string? sslKeystoreLocation)
    {
        _sslKeystoreLocation = sslKeystoreLocation;
        return This;
    }

    public partial TBuilder WithSslKeystorePassword(string? sslKeystorePassword)
    {
        _sslKeystorePassword = sslKeystorePassword;
        return This;
    }

    public partial TBuilder WithSslProviders(string? sslProviders)
    {
        _sslProviders = sslProviders;
        return This;
    }

    public partial TBuilder WithSslEngineLocation(string? sslEngineLocation)
    {
        _sslEngineLocation = sslEngineLocation;
        return This;
    }

    public partial TBuilder WithSslEngineId(string? sslEngineId)
    {
        _sslEngineId = sslEngineId;
        return This;
    }

    public partial TBuilder WithSslEndpointIdentificationAlgorithm(SslEndpointIdentificationAlgorithm? sslEndpointIdentificationAlgorithm)
    {
        _sslEndpointIdentificationAlgorithm = sslEndpointIdentificationAlgorithm;
        return This;
    }

    public partial TBuilder WithSaslKerberosServiceName(string? saslKerberosServiceName)
    {
        _saslKerberosServiceName = saslKerberosServiceName;
        return This;
    }

    public partial TBuilder WithSaslKerberosPrincipal(string? saslKerberosPrincipal)
    {
        _saslKerberosPrincipal = saslKerberosPrincipal;
        return This;
    }

    public partial TBuilder WithSaslKerberosKinitCmd(string? saslKerberosKinitCmd)
    {
        _saslKerberosKinitCmd = saslKerberosKinitCmd;
        return This;
    }

    public partial TBuilder WithSaslKerberosKeytab(string? saslKerberosKeytab)
    {
        _saslKerberosKeytab = saslKerberosKeytab;
        return This;
    }

    public partial TBuilder WithSaslKerberosMinTimeBeforeRelogin(int? saslKerberosMinTimeBeforeRelogin)
    {
        _saslKerberosMinTimeBeforeRelogin = saslKerberosMinTimeBeforeRelogin;
        return This;
    }

    public partial TBuilder WithSaslUsername(string? saslUsername)
    {
        _saslUsername = saslUsername;
        return This;
    }

    public partial TBuilder WithSaslPassword(string? saslPassword)
    {
        _saslPassword = saslPassword;
        return This;
    }

    public partial TBuilder WithSaslOauthbearerConfig(string? saslOauthbearerConfig)
    {
        _saslOauthbearerConfig = saslOauthbearerConfig;
        return This;
    }

    public partial TBuilder WithSaslOauthbearerMethod(SaslOauthbearerMethod? saslOauthbearerMethod)
    {
        _saslOauthbearerMethod = saslOauthbearerMethod;
        return This;
    }

    public partial TBuilder WithSaslOauthbearerClientId(string? saslOauthbearerClientId)
    {
        _saslOauthbearerClientId = saslOauthbearerClientId;
        return This;
    }

    public partial TBuilder WithSaslOauthbearerClientSecret(string? saslOauthbearerClientSecret)
    {
        _saslOauthbearerClientSecret = saslOauthbearerClientSecret;
        return This;
    }

    public partial TBuilder WithSaslOauthbearerScope(string? saslOauthbearerScope)
    {
        _saslOauthbearerScope = saslOauthbearerScope;
        return This;
    }

    public partial TBuilder WithSaslOauthbearerExtensions(string? saslOauthbearerExtensions)
    {
        _saslOauthbearerExtensions = saslOauthbearerExtensions;
        return This;
    }

    public partial TBuilder WithSaslOauthbearerTokenEndpointUrl(string? saslOauthbearerTokenEndpointUrl)
    {
        _saslOauthbearerTokenEndpointUrl = saslOauthbearerTokenEndpointUrl;
        return This;
    }

    public partial TBuilder WithPluginLibraryPaths(string? pluginLibraryPaths)
    {
        _pluginLibraryPaths = pluginLibraryPaths;
        return This;
    }

    public partial TBuilder WithClientRack(string? clientRack)
    {
        _clientRack = clientRack;
        return This;
    }

    public partial TBuilder WithRetryBackoffMs(int? retryBackoffMs)
    {
        _retryBackoffMs = retryBackoffMs;
        return This;
    }

    public partial TBuilder WithRetryBackoffMaxMs(int? retryBackoffMaxMs)
    {
        _retryBackoffMaxMs = retryBackoffMaxMs;
        return This;
    }

    public partial TBuilder WithClientDnsLookup(ClientDnsLookup? clientDnsLookup)
    {
        _clientDnsLookup = clientDnsLookup;
        return This;
    }

    public partial TBuilder WithCancellationDelayMaxMs(int cancellationDelayMaxMs)
    {
        _cancellationDelayMaxMs = cancellationDelayMaxMs;
        return This;
    }

    internal TBuilder WithTopicMetadataRefreshSparse(bool? topicMetadataRefreshSparse)
    {
        _topicMetadataRefreshSparse = topicMetadataRefreshSparse;
        return This;
    }

    internal TBuilder WithSocketKeepaliveEnable(bool? socketKeepaliveEnable)
    {
        _socketKeepaliveEnable = socketKeepaliveEnable;
        return This;
    }

    internal TBuilder WithSocketNagleDisable(bool? socketNagleDisable)
    {
        _socketNagleDisable = socketNagleDisable;
        return This;
    }

    internal TBuilder WithApiVersionRequest(bool? apiVersionRequest)
    {
        _apiVersionRequest = apiVersionRequest;
        return This;
    }

    internal TBuilder WithAllowAutoCreateTopics(bool? allowAutoCreateTopics)
    {
        _allowAutoCreateTopics = allowAutoCreateTopics;
        return This;
    }

    internal TBuilder WithEnableSslCertificateVerification(bool? enableSslCertificateVerification)
    {
        _enableSslCertificateVerification = enableSslCertificateVerification;
        return This;
    }

    internal TBuilder WithEnableSaslOauthbearerUnsecureJwt(bool? enableSaslOauthbearerUnsecureJwt)
    {
        _enableSaslOauthbearerUnsecureJwt = enableSaslOauthbearerUnsecureJwt;
        return This;
    }

    internal TBuilder WithEnableMetricsPush(bool? enableMetricsPush)
    {
        _enableMetricsPush = enableMetricsPush;
        return This;
    }

    /// <summary>
    ///     Builds the configuration.
    /// </summary>
    /// <returns>
    ///     The configuration.
    /// </returns>
    protected virtual TConfig BuildCore()
    {
        TConfig config = new()
        {
            SaslMechanism = _saslMechanism,
            Acks = _acks,
            ClientId = _clientId,
            BootstrapServers = _bootstrapServers,
            MessageMaxBytes = _messageMaxBytes,
            MessageCopyMaxBytes = _messageCopyMaxBytes,
            ReceiveMessageMaxBytes = _receiveMessageMaxBytes,
            MaxInFlight = _maxInFlight,
            TopicMetadataRefreshIntervalMs = _topicMetadataRefreshIntervalMs,
            MetadataMaxAgeMs = _metadataMaxAgeMs,
            TopicMetadataRefreshFastIntervalMs = _topicMetadataRefreshFastIntervalMs,
            TopicMetadataRefreshSparse = _topicMetadataRefreshSparse,
            TopicMetadataPropagationMaxMs = _topicMetadataPropagationMaxMs,
            TopicBlacklist = _topicBlacklist,
            Debug = _debug,
            SocketTimeoutMs = _socketTimeoutMs,
            SocketSendBufferBytes = _socketSendBufferBytes,
            SocketReceiveBufferBytes = _socketReceiveBufferBytes,
            SocketKeepaliveEnable = _socketKeepaliveEnable,
            SocketNagleDisable = _socketNagleDisable,
            SocketMaxFails = _socketMaxFails,
            BrokerAddressTtl = _brokerAddressTtl,
            BrokerAddressFamily = _brokerAddressFamily,
            SocketConnectionSetupTimeoutMs = _socketConnectionSetupTimeoutMs,
            ConnectionsMaxIdleMs = _connectionsMaxIdleMs,
            ReconnectBackoffMs = _reconnectBackoffMs,
            ReconnectBackoffMaxMs = _reconnectBackoffMaxMs,
            StatisticsIntervalMs = _statisticsIntervalMs,
            ApiVersionRequest = _apiVersionRequest,
            ApiVersionRequestTimeoutMs = _apiVersionRequestTimeoutMs,
            ApiVersionFallbackMs = _apiVersionFallbackMs,
            BrokerVersionFallback = _brokerVersionFallback,
            AllowAutoCreateTopics = _allowAutoCreateTopics,
            SecurityProtocol = _securityProtocol,
            SslCipherSuites = _sslCipherSuites,
            SslCurvesList = _sslCurvesList,
            SslSigalgsList = _sslSigalgsList,
            SslKeyLocation = _sslKeyLocation,
            SslKeyPassword = _sslKeyPassword,
            SslKeyPem = _sslKeyPem,
            SslCertificateLocation = _sslCertificateLocation,
            SslCertificatePem = _sslCertificatePem,
            SslCaLocation = _sslCaLocation,
            SslCaPem = _sslCaPem,
            SslCaCertificateStores = _sslCaCertificateStores,
            SslCrlLocation = _sslCrlLocation,
            SslKeystoreLocation = _sslKeystoreLocation,
            SslKeystorePassword = _sslKeystorePassword,
            SslProviders = _sslProviders,
            SslEngineLocation = _sslEngineLocation,
            SslEngineId = _sslEngineId,
            EnableSslCertificateVerification = _enableSslCertificateVerification,
            SslEndpointIdentificationAlgorithm = _sslEndpointIdentificationAlgorithm,
            SaslKerberosServiceName = _saslKerberosServiceName,
            SaslKerberosPrincipal = _saslKerberosPrincipal,
            SaslKerberosKinitCmd = _saslKerberosKinitCmd,
            SaslKerberosKeytab = _saslKerberosKeytab,
            SaslKerberosMinTimeBeforeRelogin = _saslKerberosMinTimeBeforeRelogin,
            SaslUsername = _saslUsername,
            SaslPassword = _saslPassword,
            SaslOauthbearerConfig = _saslOauthbearerConfig,
            EnableSaslOauthbearerUnsecureJwt = _enableSaslOauthbearerUnsecureJwt,
            SaslOauthbearerMethod = _saslOauthbearerMethod,
            SaslOauthbearerClientId = _saslOauthbearerClientId,
            SaslOauthbearerClientSecret = _saslOauthbearerClientSecret,
            SaslOauthbearerScope = _saslOauthbearerScope,
            SaslOauthbearerExtensions = _saslOauthbearerExtensions,
            SaslOauthbearerTokenEndpointUrl = _saslOauthbearerTokenEndpointUrl,
            PluginLibraryPaths = _pluginLibraryPaths,
            ClientRack = _clientRack,
            RetryBackoffMs = _retryBackoffMs,
            RetryBackoffMaxMs = _retryBackoffMaxMs,
            ClientDnsLookup = _clientDnsLookup,
            EnableMetricsPush = _enableMetricsPush
        };

        if (_cancellationDelayMaxMs.HasValue)
        {
            config = config with
            {
                CancellationDelayMaxMs = _cancellationDelayMaxMs
            };
        }

        return config;
    }

    void IKafkaClientConfigurationBuilder.WithSaslMechanism(SaslMechanism? saslMechanism) => WithSaslMechanism(saslMechanism);

    void IKafkaClientConfigurationBuilder.WithAcks(Acks? acks) => WithAcks(acks);

    void IKafkaClientConfigurationBuilder.WithClientId(string? clientId) => WithClientId(clientId);

    void IKafkaClientConfigurationBuilder.WithBootstrapServers(string? bootstrapServers) => WithBootstrapServers(bootstrapServers);

    void IKafkaClientConfigurationBuilder.WithMessageMaxBytes(int? messageMaxBytes) => WithMessageMaxBytes(messageMaxBytes);

    void IKafkaClientConfigurationBuilder.WithMessageCopyMaxBytes(int? messageCopyMaxBytes) => WithMessageCopyMaxBytes(messageCopyMaxBytes);

    void IKafkaClientConfigurationBuilder.WithReceiveMessageMaxBytes(int? receiveMessageMaxBytes) => WithReceiveMessageMaxBytes(receiveMessageMaxBytes);

    void IKafkaClientConfigurationBuilder.WithMaxInFlight(int? maxInFlight) => WithMaxInFlight(maxInFlight);

    void IKafkaClientConfigurationBuilder.WithTopicMetadataRefreshIntervalMs(int? topicMetadataRefreshIntervalMs) => WithTopicMetadataRefreshIntervalMs(topicMetadataRefreshIntervalMs);

    void IKafkaClientConfigurationBuilder.WithMetadataMaxAgeMs(int? metadataMaxAgeMs) => WithMetadataMaxAgeMs(metadataMaxAgeMs);

    void IKafkaClientConfigurationBuilder.WithTopicMetadataRefreshFastIntervalMs(int? topicMetadataRefreshFastIntervalMs) => WithTopicMetadataRefreshFastIntervalMs(topicMetadataRefreshFastIntervalMs);

    void IKafkaClientConfigurationBuilder.WithTopicMetadataRefreshSparse(bool? topicMetadataRefreshSparse) => WithTopicMetadataRefreshSparse(topicMetadataRefreshSparse);

    void IKafkaClientConfigurationBuilder.WithTopicMetadataPropagationMaxMs(int? topicMetadataPropagationMaxMs) => WithTopicMetadataPropagationMaxMs(topicMetadataPropagationMaxMs);

    void IKafkaClientConfigurationBuilder.WithTopicBlacklist(string? topicBlacklist) => WithTopicBlacklist(topicBlacklist);

    void IKafkaClientConfigurationBuilder.WithDebug(string? debug) => WithDebug(debug);

    void IKafkaClientConfigurationBuilder.WithSocketTimeoutMs(int? socketTimeoutMs) => WithSocketTimeoutMs(socketTimeoutMs);

    void IKafkaClientConfigurationBuilder.WithSocketSendBufferBytes(int? socketSendBufferBytes) => WithSocketSendBufferBytes(socketSendBufferBytes);

    void IKafkaClientConfigurationBuilder.WithSocketReceiveBufferBytes(int? socketReceiveBufferBytes) => WithSocketReceiveBufferBytes(socketReceiveBufferBytes);

    void IKafkaClientConfigurationBuilder.WithSocketKeepaliveEnable(bool? socketKeepaliveEnable) => WithSocketKeepaliveEnable(socketKeepaliveEnable);

    void IKafkaClientConfigurationBuilder.WithSocketNagleDisable(bool? socketNagleDisable) => WithSocketNagleDisable(socketNagleDisable);

    void IKafkaClientConfigurationBuilder.WithSocketMaxFails(int? socketMaxFails) => WithSocketMaxFails(socketMaxFails);

    void IKafkaClientConfigurationBuilder.WithBrokerAddressTtl(int? brokerAddressTtl) => WithBrokerAddressTtl(brokerAddressTtl);

    void IKafkaClientConfigurationBuilder.WithBrokerAddressFamily(BrokerAddressFamily? brokerAddressFamily) => WithBrokerAddressFamily(brokerAddressFamily);

    void IKafkaClientConfigurationBuilder.WithSocketConnectionSetupTimeoutMs(int? socketConnectionSetupTimeoutMs) => WithSocketConnectionSetupTimeoutMs(socketConnectionSetupTimeoutMs);

    void IKafkaClientConfigurationBuilder.WithConnectionsMaxIdleMs(int? connectionsMaxIdleMs) => WithConnectionsMaxIdleMs(connectionsMaxIdleMs);

    void IKafkaClientConfigurationBuilder.WithReconnectBackoffMs(int? reconnectBackoffMs) => WithReconnectBackoffMs(reconnectBackoffMs);

    void IKafkaClientConfigurationBuilder.WithReconnectBackoffMaxMs(int? reconnectBackoffMaxMs) => WithReconnectBackoffMaxMs(reconnectBackoffMaxMs);

    void IKafkaClientConfigurationBuilder.WithStatisticsIntervalMs(int? statisticsIntervalMs) => WithStatisticsIntervalMs(statisticsIntervalMs);

    void IKafkaClientConfigurationBuilder.WithApiVersionRequest(bool? apiVersionRequest) => WithApiVersionRequest(apiVersionRequest);

    void IKafkaClientConfigurationBuilder.WithApiVersionRequestTimeoutMs(int? apiVersionRequestTimeoutMs) => WithApiVersionRequestTimeoutMs(apiVersionRequestTimeoutMs);

    void IKafkaClientConfigurationBuilder.WithApiVersionFallbackMs(int? apiVersionFallbackMs) => WithApiVersionFallbackMs(apiVersionFallbackMs);

    void IKafkaClientConfigurationBuilder.WithBrokerVersionFallback(string? brokerVersionFallback) => WithBrokerVersionFallback(brokerVersionFallback);

    void IKafkaClientConfigurationBuilder.WithAllowAutoCreateTopics(bool? allowAutoCreateTopics) => WithAllowAutoCreateTopics(allowAutoCreateTopics);

    void IKafkaClientConfigurationBuilder.WithSecurityProtocol(SecurityProtocol? securityProtocol) => WithSecurityProtocol(securityProtocol);

    void IKafkaClientConfigurationBuilder.WithSslCipherSuites(string? sslCipherSuites) => WithSslCipherSuites(sslCipherSuites);

    void IKafkaClientConfigurationBuilder.WithSslCurvesList(string? sslCurvesList) => WithSslCurvesList(sslCurvesList);

    void IKafkaClientConfigurationBuilder.WithSslSigalgsList(string? sslSigalgsList) => WithSslSigalgsList(sslSigalgsList);

    void IKafkaClientConfigurationBuilder.WithSslKeyLocation(string? sslKeyLocation) => WithSslKeyLocation(sslKeyLocation);

    void IKafkaClientConfigurationBuilder.WithSslKeyPassword(string? sslKeyPassword) => WithSslKeyPassword(sslKeyPassword);

    void IKafkaClientConfigurationBuilder.WithSslKeyPem(string? sslKeyPem) => WithSslKeyPem(sslKeyPem);

    void IKafkaClientConfigurationBuilder.WithSslCertificateLocation(string? sslCertificateLocation) => WithSslCertificateLocation(sslCertificateLocation);

    void IKafkaClientConfigurationBuilder.WithSslCertificatePem(string? sslCertificatePem) => WithSslCertificatePem(sslCertificatePem);

    void IKafkaClientConfigurationBuilder.WithSslCaLocation(string? sslCaLocation) => WithSslCaLocation(sslCaLocation);

    void IKafkaClientConfigurationBuilder.WithSslCaPem(string? sslCaPem) => WithSslCaPem(sslCaPem);

    void IKafkaClientConfigurationBuilder.WithSslCaCertificateStores(string? sslCaCertificateStores) => WithSslCaCertificateStores(sslCaCertificateStores);

    void IKafkaClientConfigurationBuilder.WithSslCrlLocation(string? sslCrlLocation) => WithSslCrlLocation(sslCrlLocation);

    void IKafkaClientConfigurationBuilder.WithSslKeystoreLocation(string? sslKeystoreLocation) => WithSslKeystoreLocation(sslKeystoreLocation);

    void IKafkaClientConfigurationBuilder.WithSslKeystorePassword(string? sslKeystorePassword) => WithSslKeystorePassword(sslKeystorePassword);

    void IKafkaClientConfigurationBuilder.WithSslProviders(string? sslProviders) => WithSslProviders(sslProviders);

    void IKafkaClientConfigurationBuilder.WithSslEngineLocation(string? sslEngineLocation) => WithSslEngineLocation(sslEngineLocation);

    void IKafkaClientConfigurationBuilder.WithSslEngineId(string? sslEngineId) => WithSslEngineId(sslEngineId);

    void IKafkaClientConfigurationBuilder.WithEnableSslCertificateVerification(bool? enableSslCertificateVerification) => WithEnableSslCertificateVerification(enableSslCertificateVerification);

    void IKafkaClientConfigurationBuilder.WithSslEndpointIdentificationAlgorithm(SslEndpointIdentificationAlgorithm? sslEndpointIdentificationAlgorithm) => WithSslEndpointIdentificationAlgorithm(sslEndpointIdentificationAlgorithm);

    void IKafkaClientConfigurationBuilder.WithSaslKerberosServiceName(string? saslKerberosServiceName) => WithSaslKerberosServiceName(saslKerberosServiceName);

    void IKafkaClientConfigurationBuilder.WithSaslKerberosPrincipal(string? saslKerberosPrincipal) => WithSaslKerberosPrincipal(saslKerberosPrincipal);

    void IKafkaClientConfigurationBuilder.WithSaslKerberosKinitCmd(string? saslKerberosKinitCmd) => WithSaslKerberosKinitCmd(saslKerberosKinitCmd);

    void IKafkaClientConfigurationBuilder.WithSaslKerberosKeytab(string? saslKerberosKeytab) => WithSaslKerberosKeytab(saslKerberosKeytab);

    void IKafkaClientConfigurationBuilder.WithSaslKerberosMinTimeBeforeRelogin(int? saslKerberosMinTimeBeforeRelogin) => WithSaslKerberosMinTimeBeforeRelogin(saslKerberosMinTimeBeforeRelogin);

    void IKafkaClientConfigurationBuilder.WithSaslUsername(string? saslUsername) => WithSaslUsername(saslUsername);

    void IKafkaClientConfigurationBuilder.WithSaslPassword(string? saslPassword) => WithSaslPassword(saslPassword);

    void IKafkaClientConfigurationBuilder.WithSaslOauthbearerConfig(string? saslOauthbearerConfig) => WithSaslOauthbearerConfig(saslOauthbearerConfig);

    void IKafkaClientConfigurationBuilder.WithEnableSaslOauthbearerUnsecureJwt(bool? enableSaslOauthbearerUnsecureJwt) => WithEnableSaslOauthbearerUnsecureJwt(enableSaslOauthbearerUnsecureJwt);

    void IKafkaClientConfigurationBuilder.WithSaslOauthbearerMethod(SaslOauthbearerMethod? saslOauthbearerMethod) => WithSaslOauthbearerMethod(saslOauthbearerMethod);

    void IKafkaClientConfigurationBuilder.WithSaslOauthbearerClientId(string? saslOauthbearerClientId) => WithSaslOauthbearerClientId(saslOauthbearerClientId);

    void IKafkaClientConfigurationBuilder.WithSaslOauthbearerClientSecret(string? saslOauthbearerClientSecret) => WithSaslOauthbearerClientSecret(saslOauthbearerClientSecret);

    void IKafkaClientConfigurationBuilder.WithSaslOauthbearerScope(string? saslOauthbearerScope) => WithSaslOauthbearerScope(saslOauthbearerScope);

    void IKafkaClientConfigurationBuilder.WithSaslOauthbearerExtensions(string? saslOauthbearerExtensions) => WithSaslOauthbearerExtensions(saslOauthbearerExtensions);

    void IKafkaClientConfigurationBuilder.WithSaslOauthbearerTokenEndpointUrl(string? saslOauthbearerTokenEndpointUrl) => WithSaslOauthbearerTokenEndpointUrl(saslOauthbearerTokenEndpointUrl);

    void IKafkaClientConfigurationBuilder.WithPluginLibraryPaths(string? pluginLibraryPaths) => WithPluginLibraryPaths(pluginLibraryPaths);

    void IKafkaClientConfigurationBuilder.WithClientRack(string? clientRack) => WithClientRack(clientRack);

    void IKafkaClientConfigurationBuilder.WithRetryBackoffMs(int? retryBackoffMs) => WithRetryBackoffMs(retryBackoffMs);

    void IKafkaClientConfigurationBuilder.WithRetryBackoffMaxMs(int? retryBackoffMaxMs) => WithRetryBackoffMaxMs(retryBackoffMaxMs);

    void IKafkaClientConfigurationBuilder.WithClientDnsLookup(ClientDnsLookup? clientDnsLookup) => WithClientDnsLookup(clientDnsLookup);

    void IKafkaClientConfigurationBuilder.WithEnableMetricsPush(bool? enableMetricsPush) => WithEnableMetricsPush(enableMetricsPush);

    void IKafkaClientConfigurationBuilder.WithCancellationDelayMaxMs(int cancellationDelayMaxMs) => WithCancellationDelayMaxMs(cancellationDelayMaxMs);
}

/// <content>
///     The autogenerated part of the <see cref="KafkaConsumerConfigurationBuilder" /> class.
/// </content>
[SuppressMessage("StyleCop.CSharp.MaintainabilityRules", "SA1402:File may only contain a single type", Justification = "Autogenerated all at once")]
[SuppressMessage("StyleCop.CSharp.OrderingRules", "SA1202: 'public' members should come before 'internal' members", Justification = "Autogenerated")]
[SuppressMessage("StyleCop.CSharp.DocumentationRules", "SA1600:Elements should be documented", Justification = "Documented in other partial")]
[SuppressMessage("StyleCop.CSharp.DocumentationRules", "SA1601:Partial elements should be documented", Justification = "Autogenerated")]
public partial class KafkaConsumerConfigurationBuilder
{
    private string? _consumeResultFields;

    private AutoOffsetReset? _autoOffsetReset;

    private string? _groupId;

    private string? _groupInstanceId;

    private PartitionAssignmentStrategy? _partitionAssignmentStrategy;

    private int? _sessionTimeoutMs;

    private int? _heartbeatIntervalMs;

    private string? _groupProtocolType;

    private GroupProtocol? _groupProtocol;

    private string? _groupRemoteAssignor;

    private int? _coordinatorQueryIntervalMs;

    private int? _maxPollIntervalMs;

    private int? _autoCommitIntervalMs;

    private int? _queuedMinMessages;

    private int? _queuedMaxMessagesKbytes;

    private int? _fetchWaitMaxMs;

    private int? _fetchQueueBackoffMs;

    private int? _maxPartitionFetchBytes;

    private int? _fetchMaxBytes;

    private int? _fetchMinBytes;

    private int? _fetchErrorBackoffMs;

    private IsolationLevel? _isolationLevel;

    private bool? _enablePartitionEof;

    private bool? _checkCrcs;

    public partial KafkaConsumerConfigurationBuilder WithConsumeResultFields(string? consumeResultFields)
    {
        _consumeResultFields = consumeResultFields;
        return this;
    }

    public partial KafkaConsumerConfigurationBuilder WithAutoOffsetReset(AutoOffsetReset? autoOffsetReset)
    {
        _autoOffsetReset = autoOffsetReset;
        return this;
    }

    public partial KafkaConsumerConfigurationBuilder WithGroupId(string? groupId)
    {
        _groupId = groupId;
        return this;
    }

    public partial KafkaConsumerConfigurationBuilder WithGroupInstanceId(string? groupInstanceId)
    {
        _groupInstanceId = groupInstanceId;
        return this;
    }

    public partial KafkaConsumerConfigurationBuilder WithPartitionAssignmentStrategy(PartitionAssignmentStrategy? partitionAssignmentStrategy)
    {
        _partitionAssignmentStrategy = partitionAssignmentStrategy;
        return this;
    }

    public partial KafkaConsumerConfigurationBuilder WithSessionTimeoutMs(int? sessionTimeoutMs)
    {
        _sessionTimeoutMs = sessionTimeoutMs;
        return this;
    }

    public partial KafkaConsumerConfigurationBuilder WithHeartbeatIntervalMs(int? heartbeatIntervalMs)
    {
        _heartbeatIntervalMs = heartbeatIntervalMs;
        return this;
    }

    public partial KafkaConsumerConfigurationBuilder WithGroupProtocolType(string? groupProtocolType)
    {
        _groupProtocolType = groupProtocolType;
        return this;
    }

    public partial KafkaConsumerConfigurationBuilder WithGroupProtocol(GroupProtocol? groupProtocol)
    {
        _groupProtocol = groupProtocol;
        return this;
    }

    public partial KafkaConsumerConfigurationBuilder WithGroupRemoteAssignor(string? groupRemoteAssignor)
    {
        _groupRemoteAssignor = groupRemoteAssignor;
        return this;
    }

    public partial KafkaConsumerConfigurationBuilder WithCoordinatorQueryIntervalMs(int? coordinatorQueryIntervalMs)
    {
        _coordinatorQueryIntervalMs = coordinatorQueryIntervalMs;
        return this;
    }

    public partial KafkaConsumerConfigurationBuilder WithMaxPollIntervalMs(int? maxPollIntervalMs)
    {
        _maxPollIntervalMs = maxPollIntervalMs;
        return this;
    }

    public partial KafkaConsumerConfigurationBuilder WithAutoCommitIntervalMs(int? autoCommitIntervalMs)
    {
        _autoCommitIntervalMs = autoCommitIntervalMs;
        return this;
    }

    public partial KafkaConsumerConfigurationBuilder WithQueuedMinMessages(int? queuedMinMessages)
    {
        _queuedMinMessages = queuedMinMessages;
        return this;
    }

    public partial KafkaConsumerConfigurationBuilder WithQueuedMaxMessagesKbytes(int? queuedMaxMessagesKbytes)
    {
        _queuedMaxMessagesKbytes = queuedMaxMessagesKbytes;
        return this;
    }

    public partial KafkaConsumerConfigurationBuilder WithFetchWaitMaxMs(int? fetchWaitMaxMs)
    {
        _fetchWaitMaxMs = fetchWaitMaxMs;
        return this;
    }

    public partial KafkaConsumerConfigurationBuilder WithFetchQueueBackoffMs(int? fetchQueueBackoffMs)
    {
        _fetchQueueBackoffMs = fetchQueueBackoffMs;
        return this;
    }

    public partial KafkaConsumerConfigurationBuilder WithMaxPartitionFetchBytes(int? maxPartitionFetchBytes)
    {
        _maxPartitionFetchBytes = maxPartitionFetchBytes;
        return this;
    }

    public partial KafkaConsumerConfigurationBuilder WithFetchMaxBytes(int? fetchMaxBytes)
    {
        _fetchMaxBytes = fetchMaxBytes;
        return this;
    }

    public partial KafkaConsumerConfigurationBuilder WithFetchMinBytes(int? fetchMinBytes)
    {
        _fetchMinBytes = fetchMinBytes;
        return this;
    }

    public partial KafkaConsumerConfigurationBuilder WithFetchErrorBackoffMs(int? fetchErrorBackoffMs)
    {
        _fetchErrorBackoffMs = fetchErrorBackoffMs;
        return this;
    }

    public partial KafkaConsumerConfigurationBuilder WithIsolationLevel(IsolationLevel? isolationLevel)
    {
        _isolationLevel = isolationLevel;
        return this;
    }

    internal KafkaConsumerConfigurationBuilder WithEnablePartitionEof(bool? enablePartitionEof)
    {
        _enablePartitionEof = enablePartitionEof;
        return this;
    }

    internal KafkaConsumerConfigurationBuilder WithCheckCrcs(bool? checkCrcs)
    {
        _checkCrcs = checkCrcs;
        return this;
    }

    /// <summary>
    ///     Builds the configuration.
    /// </summary>
    /// <returns>
    ///     The configuration.
    /// </returns>
    protected override KafkaConsumerConfiguration BuildCore() =>
        base.BuildCore() with
        {
            ConsumeResultFields = _consumeResultFields,
            AutoOffsetReset = _autoOffsetReset,
            GroupId = _groupId,
            GroupInstanceId = _groupInstanceId,
            PartitionAssignmentStrategy = _partitionAssignmentStrategy,
            SessionTimeoutMs = _sessionTimeoutMs,
            HeartbeatIntervalMs = _heartbeatIntervalMs,
            GroupProtocolType = _groupProtocolType,
            GroupProtocol = _groupProtocol,
            GroupRemoteAssignor = _groupRemoteAssignor,
            CoordinatorQueryIntervalMs = _coordinatorQueryIntervalMs,
            MaxPollIntervalMs = _maxPollIntervalMs,
            AutoCommitIntervalMs = _autoCommitIntervalMs,
            QueuedMinMessages = _queuedMinMessages,
            QueuedMaxMessagesKbytes = _queuedMaxMessagesKbytes,
            FetchWaitMaxMs = _fetchWaitMaxMs,
            FetchQueueBackoffMs = _fetchQueueBackoffMs,
            MaxPartitionFetchBytes = _maxPartitionFetchBytes,
            FetchMaxBytes = _fetchMaxBytes,
            FetchMinBytes = _fetchMinBytes,
            FetchErrorBackoffMs = _fetchErrorBackoffMs,
            IsolationLevel = _isolationLevel,
            EnablePartitionEof = _enablePartitionEof,
            CheckCrcs = _checkCrcs
        };
}

/// <content>
///     The autogenerated part of the <see cref="KafkaProducerConfigurationBuilder" /> class.
/// </content>
[SuppressMessage("StyleCop.CSharp.MaintainabilityRules", "SA1402:File may only contain a single type", Justification = "Autogenerated all at once")]
[SuppressMessage("StyleCop.CSharp.OrderingRules", "SA1202: 'public' members should come before 'internal' members", Justification = "Autogenerated")]
[SuppressMessage("StyleCop.CSharp.DocumentationRules", "SA1600:Elements should be documented", Justification = "Documented in other partial")]
[SuppressMessage("StyleCop.CSharp.DocumentationRules", "SA1601:Partial elements should be documented", Justification = "Autogenerated")]
public partial class KafkaProducerConfigurationBuilder
{
    private bool? _enableDeliveryReports;

    private int? _requestTimeoutMs;

    private int? _messageTimeoutMs;

    private Partitioner? _partitioner;

    private int? _compressionLevel;

    private string? _transactionalId;

    private int? _transactionTimeoutMs;

    private bool? _enableIdempotence;

    private bool? _enableGaplessGuarantee;

    private int? _queueBufferingMaxMessages;

    private int? _queueBufferingMaxKbytes;

    private double? _lingerMs;

    private int? _messageSendMaxRetries;

    private int? _queueBufferingBackpressureThreshold;

    private CompressionType? _compressionType;

    private int? _batchNumMessages;

    private int? _batchSize;

    private int? _stickyPartitioningLingerMs;

    public partial KafkaProducerConfigurationBuilder WithRequestTimeoutMs(int? requestTimeoutMs)
    {
        _requestTimeoutMs = requestTimeoutMs;
        return this;
    }

    public partial KafkaProducerConfigurationBuilder WithMessageTimeoutMs(int? messageTimeoutMs)
    {
        _messageTimeoutMs = messageTimeoutMs;
        return this;
    }

    public partial KafkaProducerConfigurationBuilder WithPartitioner(Partitioner? partitioner)
    {
        _partitioner = partitioner;
        return this;
    }

    public partial KafkaProducerConfigurationBuilder WithCompressionLevel(int? compressionLevel)
    {
        _compressionLevel = compressionLevel;
        return this;
    }

    public partial KafkaProducerConfigurationBuilder WithTransactionTimeoutMs(int? transactionTimeoutMs)
    {
        _transactionTimeoutMs = transactionTimeoutMs;
        return this;
    }

    public partial KafkaProducerConfigurationBuilder WithQueueBufferingMaxMessages(int? queueBufferingMaxMessages)
    {
        _queueBufferingMaxMessages = queueBufferingMaxMessages;
        return this;
    }

    public partial KafkaProducerConfigurationBuilder WithQueueBufferingMaxKbytes(int? queueBufferingMaxKbytes)
    {
        _queueBufferingMaxKbytes = queueBufferingMaxKbytes;
        return this;
    }

    public partial KafkaProducerConfigurationBuilder WithLingerMs(double? lingerMs)
    {
        _lingerMs = lingerMs;
        return this;
    }

    public partial KafkaProducerConfigurationBuilder WithMessageSendMaxRetries(int? messageSendMaxRetries)
    {
        _messageSendMaxRetries = messageSendMaxRetries;
        return this;
    }

    public partial KafkaProducerConfigurationBuilder WithQueueBufferingBackpressureThreshold(int? queueBufferingBackpressureThreshold)
    {
        _queueBufferingBackpressureThreshold = queueBufferingBackpressureThreshold;
        return this;
    }

    public partial KafkaProducerConfigurationBuilder WithCompressionType(CompressionType? compressionType)
    {
        _compressionType = compressionType;
        return this;
    }

    public partial KafkaProducerConfigurationBuilder WithBatchNumMessages(int? batchNumMessages)
    {
        _batchNumMessages = batchNumMessages;
        return this;
    }

    public partial KafkaProducerConfigurationBuilder WithBatchSize(int? batchSize)
    {
        _batchSize = batchSize;
        return this;
    }

    public partial KafkaProducerConfigurationBuilder WithStickyPartitioningLingerMs(int? stickyPartitioningLingerMs)
    {
        _stickyPartitioningLingerMs = stickyPartitioningLingerMs;
        return this;
    }

    internal KafkaProducerConfigurationBuilder WithEnableDeliveryReports(bool? enableDeliveryReports)
    {
        _enableDeliveryReports = enableDeliveryReports;
        return this;
    }

    internal KafkaProducerConfigurationBuilder WithTransactionalId(string? transactionalId)
    {
        _transactionalId = transactionalId;
        return this;
    }

    internal KafkaProducerConfigurationBuilder WithEnableIdempotence(bool? enableIdempotence)
    {
        _enableIdempotence = enableIdempotence;
        return this;
    }

    internal KafkaProducerConfigurationBuilder WithEnableGaplessGuarantee(bool? enableGaplessGuarantee)
    {
        _enableGaplessGuarantee = enableGaplessGuarantee;
        return this;
    }

    /// <summary>
    ///     Builds the configuration.
    /// </summary>
    /// <returns>
    ///     The configuration.
    /// </returns>
    protected override KafkaProducerConfiguration BuildCore() =>
        base.BuildCore() with
        {
            EnableDeliveryReports = _enableDeliveryReports,
            RequestTimeoutMs = _requestTimeoutMs,
            MessageTimeoutMs = _messageTimeoutMs,
            Partitioner = _partitioner,
            CompressionLevel = _compressionLevel,
            TransactionalId = _transactionalId,
            TransactionTimeoutMs = _transactionTimeoutMs,
            EnableIdempotence = _enableIdempotence,
            EnableGaplessGuarantee = _enableGaplessGuarantee,
            QueueBufferingMaxMessages = _queueBufferingMaxMessages,
            QueueBufferingMaxKbytes = _queueBufferingMaxKbytes,
            LingerMs = _lingerMs,
            MessageSendMaxRetries = _messageSendMaxRetries,
            QueueBufferingBackpressureThreshold = _queueBufferingBackpressureThreshold,
            CompressionType = _compressionType,
            BatchNumMessages = _batchNumMessages,
            BatchSize = _batchSize,
            StickyPartitioningLingerMs = _stickyPartitioningLingerMs
        };
}
