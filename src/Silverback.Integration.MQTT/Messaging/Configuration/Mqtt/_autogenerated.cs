// Copyright (c) 2024 Sergio Aquilini
// This code is licensed under MIT license (see LICENSE file for details)

using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Net;
using System.Net.Sockets;
using System.Net.WebSockets;
using System.Security.Authentication;
using System.Security.Cryptography.X509Certificates;
using MQTTnet.Client;

namespace Silverback.Messaging.Configuration.Mqtt;

/// <content>
///     The autogenerated part of the <see cref="MqttClientConfiguration" /> class.
/// </content>
[SuppressMessage("StyleCop.CSharp.MaintainabilityRules", "SA1402:File may only contain a single type", Justification = "Autogenerated all at once")]
[SuppressMessage("Performance", "CA1819:Properties should not return arrays", Justification = "Generated according to wrapped class")]
public partial record MqttClientConfiguration
{
    private static readonly MqttClientOptions DefaultInstance = new();

    /// <summary>
    ///     Gets a value indicating whether the broker allows packet fragmentation.
    ///     Unfortunately not all brokers (like AWS) do support fragmentation and will close the connection when receiving such packets.
    ///     If such a service is used this flag must be set to <c>false</c>.
    ///     The default is <c>true</c>.
    /// </summary>
    public bool AllowPacketFragmentation { get; init; } = DefaultInstance.AllowPacketFragmentation;

    /// <summary>
    ///     Gets the authentication data to be used for the custom authentication.
    /// </summary>
    public byte[]? AuthenticationData { get; init; }

    /// <summary>
    ///     Gets the custom authentication method.
    /// </summary>
    public string? AuthenticationMethod { get; init; }

    /// <summary>
    ///     Gets a value indicating whether a clean non-persistent session has to be created for this client. The default is <c>true</c>.
    /// </summary>
    public bool CleanSession { get; init; } = DefaultInstance.CleanSession;

    /// <summary>
    ///     Gets the credentials to be used to authenticate with the message broker.
    /// </summary>
    public IMqttClientCredentialsProvider? Credentials { get; init; }

    /// <summary>
    ///     Gets the handler to be used to handle the custom authentication data exchange.
    /// </summary>
    public IMqttExtendedAuthenticationExchangeHandler? ExtendedAuthenticationExchangeHandler { get; init; }

    /// <summary>
    ///     Gets the communication timeout. The default is 10 seconds.
    /// </summary>
    public TimeSpan KeepAlivePeriod { get; init; } = DefaultInstance.KeepAlivePeriod;

    /// <summary>
    ///     Gets the maximum packet size in byte the client will process. The default is no limit.
    /// </summary>
    public uint MaximumPacketSize { get; init; } = DefaultInstance.MaximumPacketSize;

    /// <summary>
    ///     Gets the maximum number of QoS 1 and QoS 2 publications that can be received and processed concurrently. The default value is
    ///     <c>null</c>, which means <c>65'535</c>.
    /// </summary>
    public ushort ReceiveMaximum { get; init; } = DefaultInstance.ReceiveMaximum;

    /// <summary>
    ///     Gets a value indicating whether the reason string or user properties can be sent with any packet. The default is usually
    ///     <c>true</c>.
    /// </summary>
    public bool RequestProblemInformation { get; init; } = DefaultInstance.RequestProblemInformation;

    /// <summary>
    ///     Gets a value indicating whether the server should return the response information in the <i>CONNACK</i> packet. The default is
    ///     usually <c>false</c>.
    /// </summary>
    public bool RequestResponseInformation { get; init; } = DefaultInstance.RequestResponseInformation;

    /// <summary>
    ///     Gets the session expiry interval in seconds. When set to 0 the session will expire when the connection is closed, while
    ///     <see cref="uint.MaxValue" /> indicates that the session will never expire. The default is 0.
    /// </summary>
    public uint SessionExpiryInterval { get; init; } = DefaultInstance.SessionExpiryInterval;

    /// <summary>
    ///     Gets a value indicating whether an exception should be thrown when the server replies with a non success ACK packet.
    ///     The default is <c>true</c>.
    /// </summary>
    public bool ThrowOnNonSuccessfulConnectResponse { get; init; } = DefaultInstance.ThrowOnNonSuccessfulConnectResponse;

    /// <summary>
    ///     Gets the timeout which will be applied at socket level and internal operations.
    ///     The default value is the same as for sockets in .NET in general.
    /// </summary>
    public TimeSpan Timeout { get; init; } = DefaultInstance.Timeout;

    /// <summary>
    ///     Gets the maximum number of topic aliases the server can send in the <i>PUBLISH</i> packet. The default is 0, meaning that no
    ///     alias can be sent.
    /// </summary>
    public ushort TopicAliasMaximum { get; init; } = DefaultInstance.TopicAliasMaximum;

    /// <summary>
    ///     Gets a value indicating whether the bridge must attempt to indicate to the remote broker that it is a bridge and not an ordinary
    ///     client. If successful, this means that the loop detection will be more effective and that the retained messages will be propagated
    ///     correctly. Not all brokers support this feature, so it may be necessary to set it to <c>false</c> if your bridge does not connect
    ///     properly.
    /// </summary>
    public bool TryPrivate { get; init; } = DefaultInstance.TryPrivate;

    /// <summary>
    ///     Gets a value indicating whether the client should check if the configuration is valid for the selected protocol version.
    ///     The default is <c>true</c>.
    /// </summary>
    public bool ValidateFeatures { get; init; } = DefaultInstance.ValidateFeatures;

    /// <summary>
    ///     Gets the default and initial size of the packet write buffer. It is recommended to set this to a value close to the usual expected
    ///     packet size * 1.5. Do not change this value when no memory issues are experienced.
    /// </summary>
    public int WriterBufferSize { get; init; } = DefaultInstance.WriterBufferSize;

    /// <summary>
    ///     Gets the maximum size of the buffer writer. The writer will reduce its internal buffer to this value after serializing a
    ///     packet. Do not change this value when no memory issues are experienced.
    /// </summary>
    public int WriterBufferSizeMax { get; init; } = DefaultInstance.WriterBufferSizeMax;

    private MqttClientOptions MapCore() =>
        new()
        {
            AllowPacketFragmentation = AllowPacketFragmentation,
            AuthenticationData = AuthenticationData,
            AuthenticationMethod = AuthenticationMethod,
            CleanSession = CleanSession,
            Credentials = Credentials,
            ExtendedAuthenticationExchangeHandler = ExtendedAuthenticationExchangeHandler,
            KeepAlivePeriod = KeepAlivePeriod,
            MaximumPacketSize = MaximumPacketSize,
            ReceiveMaximum = ReceiveMaximum,
            RequestProblemInformation = RequestProblemInformation,
            RequestResponseInformation = RequestResponseInformation,
            SessionExpiryInterval = SessionExpiryInterval,
            ThrowOnNonSuccessfulConnectResponse = ThrowOnNonSuccessfulConnectResponse,
            Timeout = Timeout,
            TopicAliasMaximum = TopicAliasMaximum,
            TryPrivate = TryPrivate,
            ValidateFeatures = ValidateFeatures,
            WriterBufferSize = WriterBufferSize,
            WriterBufferSizeMax = WriterBufferSizeMax
        };
}

/// <content>
///     The autogenerated part of the <see cref="MqttClientConfiguration" /> class.
/// </content>
[SuppressMessage("StyleCop.CSharp.MaintainabilityRules", "SA1402:File may only contain a single type", Justification = "Autogenerated all at once")]
[SuppressMessage("Performance", "CA1819:Properties should not return arrays", Justification = "Generated according to wrapped class")]
public partial record MqttClientTcpConfiguration
{
    private static readonly MqttClientTcpOptions DefaultInstance = new();

    /// <summary>
    ///     Gets the address family of the underlying <see cref="Socket" />.
    /// </summary>
    public AddressFamily AddressFamily { get; init; } = DefaultInstance.AddressFamily;

    /// <summary>
    ///     Gets the size of both the receive and send buffers of the underlying <see cref="Socket" />.
    /// </summary>
    public int BufferSize { get; init; } = DefaultInstance.BufferSize;

    /// <summary>
    ///     Gets a value that specifies whether the underlying <see cref="Socket" /> is a dual-mode socket used for both IPv4 and IPv6.
    /// </summary>
    public bool? DualMode { get; init; }

    /// <summary>
    ///     Gets the <see cref="System.Net.Sockets.LingerOption" />.
    /// </summary>
    public LingerOption? LingerState { get; init; } = DefaultInstance.LingerState;

    /// <summary>
    ///     Gets the local endpoint (network card) which is used by the client. If <c>null</c> the OS will select the network card.
    /// </summary>
    public EndPoint? LocalEndpoint { get; init; }

    /// <summary>
    ///     Gets a value indicating whether the underlying <see cref="Socket" /> is a dual-mode socket used for both IPv4 and IPv6.
    /// </summary>
    public bool NoDelay { get; init; } = DefaultInstance.NoDelay;

    /// <summary>
    ///     Gets the protocol type, usually TCP but when using other endpoint types like unix sockets it must be changed (IP for unix sockets).
    ///     The default is <see cref="ProtocolType.Tcp" />.
    /// </summary>
    public ProtocolType ProtocolType { get; init; } = DefaultInstance.ProtocolType;

    /// <summary>
    ///     Gets the remote endpoint (server).
    /// </summary>
    public EndPoint? RemoteEndpoint { get; init; }

    private MqttClientTcpOptions MapCore() =>
        new()
        {
            AddressFamily = AddressFamily,
            BufferSize = BufferSize,
            DualMode = DualMode,
            LingerState = LingerState,
            LocalEndpoint = LocalEndpoint,
            NoDelay = NoDelay,
            ProtocolType = ProtocolType,
            RemoteEndpoint = RemoteEndpoint
        };
}

/// <content>
///     The autogenerated part of the <see cref="MqttClientConfiguration" /> class.
/// </content>
[SuppressMessage("StyleCop.CSharp.MaintainabilityRules", "SA1402:File may only contain a single type", Justification = "Autogenerated all at once")]
[SuppressMessage("Performance", "CA1819:Properties should not return arrays", Justification = "Generated according to wrapped class")]
public partial record MqttClientWebSocketConfiguration
{
    private static readonly MqttClientWebSocketOptions DefaultInstance = new();

    /// <summary>
    ///     Gets the cookies associated with the request.
    /// </summary>
    public CookieContainer? CookieContainer { get; init; }

    /// <summary>
    ///     Gets the credentials to be used.
    /// </summary>
    public ICredentials? Credentials { get; init; }

    /// <summary>
    ///     Gets the request headers.
    /// </summary>
    public IDictionary<string, string>? RequestHeaders { get; init; }

    /// <summary>
    ///     Gets the sub-protocols to be negotiated during the WebSocket connection handshake.
    /// </summary>
    public ICollection<string>? SubProtocols { get; init; } = DefaultInstance.SubProtocols;

    /// <summary>
    ///     Gets the server URI.
    /// </summary>
    [SuppressMessage("Design", "CA1056:URI-like properties should not be strings", Justification = "Generated according to wrapped class.")]
    public string? Uri { get; init; }

    /// <summary>
    ///     Gets the keep alive interval for the web socket connection. This is not related to the keep alive interval for the MQTT protocol.
    ///     The default is <see cref="WebSocket.DefaultKeepAliveInterval" />.
    /// </summary>
    public TimeSpan KeepAliveInterval { get; init; } = DefaultInstance.KeepAliveInterval;

    /// <summary>
    ///     Gets a value indicating whether the default (system) credentials should be used. The default is <c>false</c>.
    /// </summary>
    public bool UseDefaultCredentials { get; init; } = DefaultInstance.UseDefaultCredentials;

    private MqttClientWebSocketOptions MapCore() =>
        new()
        {
            CookieContainer = CookieContainer,
            Credentials = Credentials,
            RequestHeaders = RequestHeaders,
            SubProtocols = SubProtocols,
            Uri = Uri,
            KeepAliveInterval = KeepAliveInterval,
            UseDefaultCredentials = UseDefaultCredentials
        };
}

/// <content>
///     The autogenerated part of the <see cref="MqttClientConfiguration" /> class.
/// </content>
[SuppressMessage("StyleCop.CSharp.MaintainabilityRules", "SA1402:File may only contain a single type", Justification = "Autogenerated all at once")]
[SuppressMessage("Performance", "CA1819:Properties should not return arrays", Justification = "Generated according to wrapped class")]
public partial record MqttClientTlsConfiguration
{
    private static readonly MqttClientTlsOptions DefaultInstance = new();

    /// <summary>
    ///     Gets the function to be used to validate the remote certificate.
    /// </summary>
    public Func<MqttClientCertificateValidationEventArgs, bool>? CertificateValidationHandler { get; init; }

    /// <summary>
    ///     Gets the function to be used to select the client certificate.
    /// </summary>
    public Func<MqttClientCertificateSelectionEventArgs, X509Certificate>? CertificateSelectionHandler { get; init; }

    /// <summary>
    ///     Gets a value indicating whether the client should use TLS.
    /// </summary>
    public bool UseTls { get; init; } = DefaultInstance.UseTls;

    /// <summary>
    ///     Gets a value indicating whether the client should ignore the certificate revocation errors.
    /// </summary>
    public bool IgnoreCertificateRevocationErrors { get; init; } = DefaultInstance.IgnoreCertificateRevocationErrors;

    /// <summary>
    ///     Gets a value indicating whether the client should ignore the certificate chain errors.
    /// </summary>
    public bool IgnoreCertificateChainErrors { get; init; } = DefaultInstance.IgnoreCertificateChainErrors;

    /// <summary>
    ///     Gets a value indicating whether the client should accept untrusted certificates.
    /// </summary>
    public bool AllowUntrustedCertificates { get; init; } = DefaultInstance.AllowUntrustedCertificates;

    /// <summary>
    ///     Gets the <see cref="System.Security.Cryptography.X509Certificates.X509RevocationMode" />.
    /// </summary>
    public X509RevocationMode RevocationMode { get; init; } = DefaultInstance.RevocationMode;

    /// <summary>
    ///     Gets the provider to be used to get the client certificates.
    /// </summary>
    public IMqttClientCertificatesProvider? ClientCertificatesProvider { get; init; }

    /// <summary>
    ///     Gets the target host. If the value is <c>null</c> or empty the same host as the TCP socket host will be used.
    /// </summary>
    public string? TargetHost { get; init; }

    /// <summary>
    ///     Gets the protocol to be used. The default is TLS 1.3 or TLS 1.2.
    /// </summary>
    public SslProtocols SslProtocol { get; init; } = DefaultInstance.SslProtocol;

    private MqttClientTlsOptions MapCore() =>
        new()
        {
            CertificateValidationHandler = CertificateValidationHandler,
            CertificateSelectionHandler = CertificateSelectionHandler,
            UseTls = UseTls,
            IgnoreCertificateRevocationErrors = IgnoreCertificateRevocationErrors,
            IgnoreCertificateChainErrors = IgnoreCertificateChainErrors,
            AllowUntrustedCertificates = AllowUntrustedCertificates,
            RevocationMode = RevocationMode,
            ClientCertificatesProvider = ClientCertificatesProvider,
            TargetHost = TargetHost,
            SslProtocol = SslProtocol
        };
}

/// <content>
///     The autogenerated part of the <see cref="MqttClientConfiguration" /> class.
/// </content>
[SuppressMessage("StyleCop.CSharp.MaintainabilityRules", "SA1402:File may only contain a single type", Justification = "Autogenerated all at once")]
[SuppressMessage("Performance", "CA1819:Properties should not return arrays", Justification = "Generated according to wrapped class")]
public partial record MqttClientWebSocketProxyConfiguration
{
    private static readonly MqttClientWebSocketProxyOptions DefaultInstance = new();

    /// <summary>
    ///     Gets the proxy address.
    /// </summary>
    public string? Address { get; init; }

    /// <summary>
    ///     Gets the username to be used to authenticate with the proxy server.
    /// </summary>
    public string? Username { get; init; }

    /// <summary>
    ///     Gets the password to be used to authenticate with the proxy server.
    /// </summary>
    public string? Password { get; init; }

    /// <summary>
    ///     Gets proxy server domain.
    /// </summary>
    public string? Domain { get; init; }

    /// <summary>
    ///     Gets a value indicating whether the proxy should be bypassed for local calls.
    /// </summary>
    public bool BypassOnLocal { get; init; } = DefaultInstance.BypassOnLocal;

    /// <summary>
    ///     Gets a value indicating whether the default (system) credentials should be used.
    /// </summary>
    public bool UseDefaultCredentials { get; init; } = DefaultInstance.UseDefaultCredentials;

    /// <summary>
    ///     Gets the bypass list.
    /// </summary>
    public string[]? BypassList { get; init; }

    private MqttClientWebSocketProxyOptions MapCore() =>
        new()
        {
            Address = Address,
            Username = Username,
            Password = Password,
            Domain = Domain,
            BypassOnLocal = BypassOnLocal,
            UseDefaultCredentials = UseDefaultCredentials,
            BypassList = BypassList
        };
}

/// <content>
///     The autogenerated part of the <see cref="MqttClientConfigurationBuilder" /> class.
/// </content>
[SuppressMessage("StyleCop.CSharp.MaintainabilityRules", "SA1402:File may only contain a single type", Justification = "Autogenerated all at once")]
[SuppressMessage("StyleCop.CSharp.DocumentationRules", "SA1600:Elements should be documented", Justification = "Documented in other partial")]
[SuppressMessage("StyleCop.CSharp.DocumentationRules", "SA1601:Partial elements should be documented", Justification = "Autogenerated")]
public partial class MqttClientConfigurationBuilder
{
    public partial MqttClientConfigurationBuilder WithAddressFamily(AddressFamily addressFamily);

    public partial MqttClientConfigurationBuilder WithAuthentication(string? method, byte[]? data);

    public partial MqttClientConfigurationBuilder WithTimeout(TimeSpan value);
}

/// <content>
///     The autogenerated part of the <see cref="MqttClientsConfigurationBuilder" /> class.
/// </content>
[SuppressMessage("StyleCop.CSharp.MaintainabilityRules", "SA1402:File may only contain a single type", Justification = "Autogenerated all at once")]
[SuppressMessage("StyleCop.CSharp.DocumentationRules", "SA1600:Elements should be documented", Justification = "Documented in other partial")]
[SuppressMessage("StyleCop.CSharp.DocumentationRules", "SA1601:Partial elements should be documented", Justification = "Autogenerated")]
public partial class MqttClientsConfigurationBuilder
{
    public partial MqttClientsConfigurationBuilder WithAddressFamily(AddressFamily addressFamily);

    public partial MqttClientsConfigurationBuilder WithAuthentication(string? method, byte[]? data);

    public partial MqttClientsConfigurationBuilder WithTimeout(TimeSpan value);
}
