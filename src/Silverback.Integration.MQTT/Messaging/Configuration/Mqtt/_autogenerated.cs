// Copyright (c) 2020 Sergio Aquilini
// This code is licensed under MIT license (see LICENSE file for details)

using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Net;
using System.Net.Sockets;
using System.Security.Authentication;
using MQTTnet.Client.ExtendedAuthenticationExchange;
using MQTTnet.Client.Options;
using MQTTnet.Diagnostics.PacketInspection;

namespace Silverback.Messaging.Configuration.Mqtt;

/// <content>
///     The autogenerated part of the <see cref="MqttClientConfiguration" /> class.
/// </content>
[SuppressMessage("", "SA1649", Justification = "Autogenerated all at once")]
[SuppressMessage("", "SA1402", Justification = "Autogenerated all at once")]
[SuppressMessage("", "CA1819", Justification = "Generated according to wrapped class")]
public partial record MqttClientConfiguration
{
    private static readonly MqttClientOptions DefaultInstance = new();

    /// <summary>
    ///     Gets a value indicating whether a clean non-persistent session has to be created for this client. The default is <c>true</c>.
    /// </summary>
    public bool CleanSession { get; init; } = DefaultInstance.CleanSession;

    /// <summary>
    ///     Gets the credentials to be used to authenticate with the message broker.
    /// </summary>
    public MqttClientCredentials? Credentials { get; init; }

    /// <summary>
    ///     Gets the handler to be used to handle the custom authentication data exchange.
    /// </summary>
    public IMqttExtendedAuthenticationExchangeHandler? ExtendedAuthenticationExchangeHandler { get; init; }

    /// <summary>
    ///     Gets the maximum period that can elapse without a packet being sent to the message broker.
    ///     When this period is elapsed a ping packet will be sent to keep the connection alive. The default is 15 seconds.
    /// </summary>
    public TimeSpan CommunicationTimeout { get; init; } = DefaultInstance.CommunicationTimeout;

    /// <summary>
    ///     Gets the communication timeout. The default is 10 seconds.
    /// </summary>
    public TimeSpan KeepAlivePeriod { get; init; } = DefaultInstance.KeepAlivePeriod;

    /// <summary>
    ///     Gets the last will message to be sent when the client disconnects ungracefully.
    /// </summary>
    public MqttLastWillMessageConfiguration? WillMessage { get; init; }

    /// <summary>
    ///     Gets the number of seconds to wait before sending the last will message. If the client reconnects between this interval the
    ///     Gets the number of seconds to wait before sending the last will message. If the client message will not be sent.
    /// </summary>
    public uint? WillDelayInterval { get; init; }

    /// <summary>
    ///     Gets the custom authentication method.
    /// </summary>
    public string? AuthenticationMethod { get; init; }

    /// <summary>
    ///     Gets the authentication data to be used for the custom authentication.
    /// </summary>
    public byte[]? AuthenticationData { get; init; }

    /// <summary>
    ///     Gets the maximum packet size in byte the client will process. The default is no limit.
    /// </summary>
    public uint? MaximumPacketSize { get; init; }

    /// <summary>
    ///     Gets the maximum number of QoS 1 and QoS 2 publications that can be received and processed concurrently. The default value is
    ///     <c>null</c>, which means <c>65'535</c>.
    /// </summary>
    public ushort? ReceiveMaximum { get; init; }

    /// <summary>
    ///     Gets a value indicating whether the reason string or user properties can be sent with any packet. The default is usually
    ///     <c>true</c>.
    /// </summary>
    public bool? RequestProblemInformation { get; init; }

    /// <summary>
    ///     Gets a value indicating whether the server should return the response information in the <i>CONNACK</i> packet. The default is
    ///     usually <c>false</c>.
    /// </summary>
    public bool? RequestResponseInformation { get; init; }

    /// <summary>
    ///     Gets the session expiry interval in seconds. When set to 0 the session will expire when the connection is closed, while
    ///     <see cref="uint.MaxValue" /> indicates that the session will never expire. The default is 0.
    /// </summary>
    public uint? SessionExpiryInterval { get; init; }

    /// <summary>
    ///     Gets the maximum number of topic aliases the server can send in the <i>PUBLISH</i> packet. The default is 0, meaning that no
    ///     alias can be sent.
    /// </summary>
    public ushort? TopicAliasMaximum { get; init; }

    /// <summary>
    ///     Gets <see cref="IMqttPacketInspector" /> that will be used to inspect packets before they are sent and after they are received.
    /// </summary>
    public IMqttPacketInspector? PacketInspector { get; init; }

    private MqttClientOptions MapCore() =>
        new()
        {
            CleanSession = CleanSession,
            Credentials = Credentials?.ToMqttNetType(),
            ExtendedAuthenticationExchangeHandler = ExtendedAuthenticationExchangeHandler,
            CommunicationTimeout = CommunicationTimeout,
            KeepAlivePeriod = KeepAlivePeriod,
            WillMessage = WillMessage?.ToMqttNetType(),
            WillDelayInterval = WillDelayInterval,
            AuthenticationMethod = AuthenticationMethod,
            AuthenticationData = AuthenticationData,
            MaximumPacketSize = MaximumPacketSize,
            ReceiveMaximum = ReceiveMaximum,
            RequestProblemInformation = RequestProblemInformation,
            RequestResponseInformation = RequestResponseInformation,
            SessionExpiryInterval = SessionExpiryInterval,
            TopicAliasMaximum = TopicAliasMaximum,
            PacketInspector = PacketInspector
        };
}

/// <content>
///     The autogenerated part of the <see cref="MqttClientConfiguration" /> class.
/// </content>
[SuppressMessage("", "SA1649", Justification = "Autogenerated all at once")]
[SuppressMessage("", "SA1402", Justification = "Autogenerated all at once")]
[SuppressMessage("", "CA1819", Justification = "Generated according to wrapped class")]
public partial record MqttClientCredentials
{
    /// <summary>
    ///     Gets the username.
    /// </summary>
    public string? Username { get; init; }

    /// <summary>
    ///     Gets the password.
    /// </summary>
    public byte[]? Password { get; init; }

    private MQTTnet.Client.Options.MqttClientCredentials MapCore() =>
        new()
        {
            Username = Username,
            Password = Password
        };
}

/// <content>
///     The autogenerated part of the <see cref="MqttClientConfiguration" /> class.
/// </content>
[SuppressMessage("", "SA1649", Justification = "Autogenerated all at once")]
[SuppressMessage("", "SA1402", Justification = "Autogenerated all at once")]
[SuppressMessage("", "CA1819", Justification = "Generated according to wrapped class")]
public partial record MqttClientTcpConfiguration
{
    private static readonly MqttClientTcpOptions DefaultInstance = new();

    /// <summary>
    ///     Gets the server name or address.
    /// </summary>
    public string? Server { get; init; }

    /// <summary>
    ///     Gets the server port.
    /// </summary>
    public int? Port { get; init; }

    /// <summary>
    ///     Gets the size of both the receive and send buffers of the underlying <see cref="Socket" />.
    /// </summary>
    public int BufferSize { get; init; } = DefaultInstance.BufferSize;

    /// <summary>
    ///     Gets a value that specifies whether the underlying <see cref="Socket" /> is a dual-mode socket used for both IPv4 and IPv6.
    /// </summary>
    public bool? DualMode { get; init; }

    /// <summary>
    ///     Gets a value indicating whether the underlying <see cref="Socket" /> is a dual-mode socket used for both IPv4 and IPv6.
    /// </summary>
    public bool NoDelay { get; init; } = DefaultInstance.NoDelay;

    /// <summary>
    ///     Gets the address family of the underlying <see cref="Socket" />.
    /// </summary>
    public AddressFamily AddressFamily { get; init; } = DefaultInstance.AddressFamily;

    private MqttClientTcpOptions MapCore() =>
        new()
        {
            Server = Server,
            Port = Port,
            BufferSize = BufferSize,
            DualMode = DualMode,
            NoDelay = NoDelay,
            AddressFamily = AddressFamily
        };
}

/// <content>
///     The autogenerated part of the <see cref="MqttClientConfiguration" /> class.
/// </content>
[SuppressMessage("", "SA1649", Justification = "Autogenerated all at once")]
[SuppressMessage("", "SA1402", Justification = "Autogenerated all at once")]
[SuppressMessage("", "CA1819", Justification = "Generated according to wrapped class")]
public partial record MqttClientWebSocketConfiguration
{
    private static readonly MqttClientWebSocketOptions DefaultInstance = new();

    /// <summary>
    ///     Gets the server URI.
    /// </summary>
    [SuppressMessage("Design", "CA1056:URI-like properties should not be strings", Justification = "Generated according to wrapped class.")]
    public string? Uri { get; init; }

    /// <summary>
    ///     Gets the HTTP request headers.
    /// </summary>
    public IDictionary<string, string>? RequestHeaders { get; init; }

    /// <summary>
    ///     Gets the sub-protocols to be negotiated during the WebSocket connection handshake.
    /// </summary>
    public ICollection<string>? SubProtocols { get; init; } = DefaultInstance.SubProtocols;

    /// <summary>
    ///     Gets the cookies associated with the request.
    /// </summary>
    public CookieContainer? CookieContainer { get; init; }

    private MqttClientWebSocketOptions MapCore() =>
        new()
        {
            Uri = Uri,
            RequestHeaders = RequestHeaders,
            SubProtocols = SubProtocols,
            CookieContainer = CookieContainer
        };
}

/// <content>
///     The autogenerated part of the <see cref="MqttClientConfiguration" /> class.
/// </content>
[SuppressMessage("", "SA1649", Justification = "Autogenerated all at once")]
[SuppressMessage("", "SA1402", Justification = "Autogenerated all at once")]
[SuppressMessage("", "CA1819", Justification = "Generated according to wrapped class")]
public partial record MqttClientTlsConfiguration
{
    private static readonly MqttClientTlsOptions DefaultInstance = new();

    /// <summary>
    ///     Gets a value indicating whether the client should use TLS.
    /// </summary>
    public bool UseTls { get; init; } = DefaultInstance.UseTls;

    /// <summary>
    ///     Gets a value indicating whether the client should ignore the certificate revocation errors.
    /// </summary>
    public bool IgnoreCertificateRevocationErrors { get; init; } = DefaultInstance.IgnoreCertificateRevocationErrors;

    /// <summary>
    ///     Gets a value indicating whether the client should ignore the certificate chain errors.
    /// </summary>
    public bool IgnoreCertificateChainErrors { get; init; } = DefaultInstance.IgnoreCertificateChainErrors;

    /// <summary>
    ///     Gets a value indicating whether the client should accept untrusted certificates.
    /// </summary>
    public bool AllowUntrustedCertificates { get; init; } = DefaultInstance.AllowUntrustedCertificates;

    /// <summary>
    ///     Gets the protocol to be used. The default is TLS 1.3
    ///     (or TLS 1.2 for older .NET versions).
    /// </summary>
    public SslProtocols SslProtocol { get; init; } = DefaultInstance.SslProtocol;

    /// <summary>
    ///     Gets the function to be used to validate the remote certificate.
    /// </summary>
    public Func<MqttClientCertificateValidationCallbackContext, bool>? CertificateValidationHandler { get; init; }

    private MqttClientTlsOptions MapCore() =>
        new()
        {
            UseTls = UseTls,
            IgnoreCertificateRevocationErrors = IgnoreCertificateRevocationErrors,
            IgnoreCertificateChainErrors = IgnoreCertificateChainErrors,
            AllowUntrustedCertificates = AllowUntrustedCertificates,
            SslProtocol = SslProtocol,
            CertificateValidationHandler = CertificateValidationHandler
        };
}

/// <content>
///     The autogenerated part of the <see cref="MqttClientConfiguration" /> class.
/// </content>
[SuppressMessage("", "SA1649", Justification = "Autogenerated all at once")]
[SuppressMessage("", "SA1402", Justification = "Autogenerated all at once")]
[SuppressMessage("", "CA1819", Justification = "Generated according to wrapped class")]
public partial record MqttClientWebSocketProxyConfiguration
{
    private static readonly MqttClientWebSocketProxyOptions DefaultInstance = new();

    /// <summary>
    ///     Gets the proxy address.
    /// </summary>
    public string? Address { get; init; }

    /// <summary>
    ///     Gets the username to be used to authenticate with the proxy server.
    /// </summary>
    public string? Username { get; init; }

    /// <summary>
    ///     Gets the password to be used to authenticate with the proxy server.
    /// </summary>
    public string? Password { get; init; }

    /// <summary>
    ///     Gets proxy server domain.
    /// </summary>
    public string? Domain { get; init; }

    /// <summary>
    ///     Gets a value indicating whether the proxy should be bypassed for local calls.
    /// </summary>
    public bool BypassOnLocal { get; init; } = DefaultInstance.BypassOnLocal;

    /// <summary>
    ///     Gets the bypass list.
    /// </summary>
    public string[]? BypassList { get; init; }

    private MqttClientWebSocketProxyOptions MapCore() =>
        new()
        {
            Address = Address,
            Username = Username,
            Password = Password,
            Domain = Domain,
            BypassOnLocal = BypassOnLocal,
            BypassList = BypassList
        };
}

/// <content>
///     The autogenerated part of the <see cref="MqttClientConfigurationBuilder" /> class.
/// </content>
[SuppressMessage("", "SA1649", Justification = "Autogenerated all at once")]
[SuppressMessage("", "SA1402", Justification = "Autogenerated all at once")]
[SuppressMessage("StyleCop.CSharp.DocumentationRules", "SA1600:Elements should be documented", Justification = "Generated code")]
[SuppressMessage("StyleCop.CSharp.DocumentationRules", "SA1601:Partial elements should be documented", Justification = "Generated code")]
public partial class MqttClientConfigurationBuilder
{
    public partial MqttClientConfigurationBuilder WithAuthentication(string? method, byte[]? data);
}
