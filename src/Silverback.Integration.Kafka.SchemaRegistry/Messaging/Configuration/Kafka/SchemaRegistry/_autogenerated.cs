// Copyright (c) 2024 Sergio Aquilini
// This code is licensed under MIT license (see LICENSE file for details)

using System;
using System.Diagnostics.CodeAnalysis;
using Confluent.SchemaRegistry;

namespace Silverback.Messaging.Configuration.Kafka.SchemaRegistry;

/// <content>
///     The autogenerated part of the <see cref="KafkaSchemaRegistryConfiguration" /> class.
/// </content>
[SuppressMessage("StyleCop.CSharp.MaintainabilityRules", "SA1402:File may only contain a single type", Justification = "Autogenerated all at once")]
[SuppressMessage("Design", "CA1044:Properties should not be write only", Justification = "Accessors generated according to wrapped class")]
public partial record KafkaSchemaRegistryConfiguration
{
    /// <summary>
    ///     Gets the source of the basic authentication credentials. This specifies whether the credentials are specified in the <see cref="BasicAuthUserInfo" />
    ///     or they are inherited from the producer or consumer configuration.
    /// </summary>
    public AuthCredentialsSource? BasicAuthCredentialsSource
    {
        get => SchemaRegistryConfig.BasicAuthCredentialsSource;
        init => SchemaRegistryConfig.BasicAuthCredentialsSource = value;
    }

    /// <summary>
    ///     Gets the comma-separated list of URLs for schema registry instances that are used to register or lookup schemas.
    /// </summary>
    [SuppressMessage("Design", "CA1056:URI-like properties should not be strings", Justification = "Generated according to wrapped class.")]
    public string? Url
    {
        get => SchemaRegistryConfig.Url;
        init => SchemaRegistryConfig.Url = value;
    }

    /// <summary>
    ///     Gets the timeout in milliseconds for the requests to the Confluent schema registry.
    /// </summary>
    public int? RequestTimeoutMs
    {
        get => SchemaRegistryConfig.RequestTimeoutMs;
        init => SchemaRegistryConfig.RequestTimeoutMs = value;
    }

    /// <summary>
    ///     Gets the file or directory path to the CA certificate(s) for verifying the registry's key. Defaults: On Windows the system's CA certificates are automatically looked up in the Windows Root certificate store.
    ///     On Mac OSX this configuration defaults to <c>probe</c>. It is recommended to install openssl using Homebrew, to provide CA certificates. On Linux install the distribution's ca-certificates package.
    ///     If OpenSSL is statically linked or <see cref="SslCaLocation" /> is set to <c>probe</c> a list of standard paths will be probed and the first one found will be used as the default CA certificate location path.
    ///     If OpenSSL is dynamically linked the OpenSSL library's default path will be used (see <c>OPENSSLDIR</c> in <c>openssl version -a</c>).
    /// </summary>
    public string? SslCaLocation
    {
        get => SchemaRegistryConfig.SslCaLocation;
        init => SchemaRegistryConfig.SslCaLocation = value;
    }

    /// <summary>
    ///     Gets the path to the client's keystore (PKCS#12) used for the authentication.
    /// </summary>
    public string? SslKeystoreLocation
    {
        get => SchemaRegistryConfig.SslKeystoreLocation;
        init => SchemaRegistryConfig.SslKeystoreLocation = value;
    }

    /// <summary>
    ///     Gets the client's keystore (PKCS#12) password.
    /// </summary>
    public string? SslKeystorePassword
    {
        get => SchemaRegistryConfig.SslKeystorePassword;
        init => SchemaRegistryConfig.SslKeystorePassword = value;
    }

    /// <summary>
    ///     Gets a value indicating whether the registry (server) certificate must be verified.
    /// </summary>
    public bool? EnableSslCertificateVerification
    {
        get => SchemaRegistryConfig.EnableSslCertificateVerification;
        init => SchemaRegistryConfig.EnableSslCertificateVerification = value;
    }

    /// <summary>
    ///     Gets the maximum number of schemas that are cached by the schema registry client.
    /// </summary>
    public int? MaxCachedSchemas
    {
        get => SchemaRegistryConfig.MaxCachedSchemas;
        init => SchemaRegistryConfig.MaxCachedSchemas = value;
    }

    /// <summary>
    ///     Gets the basic authentication credentials in the form {username}:{password}.
    /// </summary>
    public string? BasicAuthUserInfo
    {
        get => SchemaRegistryConfig.BasicAuthUserInfo;
        init => SchemaRegistryConfig.BasicAuthUserInfo = value;
    }

    /// <inheritdoc cref="IEquatable{T}.Equals(T)" />
    public bool Equals(KafkaSchemaRegistryConfiguration? other)
    {
        if (other is null)
            return false;

        if (ReferenceEquals(this, other))
            return true;

        return BasicAuthCredentialsSource == other.BasicAuthCredentialsSource &&
               Url == other.Url &&
               RequestTimeoutMs == other.RequestTimeoutMs &&
               SslCaLocation == other.SslCaLocation &&
               SslKeystoreLocation == other.SslKeystoreLocation &&
               SslKeystorePassword == other.SslKeystorePassword &&
               EnableSslCertificateVerification == other.EnableSslCertificateVerification &&
               MaxCachedSchemas == other.MaxCachedSchemas &&
               BasicAuthUserInfo == other.BasicAuthUserInfo;
    }

    /// <inheritdoc cref="object.GetHashCode" />
    public override int GetHashCode() => HashCode.Combine(
        BasicAuthCredentialsSource,
        Url,
        RequestTimeoutMs,
        SslCaLocation,
        SslKeystoreLocation,
        EnableSslCertificateVerification,
        MaxCachedSchemas,
        BasicAuthUserInfo);
}

/// <content>
///     The autogenerated part of the <see cref="KafkaSchemaRegistryConfigurationBuilder" /> class.
/// </content>
[SuppressMessage("StyleCop.CSharp.MaintainabilityRules", "SA1402:File may only contain a single type", Justification = "Autogenerated all at once")]
[SuppressMessage("StyleCop.CSharp.OrderingRules", "SA1202: 'public' members should come before 'internal' members", Justification = "Autogenerated")]
[SuppressMessage("StyleCop.CSharp.DocumentationRules", "SA1600:Elements should be documented", Justification = "Documented in other partial")]
[SuppressMessage("StyleCop.CSharp.DocumentationRules", "SA1601:Partial elements should be documented", Justification = "Autogenerated")]
public partial class KafkaSchemaRegistryConfigurationBuilder
{
    public partial KafkaSchemaRegistryConfigurationBuilder WithBasicAuthCredentialsSource(AuthCredentialsSource? basicAuthCredentialsSource)
    {
        SchemaRegistryConfig.BasicAuthCredentialsSource = basicAuthCredentialsSource;
        return this;
    }

    public partial KafkaSchemaRegistryConfigurationBuilder WithUrl(string? url)
    {
        SchemaRegistryConfig.Url = url;
        return this;
    }

    public partial KafkaSchemaRegistryConfigurationBuilder WithRequestTimeoutMs(int? requestTimeoutMs)
    {
        SchemaRegistryConfig.RequestTimeoutMs = requestTimeoutMs;
        return this;
    }

    public partial KafkaSchemaRegistryConfigurationBuilder WithSslCaLocation(string? sslCaLocation)
    {
        SchemaRegistryConfig.SslCaLocation = sslCaLocation;
        return this;
    }

    public partial KafkaSchemaRegistryConfigurationBuilder WithSslKeystoreLocation(string? sslKeystoreLocation)
    {
        SchemaRegistryConfig.SslKeystoreLocation = sslKeystoreLocation;
        return this;
    }

    public partial KafkaSchemaRegistryConfigurationBuilder WithSslKeystorePassword(string? sslKeystorePassword)
    {
        SchemaRegistryConfig.SslKeystorePassword = sslKeystorePassword;
        return this;
    }

    public partial KafkaSchemaRegistryConfigurationBuilder WithMaxCachedSchemas(int? maxCachedSchemas)
    {
        SchemaRegistryConfig.MaxCachedSchemas = maxCachedSchemas;
        return this;
    }

    public partial KafkaSchemaRegistryConfigurationBuilder WithBasicAuthUserInfo(string? basicAuthUserInfo)
    {
        SchemaRegistryConfig.BasicAuthUserInfo = basicAuthUserInfo;
        return this;
    }

    internal KafkaSchemaRegistryConfigurationBuilder WithEnableSslCertificateVerification(bool? enableSslCertificateVerification)
    {
        SchemaRegistryConfig.EnableSslCertificateVerification = enableSslCertificateVerification;
        return this;
    }
}
