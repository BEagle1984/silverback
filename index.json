{
  "about.html": {
    "href": "about.html",
    "title": "About | Silverback",
    "keywords": "About Author Silverback is an open-source project maintained by Sergio Aquilini (BEagle1984 on GitHub). GitHub LinkedIn Personal E-Mail Project E-Mail License The code is licensed under MIT license (see LICENSE file for details). Credits Silverback uses the following libraries under the hood: Rx.Net Json.NET Confluent's .NET Client for Apache Kafka MQTTNet RabbitMQ .NET Client Special Thanks A very big thank you to all the contributors and especially to my friends and colleagues: Fabio for the help with Kafka Laurent for constantly challenging, pushing and bringing new ideas and feedbacks Marc for his contributions and the valuable constant feedbacks and ideas"
  },
  "api/Microsoft.Extensions.DependencyInjection.BrokerOptionsBuilderAddMockedKafkaExtensions.html": {
    "href": "api/Microsoft.Extensions.DependencyInjection.BrokerOptionsBuilderAddMockedKafkaExtensions.html",
    "title": "Class BrokerOptionsBuilderAddMockedKafkaExtensions | Silverback",
    "keywords": "Class BrokerOptionsBuilderAddMockedKafkaExtensions Adds the AddMockedKafka method to the Microsoft.Extensions.DependencyInjection.IBrokerOptionsBuilder . Inheritance System.Object BrokerOptionsBuilderAddMockedKafkaExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Microsoft.Extensions.DependencyInjection Assembly : Silverback.Integration.Kafka.Testing.dll Syntax public static class BrokerOptionsBuilderAddMockedKafkaExtensions Methods | Improve this doc View source AddMockedKafka(IBrokerOptionsBuilder, Action<IMockedKafkaOptionsBuilder>) Registers Apache Kafka as message broker but replaces the Kafka connectivity based on Confluent.Kafka with a mocked in-memory message broker that more or less replicates the Kafka behavior. Declaration public static IBrokerOptionsBuilder AddMockedKafka(this IBrokerOptionsBuilder brokerOptionsBuilder, Action<IMockedKafkaOptionsBuilder> optionsAction = null) Parameters Type Name Description Microsoft.Extensions.DependencyInjection.IBrokerOptionsBuilder brokerOptionsBuilder The Microsoft.Extensions.DependencyInjection.IBrokerOptionsBuilder that references the Microsoft.Extensions.DependencyInjection.IServiceCollection to add the services to. System.Action < IMockedKafkaOptionsBuilder > optionsAction Configures the mock options. Returns Type Description Microsoft.Extensions.DependencyInjection.IBrokerOptionsBuilder The Microsoft.Extensions.DependencyInjection.IBrokerOptionsBuilder so that additional calls can be chained."
  },
  "api/Microsoft.Extensions.DependencyInjection.BrokerOptionsBuilderAddMockedMqttExtensions.html": {
    "href": "api/Microsoft.Extensions.DependencyInjection.BrokerOptionsBuilderAddMockedMqttExtensions.html",
    "title": "Class BrokerOptionsBuilderAddMockedMqttExtensions | Silverback",
    "keywords": "Class BrokerOptionsBuilderAddMockedMqttExtensions Adds the AddMockedMqtt method to the Microsoft.Extensions.DependencyInjection.IBrokerOptionsBuilder . Inheritance System.Object BrokerOptionsBuilderAddMockedMqttExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Microsoft.Extensions.DependencyInjection Assembly : Silverback.Integration.MQTT.Testing.dll Syntax public static class BrokerOptionsBuilderAddMockedMqttExtensions Methods | Improve this doc View source AddMockedMqtt(IBrokerOptionsBuilder, Action<IMockedMqttOptionsBuilder>) Registers Apache Mqtt as message broker but replaces the MQTT connectivity based on MQTTnet with a mocked in-memory message broker that more or less replicates the MQTT broker behavior. Declaration public static IBrokerOptionsBuilder AddMockedMqtt(this IBrokerOptionsBuilder brokerOptionsBuilder, Action<IMockedMqttOptionsBuilder> optionsAction = null) Parameters Type Name Description Microsoft.Extensions.DependencyInjection.IBrokerOptionsBuilder brokerOptionsBuilder The Microsoft.Extensions.DependencyInjection.IBrokerOptionsBuilder that references the Microsoft.Extensions.DependencyInjection.IServiceCollection to add the services to. System.Action < IMockedMqttOptionsBuilder > optionsAction Configures the mock options. Returns Type Description Microsoft.Extensions.DependencyInjection.IBrokerOptionsBuilder The Microsoft.Extensions.DependencyInjection.IBrokerOptionsBuilder so that additional calls can be chained."
  },
  "api/Microsoft.Extensions.DependencyInjection.BrokerOptionsBuilderAddRabbitExtensions.html": {
    "href": "api/Microsoft.Extensions.DependencyInjection.BrokerOptionsBuilderAddRabbitExtensions.html",
    "title": "Class BrokerOptionsBuilderAddRabbitExtensions | Silverback",
    "keywords": "Class BrokerOptionsBuilderAddRabbitExtensions Adds the AddRabbit method to the Microsoft.Extensions.DependencyInjection.IBrokerOptionsBuilder . Inheritance System.Object BrokerOptionsBuilderAddRabbitExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Microsoft.Extensions.DependencyInjection Assembly : Silverback.Integration.RabbitMQ.dll Syntax public static class BrokerOptionsBuilderAddRabbitExtensions Methods | Improve this doc View source AddRabbit(IBrokerOptionsBuilder) Registers RabbitMQ as message broker. Declaration public static IBrokerOptionsBuilder AddRabbit(this IBrokerOptionsBuilder brokerOptionsBuilder) Parameters Type Name Description Microsoft.Extensions.DependencyInjection.IBrokerOptionsBuilder brokerOptionsBuilder The Microsoft.Extensions.DependencyInjection.IBrokerOptionsBuilder that references the Microsoft.Extensions.DependencyInjection.IServiceCollection to add the services to. Returns Type Description Microsoft.Extensions.DependencyInjection.IBrokerOptionsBuilder The Microsoft.Extensions.DependencyInjection.IBrokerOptionsBuilder so that additional calls can be chained."
  },
  "api/Microsoft.Extensions.DependencyInjection.HealthCheckBuilderExtensions.html": {
    "href": "api/Microsoft.Extensions.DependencyInjection.HealthCheckBuilderExtensions.html",
    "title": "Class HealthCheckBuilderExtensions | Silverback",
    "keywords": "Class HealthCheckBuilderExtensions Adds methods such as AddOutboundEndpointsCheck and AddOutboundQueueCheck to the Microsoft.Extensions.DependencyInjection.IHealthChecksBuilder . Inheritance System.Object HealthCheckBuilderExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Microsoft.Extensions.DependencyInjection Assembly : Silverback.Integration.HealthChecks.dll Syntax public static class HealthCheckBuilderExtensions Methods | Improve this doc View source AddConsumersCheck(IHealthChecksBuilder, ConsumerStatus, Nullable<TimeSpan>, Func<IConsumerEndpoint, Boolean>, String, Nullable<HealthStatus>, IEnumerable<String>) Adds a health check that verifies that all consumers are connected. Declaration public static IHealthChecksBuilder AddConsumersCheck(this IHealthChecksBuilder builder, ConsumerStatus minHealthyStatus = ConsumerStatus.Ready, TimeSpan? gracePeriod = null, Func<IConsumerEndpoint, bool> endpointsFilter = null, string name = \"Consumers\", HealthStatus? failureStatus = null, IEnumerable<string> tags = null) Parameters Type Name Description Microsoft.Extensions.DependencyInjection.IHealthChecksBuilder builder The Microsoft.Extensions.DependencyInjection.IHealthChecksBuilder . Silverback.Messaging.Broker.ConsumerStatus minHealthyStatus The minimum Silverback.Messaging.Broker.ConsumerStatus a consumer must have to be considered healthy. System.Nullable < System.TimeSpan > gracePeriod The grace period to observe after each status change before a consumer is considered unhealthy. System.Func < Silverback.Messaging.IConsumerEndpoint , System.Boolean > endpointsFilter An optional filter to be applied to the endpoints to be tested. System.String name The health check name. The default is \"Consumers\". System.Nullable < Microsoft.Extensions.Diagnostics.HealthChecks.HealthStatus > failureStatus The Microsoft.Extensions.Diagnostics.HealthChecks.HealthStatus that should be reported when the health check reports a failure. The default is Microsoft.Extensions.Diagnostics.HealthChecks.HealthStatus.Unhealthy . System.Collections.Generic.IEnumerable < System.String > tags An optional list of tags that can be used for filtering health checks. Returns Type Description Microsoft.Extensions.DependencyInjection.IHealthChecksBuilder The Microsoft.Extensions.DependencyInjection.IHealthChecksBuilder so that additional calls can be chained. | Improve this doc View source AddOutboundEndpointsCheck(IHealthChecksBuilder, String, Nullable<HealthStatus>, IEnumerable<String>) Adds a health check that sends a ping message to all the outbound endpoints. Declaration public static IHealthChecksBuilder AddOutboundEndpointsCheck(this IHealthChecksBuilder builder, string name = \"OutboundEndpoints\", HealthStatus? failureStatus = null, IEnumerable<string> tags = null) Parameters Type Name Description Microsoft.Extensions.DependencyInjection.IHealthChecksBuilder builder The Microsoft.Extensions.DependencyInjection.IHealthChecksBuilder . System.String name The health check name. The default is \"OutboundEndpoints\". System.Nullable < Microsoft.Extensions.Diagnostics.HealthChecks.HealthStatus > failureStatus The Microsoft.Extensions.Diagnostics.HealthChecks.HealthStatus that should be reported when the health check reports a failure. The default is Microsoft.Extensions.Diagnostics.HealthChecks.HealthStatus.Unhealthy . System.Collections.Generic.IEnumerable < System.String > tags An optional list of tags that can be used for filtering health checks. Returns Type Description Microsoft.Extensions.DependencyInjection.IHealthChecksBuilder The Microsoft.Extensions.DependencyInjection.IHealthChecksBuilder so that additional calls can be chained. | Improve this doc View source AddOutboxCheck(IHealthChecksBuilder, String, Nullable<HealthStatus>, IEnumerable<String>) Adds a health check that monitors the outbox, verifying that the messages are being processed. Declaration public static IHealthChecksBuilder AddOutboxCheck(this IHealthChecksBuilder builder, string name = \"OutboundQueue\", HealthStatus? failureStatus = null, IEnumerable<string> tags = null) Parameters Type Name Description Microsoft.Extensions.DependencyInjection.IHealthChecksBuilder builder The Microsoft.Extensions.DependencyInjection.IHealthChecksBuilder . System.String name The health check name. The default is \"OutboundQueue\". System.Nullable < Microsoft.Extensions.Diagnostics.HealthChecks.HealthStatus > failureStatus The Microsoft.Extensions.Diagnostics.HealthChecks.HealthStatus that should be reported when the health check reports a failure. The default is Microsoft.Extensions.Diagnostics.HealthChecks.HealthStatus.Unhealthy . System.Collections.Generic.IEnumerable < System.String > tags An optional list of tags that can be used for filtering health checks. Returns Type Description Microsoft.Extensions.DependencyInjection.IHealthChecksBuilder The Microsoft.Extensions.DependencyInjection.IHealthChecksBuilder so that additional calls can be chained."
  },
  "api/Microsoft.Extensions.DependencyInjection.html": {
    "href": "api/Microsoft.Extensions.DependencyInjection.html",
    "title": "Namespace Microsoft.Extensions.DependencyInjection | Silverback",
    "keywords": "Namespace Microsoft.Extensions.DependencyInjection Classes BrokerOptionsBuilderAddMockedKafkaExtensions Adds the AddMockedKafka method to the Microsoft.Extensions.DependencyInjection.IBrokerOptionsBuilder . BrokerOptionsBuilderAddMockedMqttExtensions Adds the AddMockedMqtt method to the Microsoft.Extensions.DependencyInjection.IBrokerOptionsBuilder . BrokerOptionsBuilderAddRabbitExtensions Adds the AddRabbit method to the Microsoft.Extensions.DependencyInjection.IBrokerOptionsBuilder . HealthCheckBuilderExtensions Adds methods such as AddOutboundEndpointsCheck and AddOutboundQueueCheck to the Microsoft.Extensions.DependencyInjection.IHealthChecksBuilder . ServiceCollectionAddSilverbackExtensions Adds the AddSilverback method to the Microsoft.Extensions.DependencyInjection.IServiceCollection . ServiceCollectionConfigureSilverbackExtensions Adds the ConfigureSilverback method to the Microsoft.Extensions.DependencyInjection.IServiceCollection . ServiceCollectionUseMockedKafkaExtensions Adds the UseMockedKafka method to the Microsoft.Extensions.DependencyInjection.IServiceCollection . ServiceCollectionUseMockedMqttExtensions Adds the UseMockedMqtt method to the Microsoft.Extensions.DependencyInjection.IServiceCollection . SilverbackBuilderAddBehaviorExtensions Adds the AddTransientBehavior , AddScopedBehavior and AddSingletonBehavior methods to the ISilverbackBuilder . SilverbackBuilderAddDbDistributedLockManagerExtensions Adds the AddDbDistributedLockManager method to the ISilverbackBuilder . SilverbackBuilderAddDelegateSubscriberExtensions Adds the AddDelegateSubscriber methods to the ISilverbackBuilder . SilverbackBuilderAddIntegrationSpyExtensions Adds the AddIntegrationSpy and AddIntegrationSpyAndSubscriber methods to the ISilverbackBuilder . SilverbackBuilderAddSubscriberExtensions Adds the AddTransientSubscriber , AddScopedSubscriber and AddSingletonSubscriber methods to the ISilverbackBuilder . SilverbackBuilderUseDbContextExtensions Contains the UseDbContext extension for the ISilverbackBuilder . SilverbackBuilderUseMockedKafkaExtensions Adds the UseMockedKafka method to the ISilverbackBuilder . SilverbackBuilderUseMockedMqttExtensions Adds the UseMockedMqtt method to the ISilverbackBuilder . SilverbackBuilderUseModelExtensions Adds the UseModel method to the ISilverbackBuilder . SilverbackBuilderWithLogLevelsExtensions Adds the WithLogLevels method to the ISilverbackBuilder ."
  },
  "api/Microsoft.Extensions.DependencyInjection.ServiceCollectionAddSilverbackExtensions.html": {
    "href": "api/Microsoft.Extensions.DependencyInjection.ServiceCollectionAddSilverbackExtensions.html",
    "title": "Class ServiceCollectionAddSilverbackExtensions | Silverback",
    "keywords": "Class ServiceCollectionAddSilverbackExtensions Adds the AddSilverback method to the Microsoft.Extensions.DependencyInjection.IServiceCollection . Inheritance System.Object ServiceCollectionAddSilverbackExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Microsoft.Extensions.DependencyInjection Assembly : Silverback.Core.dll Syntax public static class ServiceCollectionAddSilverbackExtensions Methods | Improve this doc View source AddSilverback(IServiceCollection) Adds the minimum essential Silverback services to the Microsoft.Extensions.DependencyInjection.IServiceCollection . Additional services including broker support, inbound/outbound connectors and database bindings must be added separately using the returned ISilverbackBuilder . Declaration public static ISilverbackBuilder AddSilverback(this IServiceCollection services) Parameters Type Name Description Microsoft.Extensions.DependencyInjection.IServiceCollection services The Microsoft.Extensions.DependencyInjection.IServiceCollection to add the services to. Returns Type Description ISilverbackBuilder The ISilverbackBuilder to add the services necessary to enable the Silverback features."
  },
  "api/Microsoft.Extensions.DependencyInjection.ServiceCollectionConfigureSilverbackExtensions.html": {
    "href": "api/Microsoft.Extensions.DependencyInjection.ServiceCollectionConfigureSilverbackExtensions.html",
    "title": "Class ServiceCollectionConfigureSilverbackExtensions | Silverback",
    "keywords": "Class ServiceCollectionConfigureSilverbackExtensions Adds the ConfigureSilverback method to the Microsoft.Extensions.DependencyInjection.IServiceCollection . Inheritance System.Object ServiceCollectionConfigureSilverbackExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Microsoft.Extensions.DependencyInjection Assembly : Silverback.Core.dll Syntax public static class ServiceCollectionConfigureSilverbackExtensions Methods | Improve this doc View source ConfigureSilverback(IServiceCollection) Returns an ISilverbackBuilder instance that can be used to configure the additional services. Declaration public static ISilverbackBuilder ConfigureSilverback(this IServiceCollection services) Parameters Type Name Description Microsoft.Extensions.DependencyInjection.IServiceCollection services The Microsoft.Extensions.DependencyInjection.IServiceCollection to add the services to. Returns Type Description ISilverbackBuilder The ISilverbackBuilder to add the services necessary to enable the Silverback features."
  },
  "api/Microsoft.Extensions.DependencyInjection.ServiceCollectionUseMockedKafkaExtensions.html": {
    "href": "api/Microsoft.Extensions.DependencyInjection.ServiceCollectionUseMockedKafkaExtensions.html",
    "title": "Class ServiceCollectionUseMockedKafkaExtensions | Silverback",
    "keywords": "Class ServiceCollectionUseMockedKafkaExtensions Adds the UseMockedKafka method to the Microsoft.Extensions.DependencyInjection.IServiceCollection . Inheritance System.Object ServiceCollectionUseMockedKafkaExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Microsoft.Extensions.DependencyInjection Assembly : Silverback.Integration.Kafka.Testing.dll Syntax public static class ServiceCollectionUseMockedKafkaExtensions Methods | Improve this doc View source UseMockedKafka(IServiceCollection, Action<IMockedKafkaOptionsBuilder>) Replaces the Kafka connectivity based on Confluent.Kafka with a mocked in-memory message broker that more or less replicates the Kafka behavior. Declaration public static IServiceCollection UseMockedKafka(this IServiceCollection services, Action<IMockedKafkaOptionsBuilder> optionsAction = null) Parameters Type Name Description Microsoft.Extensions.DependencyInjection.IServiceCollection services The Microsoft.Extensions.DependencyInjection.IServiceCollection to add the service to. System.Action < IMockedKafkaOptionsBuilder > optionsAction Additional options (such as topics and partitions settings). Returns Type Description Microsoft.Extensions.DependencyInjection.IServiceCollection The Microsoft.Extensions.DependencyInjection.IServiceCollection so that additional calls can be chained."
  },
  "api/Microsoft.Extensions.DependencyInjection.ServiceCollectionUseMockedMqttExtensions.html": {
    "href": "api/Microsoft.Extensions.DependencyInjection.ServiceCollectionUseMockedMqttExtensions.html",
    "title": "Class ServiceCollectionUseMockedMqttExtensions | Silverback",
    "keywords": "Class ServiceCollectionUseMockedMqttExtensions Adds the UseMockedMqtt method to the Microsoft.Extensions.DependencyInjection.IServiceCollection . Inheritance System.Object ServiceCollectionUseMockedMqttExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Microsoft.Extensions.DependencyInjection Assembly : Silverback.Integration.MQTT.Testing.dll Syntax public static class ServiceCollectionUseMockedMqttExtensions Methods | Improve this doc View source UseMockedMqtt(IServiceCollection) Replaces the MQTT connectivity based on MQTTnet with a mocked in-memory message broker that more or less replicates the MQTT broker behavior. Declaration public static IServiceCollection UseMockedMqtt(this IServiceCollection services) Parameters Type Name Description Microsoft.Extensions.DependencyInjection.IServiceCollection services The Microsoft.Extensions.DependencyInjection.IServiceCollection to add the service to. Returns Type Description Microsoft.Extensions.DependencyInjection.IServiceCollection The Microsoft.Extensions.DependencyInjection.IServiceCollection so that additional calls can be chained."
  },
  "api/Microsoft.Extensions.DependencyInjection.SilverbackBuilderAddBehaviorExtensions.html": {
    "href": "api/Microsoft.Extensions.DependencyInjection.SilverbackBuilderAddBehaviorExtensions.html",
    "title": "Class SilverbackBuilderAddBehaviorExtensions | Silverback",
    "keywords": "Class SilverbackBuilderAddBehaviorExtensions Adds the AddTransientBehavior , AddScopedBehavior and AddSingletonBehavior methods to the ISilverbackBuilder . Inheritance System.Object SilverbackBuilderAddBehaviorExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Microsoft.Extensions.DependencyInjection Assembly : Silverback.Core.dll Syntax public static class SilverbackBuilderAddBehaviorExtensions Methods | Improve this doc View source AddScopedBehavior(ISilverbackBuilder, Func<IServiceProvider, IBehavior>) Adds a scoped behavior with a factory specified in implementationFactory to the Microsoft.Extensions.DependencyInjection.IServiceCollection . Declaration public static ISilverbackBuilder AddScopedBehavior(this ISilverbackBuilder silverbackBuilder, Func<IServiceProvider, IBehavior> implementationFactory) Parameters Type Name Description ISilverbackBuilder silverbackBuilder The ISilverbackBuilder that references the Microsoft.Extensions.DependencyInjection.IServiceCollection to add the behavior to. System.Func < System.IServiceProvider , IBehavior > implementationFactory The factory that creates the service. Returns Type Description ISilverbackBuilder The ISilverbackBuilder so that additional calls can be chained. | Improve this doc View source AddScopedBehavior(ISilverbackBuilder, Type) Adds a scoped behavior of the type specified in behaviorType to the Microsoft.Extensions.DependencyInjection.IServiceCollection . Declaration public static ISilverbackBuilder AddScopedBehavior(this ISilverbackBuilder silverbackBuilder, Type behaviorType) Parameters Type Name Description ISilverbackBuilder silverbackBuilder The ISilverbackBuilder that references the Microsoft.Extensions.DependencyInjection.IServiceCollection to add the behavior to. System.Type behaviorType The type of the behavior to register and the implementation to use. Returns Type Description ISilverbackBuilder The ISilverbackBuilder so that additional calls can be chained. | Improve this doc View source AddScopedBehavior<TBehavior>(ISilverbackBuilder) Adds a scoped behavior of the type specified in TBehavior to the Microsoft.Extensions.DependencyInjection.IServiceCollection . Declaration public static ISilverbackBuilder AddScopedBehavior<TBehavior>(this ISilverbackBuilder silverbackBuilder) where TBehavior : class, IBehavior Parameters Type Name Description ISilverbackBuilder silverbackBuilder The ISilverbackBuilder that references the Microsoft.Extensions.DependencyInjection.IServiceCollection to add the behavior to. Returns Type Description ISilverbackBuilder The ISilverbackBuilder so that additional calls can be chained. Type Parameters Name Description TBehavior The type of the behavior to add. | Improve this doc View source AddSingletonBehavior(ISilverbackBuilder, IBehavior) Adds a singleton behavior with an instance specified in implementationInstance to the Microsoft.Extensions.DependencyInjection.IServiceCollection . Declaration public static ISilverbackBuilder AddSingletonBehavior(this ISilverbackBuilder silverbackBuilder, IBehavior implementationInstance) Parameters Type Name Description ISilverbackBuilder silverbackBuilder The ISilverbackBuilder that references the Microsoft.Extensions.DependencyInjection.IServiceCollection to add the behavior to. IBehavior implementationInstance The instance of the service. Returns Type Description ISilverbackBuilder The ISilverbackBuilder so that additional calls can be chained. | Improve this doc View source AddSingletonBehavior(ISilverbackBuilder, Func<IServiceProvider, IBehavior>) Adds a singleton behavior with a factory specified in implementationFactory to the Microsoft.Extensions.DependencyInjection.IServiceCollection . Declaration public static ISilverbackBuilder AddSingletonBehavior(this ISilverbackBuilder silverbackBuilder, Func<IServiceProvider, IBehavior> implementationFactory) Parameters Type Name Description ISilverbackBuilder silverbackBuilder The ISilverbackBuilder that references the Microsoft.Extensions.DependencyInjection.IServiceCollection to add the behavior to. System.Func < System.IServiceProvider , IBehavior > implementationFactory The factory that creates the service. Returns Type Description ISilverbackBuilder The ISilverbackBuilder so that additional calls can be chained. | Improve this doc View source AddSingletonBehavior(ISilverbackBuilder, Type) Adds a singleton behavior of the type specified in behaviorType to the Microsoft.Extensions.DependencyInjection.IServiceCollection . Declaration public static ISilverbackBuilder AddSingletonBehavior(this ISilverbackBuilder silverbackBuilder, Type behaviorType) Parameters Type Name Description ISilverbackBuilder silverbackBuilder The ISilverbackBuilder that references the Microsoft.Extensions.DependencyInjection.IServiceCollection to add the behavior to. System.Type behaviorType The type of the behavior to register and the implementation to use. Returns Type Description ISilverbackBuilder The ISilverbackBuilder so that additional calls can be chained. | Improve this doc View source AddSingletonBehavior<TBehavior>(ISilverbackBuilder) Adds a singleton behavior of the type specified in TBehavior to the Microsoft.Extensions.DependencyInjection.IServiceCollection . Declaration public static ISilverbackBuilder AddSingletonBehavior<TBehavior>(this ISilverbackBuilder silverbackBuilder) where TBehavior : class, IBehavior Parameters Type Name Description ISilverbackBuilder silverbackBuilder The ISilverbackBuilder that references the Microsoft.Extensions.DependencyInjection.IServiceCollection to add the behavior to. Returns Type Description ISilverbackBuilder The ISilverbackBuilder so that additional calls can be chained. Type Parameters Name Description TBehavior The type of the behavior to add. | Improve this doc View source AddTransientBehavior(ISilverbackBuilder, Func<IServiceProvider, IBehavior>) Adds a scoped behavior with a factory specified in implementationFactory to the Microsoft.Extensions.DependencyInjection.IServiceCollection . Declaration public static ISilverbackBuilder AddTransientBehavior(this ISilverbackBuilder silverbackBuilder, Func<IServiceProvider, IBehavior> implementationFactory) Parameters Type Name Description ISilverbackBuilder silverbackBuilder The ISilverbackBuilder that references the Microsoft.Extensions.DependencyInjection.IServiceCollection to add the behavior to. System.Func < System.IServiceProvider , IBehavior > implementationFactory The factory that creates the service. Returns Type Description ISilverbackBuilder The ISilverbackBuilder so that additional calls can be chained. | Improve this doc View source AddTransientBehavior(ISilverbackBuilder, Type) Adds a scoped behavior of the type specified in behaviorType to the Microsoft.Extensions.DependencyInjection.IServiceCollection . Declaration public static ISilverbackBuilder AddTransientBehavior(this ISilverbackBuilder silverbackBuilder, Type behaviorType) Parameters Type Name Description ISilverbackBuilder silverbackBuilder The ISilverbackBuilder that references the Microsoft.Extensions.DependencyInjection.IServiceCollection to add the behavior to. System.Type behaviorType The type of the behavior to register and the implementation to use. Returns Type Description ISilverbackBuilder The ISilverbackBuilder so that additional calls can be chained. | Improve this doc View source AddTransientBehavior<TBehavior>(ISilverbackBuilder) Adds a scoped behavior of the type specified in TBehavior to the Microsoft.Extensions.DependencyInjection.IServiceCollection . Declaration public static ISilverbackBuilder AddTransientBehavior<TBehavior>(this ISilverbackBuilder silverbackBuilder) where TBehavior : class, IBehavior Parameters Type Name Description ISilverbackBuilder silverbackBuilder The ISilverbackBuilder that references the Microsoft.Extensions.DependencyInjection.IServiceCollection to add the behavior to. Returns Type Description ISilverbackBuilder The ISilverbackBuilder so that additional calls can be chained. Type Parameters Name Description TBehavior The type of the behavior to add."
  },
  "api/Microsoft.Extensions.DependencyInjection.SilverbackBuilderAddDbDistributedLockManagerExtensions.html": {
    "href": "api/Microsoft.Extensions.DependencyInjection.SilverbackBuilderAddDbDistributedLockManagerExtensions.html",
    "title": "Class SilverbackBuilderAddDbDistributedLockManagerExtensions | Silverback",
    "keywords": "Class SilverbackBuilderAddDbDistributedLockManagerExtensions Adds the AddDbDistributedLockManager method to the ISilverbackBuilder . Inheritance System.Object SilverbackBuilderAddDbDistributedLockManagerExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Microsoft.Extensions.DependencyInjection Assembly : Silverback.Core.dll Syntax public static class SilverbackBuilderAddDbDistributedLockManagerExtensions Methods | Improve this doc View source AddDbDistributedLockManager(ISilverbackBuilder) Adds the IDistributedLockManager implementation and uses the specified DbContext to handle the distributed locks. Declaration public static ISilverbackBuilder AddDbDistributedLockManager(this ISilverbackBuilder builder) Parameters Type Name Description ISilverbackBuilder builder The ISilverbackBuilder to add the model types to. Returns Type Description ISilverbackBuilder The ISilverbackBuilder so that additional calls can be chained."
  },
  "api/Microsoft.Extensions.DependencyInjection.SilverbackBuilderAddDelegateSubscriberExtensions.html": {
    "href": "api/Microsoft.Extensions.DependencyInjection.SilverbackBuilderAddDelegateSubscriberExtensions.html",
    "title": "Class SilverbackBuilderAddDelegateSubscriberExtensions | Silverback",
    "keywords": "Class SilverbackBuilderAddDelegateSubscriberExtensions Adds the AddDelegateSubscriber methods to the ISilverbackBuilder . Inheritance System.Object SilverbackBuilderAddDelegateSubscriberExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Microsoft.Extensions.DependencyInjection Assembly : Silverback.Core.dll Syntax public static class SilverbackBuilderAddDelegateSubscriberExtensions Methods | Improve this doc View source AddDelegateSubscriber(ISilverbackBuilder, Delegate, SubscriptionOptions) Subscribes the specified delegate to the messages being published into the bus. Declaration public static ISilverbackBuilder AddDelegateSubscriber(this ISilverbackBuilder silverbackBuilder, Delegate handler, SubscriptionOptions options = null) Parameters Type Name Description ISilverbackBuilder silverbackBuilder The ISilverbackBuilder that references the IBusOptions to be configured. System.Delegate handler The message handler delegate. SubscriptionOptions options The SubscriptionOptions . Returns Type Description ISilverbackBuilder The ISilverbackBuilder so that additional calls can be chained. | Improve this doc View source AddDelegateSubscriber<TMessage>(ISilverbackBuilder, Action<TMessage, IServiceProvider>, SubscriptionOptions) Subscribes the specified delegate to the messages being published into the bus. Declaration public static ISilverbackBuilder AddDelegateSubscriber<TMessage>(this ISilverbackBuilder silverbackBuilder, Action<TMessage, IServiceProvider> handler, SubscriptionOptions options = null) Parameters Type Name Description ISilverbackBuilder silverbackBuilder The ISilverbackBuilder that references the IBusOptions to be configured. System.Action <TMessage, System.IServiceProvider > handler The message handler delegate. SubscriptionOptions options The SubscriptionOptions . Returns Type Description ISilverbackBuilder The ISilverbackBuilder so that additional calls can be chained. Type Parameters Name Description TMessage The type of the messages to be handled. | Improve this doc View source AddDelegateSubscriber<TMessage>(ISilverbackBuilder, Action<TMessage>, SubscriptionOptions) Subscribes the specified delegate to the messages being published into the bus. Declaration public static ISilverbackBuilder AddDelegateSubscriber<TMessage>(this ISilverbackBuilder silverbackBuilder, Action<TMessage> handler, SubscriptionOptions options = null) Parameters Type Name Description ISilverbackBuilder silverbackBuilder The ISilverbackBuilder that references the IBusOptions to be configured. System.Action <TMessage> handler The message handler delegate. SubscriptionOptions options The SubscriptionOptions . Returns Type Description ISilverbackBuilder The ISilverbackBuilder so that additional calls can be chained. Type Parameters Name Description TMessage The type of the messages to be handled. | Improve this doc View source AddDelegateSubscriber<TMessage>(ISilverbackBuilder, Action<IEnumerable<TMessage>, IServiceProvider>, SubscriptionOptions) Subscribes the specified delegate to the messages being published into the bus. Declaration public static ISilverbackBuilder AddDelegateSubscriber<TMessage>(this ISilverbackBuilder silverbackBuilder, Action<IEnumerable<TMessage>, IServiceProvider> handler, SubscriptionOptions options = null) Parameters Type Name Description ISilverbackBuilder silverbackBuilder The ISilverbackBuilder that references the IBusOptions to be configured. System.Action < System.Collections.Generic.IEnumerable <TMessage>, System.IServiceProvider > handler The message handler delegate. SubscriptionOptions options The SubscriptionOptions . Returns Type Description ISilverbackBuilder The ISilverbackBuilder so that additional calls can be chained. Type Parameters Name Description TMessage The type of the messages to be handled. | Improve this doc View source AddDelegateSubscriber<TMessage>(ISilverbackBuilder, Action<IEnumerable<TMessage>>, SubscriptionOptions) Subscribes the specified delegate to the messages being published into the bus. Declaration public static ISilverbackBuilder AddDelegateSubscriber<TMessage>(this ISilverbackBuilder silverbackBuilder, Action<IEnumerable<TMessage>> handler, SubscriptionOptions options = null) Parameters Type Name Description ISilverbackBuilder silverbackBuilder The ISilverbackBuilder that references the IBusOptions to be configured. System.Action < System.Collections.Generic.IEnumerable <TMessage>> handler The message handler delegate. SubscriptionOptions options The SubscriptionOptions . Returns Type Description ISilverbackBuilder The ISilverbackBuilder so that additional calls can be chained. Type Parameters Name Description TMessage The type of the messages to be handled. | Improve this doc View source AddDelegateSubscriber<TMessage>(ISilverbackBuilder, Func<TMessage, IServiceProvider, Object>, SubscriptionOptions) Subscribes the specified delegate to the messages being published into the bus. Declaration public static ISilverbackBuilder AddDelegateSubscriber<TMessage>(this ISilverbackBuilder silverbackBuilder, Func<TMessage, IServiceProvider, object> handler, SubscriptionOptions options = null) Parameters Type Name Description ISilverbackBuilder silverbackBuilder The ISilverbackBuilder that references the IBusOptions to be configured. System.Func <TMessage, System.IServiceProvider , System.Object > handler The message handler delegate. SubscriptionOptions options The SubscriptionOptions . Returns Type Description ISilverbackBuilder The ISilverbackBuilder so that additional calls can be chained. Type Parameters Name Description TMessage The type of the messages to be handled. | Improve this doc View source AddDelegateSubscriber<TMessage>(ISilverbackBuilder, Func<TMessage, IServiceProvider, Task>, SubscriptionOptions) Subscribes the specified delegate to the messages being published into the bus. Declaration public static ISilverbackBuilder AddDelegateSubscriber<TMessage>(this ISilverbackBuilder silverbackBuilder, Func<TMessage, IServiceProvider, Task> handler, SubscriptionOptions options = null) Parameters Type Name Description ISilverbackBuilder silverbackBuilder The ISilverbackBuilder that references the IBusOptions to be configured. System.Func <TMessage, System.IServiceProvider , System.Threading.Tasks.Task > handler The message handler delegate. SubscriptionOptions options The SubscriptionOptions . Returns Type Description ISilverbackBuilder The ISilverbackBuilder so that additional calls can be chained. Type Parameters Name Description TMessage The type of the messages to be handled. | Improve this doc View source AddDelegateSubscriber<TMessage>(ISilverbackBuilder, Func<TMessage, Object>, SubscriptionOptions) Subscribes the specified delegate to the messages being published into the bus. Declaration public static ISilverbackBuilder AddDelegateSubscriber<TMessage>(this ISilverbackBuilder silverbackBuilder, Func<TMessage, object> handler, SubscriptionOptions options = null) Parameters Type Name Description ISilverbackBuilder silverbackBuilder The ISilverbackBuilder that references the IBusOptions to be configured. System.Func <TMessage, System.Object > handler The message handler delegate. SubscriptionOptions options The SubscriptionOptions . Returns Type Description ISilverbackBuilder The ISilverbackBuilder so that additional calls can be chained. Type Parameters Name Description TMessage The type of the messages to be handled. | Improve this doc View source AddDelegateSubscriber<TMessage>(ISilverbackBuilder, Func<TMessage, Task<Object>>, SubscriptionOptions) Subscribes the specified delegate to the messages being published into the bus. Declaration public static ISilverbackBuilder AddDelegateSubscriber<TMessage>(this ISilverbackBuilder silverbackBuilder, Func<TMessage, Task<object>> handler, SubscriptionOptions options = null) Parameters Type Name Description ISilverbackBuilder silverbackBuilder The ISilverbackBuilder that references the IBusOptions to be configured. System.Func <TMessage, System.Threading.Tasks.Task < System.Object >> handler The message handler delegate. SubscriptionOptions options The SubscriptionOptions . Returns Type Description ISilverbackBuilder The ISilverbackBuilder so that additional calls can be chained. Type Parameters Name Description TMessage The type of the messages to be handled. | Improve this doc View source AddDelegateSubscriber<TMessage>(ISilverbackBuilder, Func<TMessage, Task>, SubscriptionOptions) Subscribes the specified delegate to the messages being published into the bus. Declaration public static ISilverbackBuilder AddDelegateSubscriber<TMessage>(this ISilverbackBuilder silverbackBuilder, Func<TMessage, Task> handler, SubscriptionOptions options = null) Parameters Type Name Description ISilverbackBuilder silverbackBuilder The ISilverbackBuilder that references the IBusOptions to be configured. System.Func <TMessage, System.Threading.Tasks.Task > handler The message handler delegate. SubscriptionOptions options The SubscriptionOptions . Returns Type Description ISilverbackBuilder The ISilverbackBuilder so that additional calls can be chained. Type Parameters Name Description TMessage The type of the messages to be handled. | Improve this doc View source AddDelegateSubscriber<TMessage>(ISilverbackBuilder, Func<IEnumerable<TMessage>, IServiceProvider, Object>, SubscriptionOptions) Subscribes the specified delegate to the messages being published into the bus. Declaration public static ISilverbackBuilder AddDelegateSubscriber<TMessage>(this ISilverbackBuilder silverbackBuilder, Func<IEnumerable<TMessage>, IServiceProvider, object> handler, SubscriptionOptions options = null) Parameters Type Name Description ISilverbackBuilder silverbackBuilder The ISilverbackBuilder that references the IBusOptions to be configured. System.Func < System.Collections.Generic.IEnumerable <TMessage>, System.IServiceProvider , System.Object > handler The message handler delegate. SubscriptionOptions options The SubscriptionOptions . Returns Type Description ISilverbackBuilder The ISilverbackBuilder so that additional calls can be chained. Type Parameters Name Description TMessage The type of the messages to be handled. | Improve this doc View source AddDelegateSubscriber<TMessage>(ISilverbackBuilder, Func<IEnumerable<TMessage>, Object>, SubscriptionOptions) Subscribes the specified delegate to the messages being published into the bus. Declaration public static ISilverbackBuilder AddDelegateSubscriber<TMessage>(this ISilverbackBuilder silverbackBuilder, Func<IEnumerable<TMessage>, object> handler, SubscriptionOptions options = null) Parameters Type Name Description ISilverbackBuilder silverbackBuilder The ISilverbackBuilder that references the IBusOptions to be configured. System.Func < System.Collections.Generic.IEnumerable <TMessage>, System.Object > handler The message handler delegate. SubscriptionOptions options The SubscriptionOptions . Returns Type Description ISilverbackBuilder The ISilverbackBuilder so that additional calls can be chained. Type Parameters Name Description TMessage The type of the messages to be handled. | Improve this doc View source AddDelegateSubscriber<TMessage>(ISilverbackBuilder, Func<IEnumerable<TMessage>, Task<Object>>, SubscriptionOptions) Subscribes the specified delegate to the messages being published into the bus. Declaration public static ISilverbackBuilder AddDelegateSubscriber<TMessage>(this ISilverbackBuilder silverbackBuilder, Func<IEnumerable<TMessage>, Task<object>> handler, SubscriptionOptions options = null) Parameters Type Name Description ISilverbackBuilder silverbackBuilder The ISilverbackBuilder that references the IBusOptions to be configured. System.Func < System.Collections.Generic.IEnumerable <TMessage>, System.Threading.Tasks.Task < System.Object >> handler The message handler delegate. SubscriptionOptions options The SubscriptionOptions . Returns Type Description ISilverbackBuilder The ISilverbackBuilder so that additional calls can be chained. Type Parameters Name Description TMessage The type of the messages to be handled. | Improve this doc View source AddDelegateSubscriber<TMessage>(ISilverbackBuilder, Func<IEnumerable<TMessage>, Task>, SubscriptionOptions) Subscribes the specified delegate to the messages being published into the bus. Declaration public static ISilverbackBuilder AddDelegateSubscriber<TMessage>(this ISilverbackBuilder silverbackBuilder, Func<IEnumerable<TMessage>, Task> handler, SubscriptionOptions options = null) Parameters Type Name Description ISilverbackBuilder silverbackBuilder The ISilverbackBuilder that references the IBusOptions to be configured. System.Func < System.Collections.Generic.IEnumerable <TMessage>, System.Threading.Tasks.Task > handler The message handler delegate. SubscriptionOptions options The SubscriptionOptions . Returns Type Description ISilverbackBuilder The ISilverbackBuilder so that additional calls can be chained. Type Parameters Name Description TMessage The type of the messages to be handled."
  },
  "api/Microsoft.Extensions.DependencyInjection.SilverbackBuilderAddIntegrationSpyExtensions.html": {
    "href": "api/Microsoft.Extensions.DependencyInjection.SilverbackBuilderAddIntegrationSpyExtensions.html",
    "title": "Class SilverbackBuilderAddIntegrationSpyExtensions | Silverback",
    "keywords": "Class SilverbackBuilderAddIntegrationSpyExtensions Adds the AddIntegrationSpy and AddIntegrationSpyAndSubscriber methods to the ISilverbackBuilder . Inheritance System.Object SilverbackBuilderAddIntegrationSpyExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Microsoft.Extensions.DependencyInjection Assembly : Silverback.Integration.Testing.dll Syntax public static class SilverbackBuilderAddIntegrationSpyExtensions Methods | Improve this doc View source AddIntegrationSpy(ISilverbackBuilder, Boolean) Adds the IIntegrationSpy and its support services to the Microsoft.Extensions.DependencyInjection.IServiceCollection . Declaration public static ISilverbackBuilder AddIntegrationSpy(this ISilverbackBuilder silverbackBuilder, bool attachSubscriber = false) Parameters Type Name Description ISilverbackBuilder silverbackBuilder The ISilverbackBuilder that references the Microsoft.Extensions.DependencyInjection.IServiceCollection to add the services to. System.Boolean attachSubscriber Specifies whether a generic subscriber ( InboundSpySubscriber must be used to monitor the inbound messages instead of a behavior ( InboundSpyBrokerBehavior ). Returns Type Description ISilverbackBuilder The ISilverbackBuilder so that additional calls can be chained. | Improve this doc View source AddIntegrationSpyAndSubscriber(ISilverbackBuilder) Adds the IIntegrationSpy and its support services to the Microsoft.Extensions.DependencyInjection.IServiceCollection and uses a generic subscriber to monitor the incoming messages. This is the same as calling AddIntegrationSpy(ISilverbackBuilder, Boolean) with the attachSubscriber parameter set to true . Declaration public static ISilverbackBuilder AddIntegrationSpyAndSubscriber(this ISilverbackBuilder silverbackBuilder) Parameters Type Name Description ISilverbackBuilder silverbackBuilder The ISilverbackBuilder that references the Microsoft.Extensions.DependencyInjection.IServiceCollection to add the services to. Returns Type Description ISilverbackBuilder The ISilverbackBuilder so that additional calls can be chained."
  },
  "api/Microsoft.Extensions.DependencyInjection.SilverbackBuilderAddSubscriberExtensions.html": {
    "href": "api/Microsoft.Extensions.DependencyInjection.SilverbackBuilderAddSubscriberExtensions.html",
    "title": "Class SilverbackBuilderAddSubscriberExtensions | Silverback",
    "keywords": "Class SilverbackBuilderAddSubscriberExtensions Adds the AddTransientSubscriber , AddScopedSubscriber and AddSingletonSubscriber methods to the ISilverbackBuilder . Inheritance System.Object SilverbackBuilderAddSubscriberExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Microsoft.Extensions.DependencyInjection Assembly : Silverback.Core.dll Syntax public static class SilverbackBuilderAddSubscriberExtensions Methods | Improve this doc View source AddScopedSubscriber(ISilverbackBuilder, Type, TypeSubscriptionOptions) Adds a scoped subscriber of the type specified in subscriberType to the Microsoft.Extensions.DependencyInjection.IServiceCollection . Declaration public static ISilverbackBuilder AddScopedSubscriber(this ISilverbackBuilder silverbackBuilder, Type subscriberType, TypeSubscriptionOptions options) Parameters Type Name Description ISilverbackBuilder silverbackBuilder The ISilverbackBuilder that references the Microsoft.Extensions.DependencyInjection.IServiceCollection to add the subscriber to. System.Type subscriberType The type of the subscriber to register and the implementation to use. TypeSubscriptionOptions options The TypeSubscriptionOptions . Returns Type Description ISilverbackBuilder The ISilverbackBuilder so that additional calls can be chained. | Improve this doc View source AddScopedSubscriber(ISilverbackBuilder, Type, Boolean) Adds a scoped subscriber of the type specified in subscriberType to the Microsoft.Extensions.DependencyInjection.IServiceCollection . Declaration public static ISilverbackBuilder AddScopedSubscriber(this ISilverbackBuilder silverbackBuilder, Type subscriberType, bool autoSubscribeAllPublicMethods = true) Parameters Type Name Description ISilverbackBuilder silverbackBuilder The ISilverbackBuilder that references the Microsoft.Extensions.DependencyInjection.IServiceCollection to add the subscriber to. System.Type subscriberType The type of the subscriber to register and the implementation to use. System.Boolean autoSubscribeAllPublicMethods A boolean value indicating whether all public methods of the specified type have to be automatically subscribed. When set to false only the methods decorated with the SubscribeAttribute are subscribed. Returns Type Description ISilverbackBuilder The ISilverbackBuilder so that additional calls can be chained. | Improve this doc View source AddScopedSubscriber(ISilverbackBuilder, Type, Func<IServiceProvider, Object>, TypeSubscriptionOptions) Adds a scoped subscriber of the type specified in subscriberType with a factory specified in implementationFactory to the Microsoft.Extensions.DependencyInjection.IServiceCollection . Declaration public static ISilverbackBuilder AddScopedSubscriber(this ISilverbackBuilder silverbackBuilder, Type subscriberType, Func<IServiceProvider, object> implementationFactory, TypeSubscriptionOptions options) Parameters Type Name Description ISilverbackBuilder silverbackBuilder The ISilverbackBuilder that references the Microsoft.Extensions.DependencyInjection.IServiceCollection to add the subscriber to. System.Type subscriberType The type of the subscriber to register. System.Func < System.IServiceProvider , System.Object > implementationFactory The factory that creates the service. TypeSubscriptionOptions options The TypeSubscriptionOptions . Returns Type Description ISilverbackBuilder The ISilverbackBuilder so that additional calls can be chained. | Improve this doc View source AddScopedSubscriber(ISilverbackBuilder, Type, Func<IServiceProvider, Object>, Boolean) Adds a scoped subscriber of the type specified in subscriberType with a factory specified in implementationFactory to the Microsoft.Extensions.DependencyInjection.IServiceCollection . Declaration public static ISilverbackBuilder AddScopedSubscriber(this ISilverbackBuilder silverbackBuilder, Type subscriberType, Func<IServiceProvider, object> implementationFactory, bool autoSubscribeAllPublicMethods = true) Parameters Type Name Description ISilverbackBuilder silverbackBuilder The ISilverbackBuilder that references the Microsoft.Extensions.DependencyInjection.IServiceCollection to add the subscriber to. System.Type subscriberType The type of the subscriber to register. System.Func < System.IServiceProvider , System.Object > implementationFactory The factory that creates the service. System.Boolean autoSubscribeAllPublicMethods A boolean value indicating whether all public methods of the specified type have to be automatically subscribed. When set to false only the methods decorated with the SubscribeAttribute are subscribed. Returns Type Description ISilverbackBuilder The ISilverbackBuilder so that additional calls can be chained. | Improve this doc View source AddScopedSubscriber<TSubscriber>(ISilverbackBuilder, TypeSubscriptionOptions) Adds a scoped subscriber of the type specified in TSubscriber to the Microsoft.Extensions.DependencyInjection.IServiceCollection . Declaration public static ISilverbackBuilder AddScopedSubscriber<TSubscriber>(this ISilverbackBuilder silverbackBuilder, TypeSubscriptionOptions options) where TSubscriber : class Parameters Type Name Description ISilverbackBuilder silverbackBuilder The ISilverbackBuilder that references the Microsoft.Extensions.DependencyInjection.IServiceCollection to add the subscriber to. TypeSubscriptionOptions options The TypeSubscriptionOptions . Returns Type Description ISilverbackBuilder The ISilverbackBuilder so that additional calls can be chained. Type Parameters Name Description TSubscriber The type of the subscriber to add. | Improve this doc View source AddScopedSubscriber<TSubscriber>(ISilverbackBuilder, Boolean) Adds a scoped subscriber of the type specified in TSubscriber to the Microsoft.Extensions.DependencyInjection.IServiceCollection . Declaration public static ISilverbackBuilder AddScopedSubscriber<TSubscriber>(this ISilverbackBuilder silverbackBuilder, bool autoSubscribeAllPublicMethods = true) where TSubscriber : class Parameters Type Name Description ISilverbackBuilder silverbackBuilder The ISilverbackBuilder that references the Microsoft.Extensions.DependencyInjection.IServiceCollection to add the subscriber to. System.Boolean autoSubscribeAllPublicMethods A boolean value indicating whether all public methods of the specified type have to be automatically subscribed. When set to false only the methods decorated with the SubscribeAttribute are subscribed. Returns Type Description ISilverbackBuilder The ISilverbackBuilder so that additional calls can be chained. Type Parameters Name Description TSubscriber The type of the subscriber to add. | Improve this doc View source AddScopedSubscriber<TSubscriber>(ISilverbackBuilder, Func<IServiceProvider, TSubscriber>, TypeSubscriptionOptions) Adds a scoped subscriber of the type specified in TSubscriber with a factory specified in implementationFactory to the Microsoft.Extensions.DependencyInjection.IServiceCollection . Declaration public static ISilverbackBuilder AddScopedSubscriber<TSubscriber>(this ISilverbackBuilder silverbackBuilder, Func<IServiceProvider, TSubscriber> implementationFactory, TypeSubscriptionOptions options) where TSubscriber : class Parameters Type Name Description ISilverbackBuilder silverbackBuilder The ISilverbackBuilder that references the Microsoft.Extensions.DependencyInjection.IServiceCollection to add the subscriber to. System.Func < System.IServiceProvider , TSubscriber> implementationFactory The factory that creates the service. TypeSubscriptionOptions options The TypeSubscriptionOptions . Returns Type Description ISilverbackBuilder The ISilverbackBuilder so that additional calls can be chained. Type Parameters Name Description TSubscriber The type of the subscriber to add. | Improve this doc View source AddScopedSubscriber<TSubscriber>(ISilverbackBuilder, Func<IServiceProvider, TSubscriber>, Boolean) Adds a scoped subscriber of the type specified in TSubscriber with a factory specified in implementationFactory to the Microsoft.Extensions.DependencyInjection.IServiceCollection . Declaration public static ISilverbackBuilder AddScopedSubscriber<TSubscriber>(this ISilverbackBuilder silverbackBuilder, Func<IServiceProvider, TSubscriber> implementationFactory, bool autoSubscribeAllPublicMethods = true) where TSubscriber : class Parameters Type Name Description ISilverbackBuilder silverbackBuilder The ISilverbackBuilder that references the Microsoft.Extensions.DependencyInjection.IServiceCollection to add the subscriber to. System.Func < System.IServiceProvider , TSubscriber> implementationFactory The factory that creates the service. System.Boolean autoSubscribeAllPublicMethods A boolean value indicating whether all public methods of the specified type have to be automatically subscribed. When set to false only the methods decorated with the SubscribeAttribute are subscribed. Returns Type Description ISilverbackBuilder The ISilverbackBuilder so that additional calls can be chained. Type Parameters Name Description TSubscriber The type of the subscriber to add. | Improve this doc View source AddSingletonSubscriber(ISilverbackBuilder, Type, TypeSubscriptionOptions) Adds a singleton subscriber of the type specified in subscriberType to the Microsoft.Extensions.DependencyInjection.IServiceCollection . Declaration public static ISilverbackBuilder AddSingletonSubscriber(this ISilverbackBuilder silverbackBuilder, Type subscriberType, TypeSubscriptionOptions options) Parameters Type Name Description ISilverbackBuilder silverbackBuilder The ISilverbackBuilder that references the Microsoft.Extensions.DependencyInjection.IServiceCollection to add the subscriber to. System.Type subscriberType The type of the subscriber to register and the implementation to use. TypeSubscriptionOptions options The TypeSubscriptionOptions . Returns Type Description ISilverbackBuilder The ISilverbackBuilder so that additional calls can be chained. | Improve this doc View source AddSingletonSubscriber(ISilverbackBuilder, Type, Boolean) Adds a singleton subscriber of the type specified in subscriberType to the Microsoft.Extensions.DependencyInjection.IServiceCollection . Declaration public static ISilverbackBuilder AddSingletonSubscriber(this ISilverbackBuilder silverbackBuilder, Type subscriberType, bool autoSubscribeAllPublicMethods = true) Parameters Type Name Description ISilverbackBuilder silverbackBuilder The ISilverbackBuilder that references the Microsoft.Extensions.DependencyInjection.IServiceCollection to add the subscriber to. System.Type subscriberType The type of the subscriber to register and the implementation to use. System.Boolean autoSubscribeAllPublicMethods A boolean value indicating whether all public methods of the specified type have to be automatically subscribed. When set to false only the methods decorated with the SubscribeAttribute are subscribed. Returns Type Description ISilverbackBuilder The ISilverbackBuilder so that additional calls can be chained. | Improve this doc View source AddSingletonSubscriber(ISilverbackBuilder, Type, Func<IServiceProvider, Object>, TypeSubscriptionOptions) Adds a singleton subscriber of the type specified in subscriberType with a factory specified in implementationFactory to the Microsoft.Extensions.DependencyInjection.IServiceCollection . Declaration public static ISilverbackBuilder AddSingletonSubscriber(this ISilverbackBuilder silverbackBuilder, Type subscriberType, Func<IServiceProvider, object> implementationFactory, TypeSubscriptionOptions options) Parameters Type Name Description ISilverbackBuilder silverbackBuilder The ISilverbackBuilder that references the Microsoft.Extensions.DependencyInjection.IServiceCollection to add the subscriber to. System.Type subscriberType The type of the subscriber to register. System.Func < System.IServiceProvider , System.Object > implementationFactory The factory that creates the service. TypeSubscriptionOptions options The TypeSubscriptionOptions . Returns Type Description ISilverbackBuilder The ISilverbackBuilder so that additional calls can be chained. | Improve this doc View source AddSingletonSubscriber(ISilverbackBuilder, Type, Func<IServiceProvider, Object>, Boolean) Adds a singleton subscriber of the type specified in subscriberType with a factory specified in implementationFactory to the Microsoft.Extensions.DependencyInjection.IServiceCollection . Declaration public static ISilverbackBuilder AddSingletonSubscriber(this ISilverbackBuilder silverbackBuilder, Type subscriberType, Func<IServiceProvider, object> implementationFactory, bool autoSubscribeAllPublicMethods = true) Parameters Type Name Description ISilverbackBuilder silverbackBuilder The ISilverbackBuilder that references the Microsoft.Extensions.DependencyInjection.IServiceCollection to add the subscriber to. System.Type subscriberType The type of the subscriber to register. System.Func < System.IServiceProvider , System.Object > implementationFactory The factory that creates the service. System.Boolean autoSubscribeAllPublicMethods A boolean value indicating whether all public methods of the specified type have to be automatically subscribed. When set to false only the methods decorated with the SubscribeAttribute are subscribed. Returns Type Description ISilverbackBuilder The ISilverbackBuilder so that additional calls can be chained. | Improve this doc View source AddSingletonSubscriber(ISilverbackBuilder, Type, Object, TypeSubscriptionOptions) Adds a singleton subscriber of the type specified in subscriberType with an instance specified in implementationInstance to the Microsoft.Extensions.DependencyInjection.IServiceCollection . Declaration public static ISilverbackBuilder AddSingletonSubscriber(this ISilverbackBuilder silverbackBuilder, Type subscriberType, object implementationInstance, TypeSubscriptionOptions options) Parameters Type Name Description ISilverbackBuilder silverbackBuilder The ISilverbackBuilder that references the Microsoft.Extensions.DependencyInjection.IServiceCollection to add the subscriber to. System.Type subscriberType The type of the subscriber to register. System.Object implementationInstance The instance of the service. TypeSubscriptionOptions options The TypeSubscriptionOptions . Returns Type Description ISilverbackBuilder The ISilverbackBuilder so that additional calls can be chained. | Improve this doc View source AddSingletonSubscriber(ISilverbackBuilder, Type, Object, Boolean) Adds a singleton subscriber of the type specified in subscriberType with an instance specified in implementationInstance to the Microsoft.Extensions.DependencyInjection.IServiceCollection . Declaration public static ISilverbackBuilder AddSingletonSubscriber(this ISilverbackBuilder silverbackBuilder, Type subscriberType, object implementationInstance, bool autoSubscribeAllPublicMethods = true) Parameters Type Name Description ISilverbackBuilder silverbackBuilder The ISilverbackBuilder that references the Microsoft.Extensions.DependencyInjection.IServiceCollection to add the subscriber to. System.Type subscriberType The type of the subscriber to register. System.Object implementationInstance The instance of the service. System.Boolean autoSubscribeAllPublicMethods A boolean value indicating whether all public methods of the specified type have to be automatically subscribed. When set to false only the methods decorated with the SubscribeAttribute are subscribed. Returns Type Description ISilverbackBuilder The ISilverbackBuilder so that additional calls can be chained. | Improve this doc View source AddSingletonSubscriber<TSubscriber>(ISilverbackBuilder, TSubscriber, TypeSubscriptionOptions) Adds a singleton subscriber of the type specified in TSubscriber with an instance specified in implementationInstance to the Microsoft.Extensions.DependencyInjection.IServiceCollection . Declaration public static ISilverbackBuilder AddSingletonSubscriber<TSubscriber>(this ISilverbackBuilder silverbackBuilder, TSubscriber implementationInstance, TypeSubscriptionOptions options) where TSubscriber : class Parameters Type Name Description ISilverbackBuilder silverbackBuilder The ISilverbackBuilder that references the Microsoft.Extensions.DependencyInjection.IServiceCollection to add the subscriber to. TSubscriber implementationInstance The instance of the service. TypeSubscriptionOptions options The TypeSubscriptionOptions . Returns Type Description ISilverbackBuilder The ISilverbackBuilder so that additional calls can be chained. Type Parameters Name Description TSubscriber The type of the subscriber to register. | Improve this doc View source AddSingletonSubscriber<TSubscriber>(ISilverbackBuilder, TSubscriber, Boolean) Adds a singleton subscriber of the type specified in TSubscriber with an instance specified in implementationInstance to the Microsoft.Extensions.DependencyInjection.IServiceCollection . Declaration public static ISilverbackBuilder AddSingletonSubscriber<TSubscriber>(this ISilverbackBuilder silverbackBuilder, TSubscriber implementationInstance, bool autoSubscribeAllPublicMethods = true) where TSubscriber : class Parameters Type Name Description ISilverbackBuilder silverbackBuilder The ISilverbackBuilder that references the Microsoft.Extensions.DependencyInjection.IServiceCollection to add the subscriber to. TSubscriber implementationInstance The instance of the service. System.Boolean autoSubscribeAllPublicMethods A boolean value indicating whether all public methods of the specified type have to be automatically subscribed. When set to false only the methods decorated with the SubscribeAttribute are subscribed. Returns Type Description ISilverbackBuilder The ISilverbackBuilder so that additional calls can be chained. Type Parameters Name Description TSubscriber The type of the subscriber to register. | Improve this doc View source AddSingletonSubscriber<TSubscriber>(ISilverbackBuilder, TypeSubscriptionOptions) Adds a singleton subscriber of the type specified in TSubscriber to this ISilverbackBuilder . Declaration public static ISilverbackBuilder AddSingletonSubscriber<TSubscriber>(this ISilverbackBuilder silverbackBuilder, TypeSubscriptionOptions options) where TSubscriber : class Parameters Type Name Description ISilverbackBuilder silverbackBuilder The ISilverbackBuilder that references the Microsoft.Extensions.DependencyInjection.IServiceCollection to add the subscriber to. TypeSubscriptionOptions options The TypeSubscriptionOptions . Returns Type Description ISilverbackBuilder The ISilverbackBuilder so that additional calls can be chained. Type Parameters Name Description TSubscriber The type of the subscriber to add. | Improve this doc View source AddSingletonSubscriber<TSubscriber>(ISilverbackBuilder, Boolean) Adds a singleton subscriber of the type specified in TSubscriber to this ISilverbackBuilder . Declaration public static ISilverbackBuilder AddSingletonSubscriber<TSubscriber>(this ISilverbackBuilder silverbackBuilder, bool autoSubscribeAllPublicMethods = true) where TSubscriber : class Parameters Type Name Description ISilverbackBuilder silverbackBuilder The ISilverbackBuilder that references the Microsoft.Extensions.DependencyInjection.IServiceCollection to add the subscriber to. System.Boolean autoSubscribeAllPublicMethods A boolean value indicating whether all public methods of the specified type have to be automatically subscribed. When set to false only the methods decorated with the SubscribeAttribute are subscribed. Returns Type Description ISilverbackBuilder The ISilverbackBuilder so that additional calls can be chained. Type Parameters Name Description TSubscriber The type of the subscriber to add. | Improve this doc View source AddSingletonSubscriber<TSubscriber>(ISilverbackBuilder, Func<IServiceProvider, TSubscriber>, TypeSubscriptionOptions) Adds a singleton subscriber of the type specified in TSubscriber with a factory specified in implementationFactory to the Microsoft.Extensions.DependencyInjection.IServiceCollection . Declaration public static ISilverbackBuilder AddSingletonSubscriber<TSubscriber>(this ISilverbackBuilder silverbackBuilder, Func<IServiceProvider, TSubscriber> implementationFactory, TypeSubscriptionOptions options) where TSubscriber : class Parameters Type Name Description ISilverbackBuilder silverbackBuilder The ISilverbackBuilder that references the Microsoft.Extensions.DependencyInjection.IServiceCollection to add the subscriber to. System.Func < System.IServiceProvider , TSubscriber> implementationFactory The factory that creates the service. TypeSubscriptionOptions options The TypeSubscriptionOptions . Returns Type Description ISilverbackBuilder The ISilverbackBuilder so that additional calls can be chained. Type Parameters Name Description TSubscriber The type of the subscriber to add. | Improve this doc View source AddSingletonSubscriber<TSubscriber>(ISilverbackBuilder, Func<IServiceProvider, TSubscriber>, Boolean) Adds a singleton subscriber of the type specified in TSubscriber with a factory specified in implementationFactory to the Microsoft.Extensions.DependencyInjection.IServiceCollection . Declaration public static ISilverbackBuilder AddSingletonSubscriber<TSubscriber>(this ISilverbackBuilder silverbackBuilder, Func<IServiceProvider, TSubscriber> implementationFactory, bool autoSubscribeAllPublicMethods = true) where TSubscriber : class Parameters Type Name Description ISilverbackBuilder silverbackBuilder The ISilverbackBuilder that references the Microsoft.Extensions.DependencyInjection.IServiceCollection to add the subscriber to. System.Func < System.IServiceProvider , TSubscriber> implementationFactory The factory that creates the service. System.Boolean autoSubscribeAllPublicMethods A boolean value indicating whether all public methods of the specified type have to be automatically subscribed. When set to false only the methods decorated with the SubscribeAttribute are subscribed. Returns Type Description ISilverbackBuilder The ISilverbackBuilder so that additional calls can be chained. Type Parameters Name Description TSubscriber The type of the subscriber to add. | Improve this doc View source AddSubscribers<TSubscriber>(ISilverbackBuilder, TypeSubscriptionOptions) Registers the base type to be resolved as subscriber. The actual types have to be added to the Microsoft.Extensions.DependencyInjection.IServiceCollection separately. Declaration public static ISilverbackBuilder AddSubscribers<TSubscriber>(this ISilverbackBuilder silverbackBuilder, TypeSubscriptionOptions options) where TSubscriber : class Parameters Type Name Description ISilverbackBuilder silverbackBuilder The ISilverbackBuilder that references the Microsoft.Extensions.DependencyInjection.IServiceCollection to add the subscriber to. TypeSubscriptionOptions options The TypeSubscriptionOptions . Returns Type Description ISilverbackBuilder The ISilverbackBuilder so that additional calls can be chained. Type Parameters Name Description TSubscriber The base type of the subscribers (class or interface). Remarks The subscribers will have to be registered twice (with the base type and the type itself: .AddScoped<BaseType, Subscriber>.AddScoped<Subscriber> ). | Improve this doc View source AddSubscribers<TSubscriber>(ISilverbackBuilder, Boolean) Registers the base type to be resolved as subscriber. The actual types have to be added to the Microsoft.Extensions.DependencyInjection.IServiceCollection separately. Declaration public static ISilverbackBuilder AddSubscribers<TSubscriber>(this ISilverbackBuilder silverbackBuilder, bool autoSubscribeAllPublicMethods = true) where TSubscriber : class Parameters Type Name Description ISilverbackBuilder silverbackBuilder The ISilverbackBuilder that references the Microsoft.Extensions.DependencyInjection.IServiceCollection to add the subscriber to. System.Boolean autoSubscribeAllPublicMethods A boolean value indicating whether all public methods of the specified type have to be automatically subscribed. When set to false only the methods decorated with the SubscribeAttribute are subscribed. Returns Type Description ISilverbackBuilder The ISilverbackBuilder so that additional calls can be chained. Type Parameters Name Description TSubscriber The base type of the subscribers (class or interface). Remarks The subscribers will have to be registered twice (with the base type and the type itself: .AddScoped<BaseType, Subscriber>.AddScoped<Subscriber> ). | Improve this doc View source AddTransientSubscriber(ISilverbackBuilder, Type, TypeSubscriptionOptions) Adds a scoped subscriber of the type specified in subscriberType to the Microsoft.Extensions.DependencyInjection.IServiceCollection . Declaration public static ISilverbackBuilder AddTransientSubscriber(this ISilverbackBuilder silverbackBuilder, Type subscriberType, TypeSubscriptionOptions options) Parameters Type Name Description ISilverbackBuilder silverbackBuilder The ISilverbackBuilder that references the Microsoft.Extensions.DependencyInjection.IServiceCollection to add the subscriber to. System.Type subscriberType The type of the subscriber to register and the implementation to use. TypeSubscriptionOptions options The TypeSubscriptionOptions . Returns Type Description ISilverbackBuilder The ISilverbackBuilder so that additional calls can be chained. | Improve this doc View source AddTransientSubscriber(ISilverbackBuilder, Type, Boolean) Adds a scoped subscriber of the type specified in subscriberType to the Microsoft.Extensions.DependencyInjection.IServiceCollection . Declaration public static ISilverbackBuilder AddTransientSubscriber(this ISilverbackBuilder silverbackBuilder, Type subscriberType, bool autoSubscribeAllPublicMethods = true) Parameters Type Name Description ISilverbackBuilder silverbackBuilder The ISilverbackBuilder that references the Microsoft.Extensions.DependencyInjection.IServiceCollection to add the subscriber to. System.Type subscriberType The type of the subscriber to register and the implementation to use. System.Boolean autoSubscribeAllPublicMethods A boolean value indicating whether all public methods of the specified type have to be automatically subscribed. When set to false only the methods decorated with the SubscribeAttribute are subscribed. Returns Type Description ISilverbackBuilder The ISilverbackBuilder so that additional calls can be chained. | Improve this doc View source AddTransientSubscriber(ISilverbackBuilder, Type, Func<IServiceProvider, Object>, TypeSubscriptionOptions) Adds a scoped subscriber of the type specified in subscriberType with a factory specified in implementationFactory to the Microsoft.Extensions.DependencyInjection.IServiceCollection . Declaration public static ISilverbackBuilder AddTransientSubscriber(this ISilverbackBuilder silverbackBuilder, Type subscriberType, Func<IServiceProvider, object> implementationFactory, TypeSubscriptionOptions options) Parameters Type Name Description ISilverbackBuilder silverbackBuilder The ISilverbackBuilder that references the Microsoft.Extensions.DependencyInjection.IServiceCollection to add the subscriber to. System.Type subscriberType The type of the subscriber to register. System.Func < System.IServiceProvider , System.Object > implementationFactory The factory that creates the service. TypeSubscriptionOptions options The TypeSubscriptionOptions . Returns Type Description ISilverbackBuilder The ISilverbackBuilder so that additional calls can be chained. | Improve this doc View source AddTransientSubscriber(ISilverbackBuilder, Type, Func<IServiceProvider, Object>, Boolean) Adds a scoped subscriber of the type specified in subscriberType with a factory specified in implementationFactory to the Microsoft.Extensions.DependencyInjection.IServiceCollection . Declaration public static ISilverbackBuilder AddTransientSubscriber(this ISilverbackBuilder silverbackBuilder, Type subscriberType, Func<IServiceProvider, object> implementationFactory, bool autoSubscribeAllPublicMethods = true) Parameters Type Name Description ISilverbackBuilder silverbackBuilder The ISilverbackBuilder that references the Microsoft.Extensions.DependencyInjection.IServiceCollection to add the subscriber to. System.Type subscriberType The type of the subscriber to register. System.Func < System.IServiceProvider , System.Object > implementationFactory The factory that creates the service. System.Boolean autoSubscribeAllPublicMethods A boolean value indicating whether all public methods of the specified type have to be automatically subscribed. When set to false only the methods decorated with the SubscribeAttribute are subscribed. Returns Type Description ISilverbackBuilder The ISilverbackBuilder so that additional calls can be chained. | Improve this doc View source AddTransientSubscriber<TSubscriber>(ISilverbackBuilder, TypeSubscriptionOptions) Adds a scoped subscriber of the type specified in TSubscriber to the Microsoft.Extensions.DependencyInjection.IServiceCollection . Declaration public static ISilverbackBuilder AddTransientSubscriber<TSubscriber>(this ISilverbackBuilder silverbackBuilder, TypeSubscriptionOptions options) where TSubscriber : class Parameters Type Name Description ISilverbackBuilder silverbackBuilder The ISilverbackBuilder that references the Microsoft.Extensions.DependencyInjection.IServiceCollection to add the subscriber to. TypeSubscriptionOptions options The TypeSubscriptionOptions . Returns Type Description ISilverbackBuilder The ISilverbackBuilder so that additional calls can be chained. Type Parameters Name Description TSubscriber The type of the subscriber to add. | Improve this doc View source AddTransientSubscriber<TSubscriber>(ISilverbackBuilder, Boolean) Adds a scoped subscriber of the type specified in TSubscriber to the Microsoft.Extensions.DependencyInjection.IServiceCollection . Declaration public static ISilverbackBuilder AddTransientSubscriber<TSubscriber>(this ISilverbackBuilder silverbackBuilder, bool autoSubscribeAllPublicMethods = true) where TSubscriber : class Parameters Type Name Description ISilverbackBuilder silverbackBuilder The ISilverbackBuilder that references the Microsoft.Extensions.DependencyInjection.IServiceCollection to add the subscriber to. System.Boolean autoSubscribeAllPublicMethods A boolean value indicating whether all public methods of the specified type have to be automatically subscribed. When set to false only the methods decorated with the SubscribeAttribute are subscribed. Returns Type Description ISilverbackBuilder The ISilverbackBuilder so that additional calls can be chained. Type Parameters Name Description TSubscriber The type of the subscriber to add. | Improve this doc View source AddTransientSubscriber<TSubscriber>(ISilverbackBuilder, Func<IServiceProvider, TSubscriber>, TypeSubscriptionOptions) Adds a scoped subscriber of the type specified in TSubscriber with a factory specified in implementationFactory to the Microsoft.Extensions.DependencyInjection.IServiceCollection . Declaration public static ISilverbackBuilder AddTransientSubscriber<TSubscriber>(this ISilverbackBuilder silverbackBuilder, Func<IServiceProvider, TSubscriber> implementationFactory, TypeSubscriptionOptions options) where TSubscriber : class Parameters Type Name Description ISilverbackBuilder silverbackBuilder The ISilverbackBuilder that references the Microsoft.Extensions.DependencyInjection.IServiceCollection to add the subscriber to. System.Func < System.IServiceProvider , TSubscriber> implementationFactory The factory that creates the service. TypeSubscriptionOptions options The TypeSubscriptionOptions . Returns Type Description ISilverbackBuilder The ISilverbackBuilder so that additional calls can be chained. Type Parameters Name Description TSubscriber The type of the subscriber to add. | Improve this doc View source AddTransientSubscriber<TSubscriber>(ISilverbackBuilder, Func<IServiceProvider, TSubscriber>, Boolean) Adds a scoped subscriber of the type specified in TSubscriber with a factory specified in implementationFactory to the Microsoft.Extensions.DependencyInjection.IServiceCollection . Declaration public static ISilverbackBuilder AddTransientSubscriber<TSubscriber>(this ISilverbackBuilder silverbackBuilder, Func<IServiceProvider, TSubscriber> implementationFactory, bool autoSubscribeAllPublicMethods = true) where TSubscriber : class Parameters Type Name Description ISilverbackBuilder silverbackBuilder The ISilverbackBuilder that references the Microsoft.Extensions.DependencyInjection.IServiceCollection to add the subscriber to. System.Func < System.IServiceProvider , TSubscriber> implementationFactory The factory that creates the service. System.Boolean autoSubscribeAllPublicMethods A boolean value indicating whether all public methods of the specified type have to be automatically subscribed. When set to false only the methods decorated with the SubscribeAttribute are subscribed. Returns Type Description ISilverbackBuilder The ISilverbackBuilder so that additional calls can be chained. Type Parameters Name Description TSubscriber The type of the subscriber to add."
  },
  "api/Microsoft.Extensions.DependencyInjection.SilverbackBuilderUseDbContextExtensions.html": {
    "href": "api/Microsoft.Extensions.DependencyInjection.SilverbackBuilderUseDbContextExtensions.html",
    "title": "Class SilverbackBuilderUseDbContextExtensions | Silverback",
    "keywords": "Class SilverbackBuilderUseDbContextExtensions Contains the UseDbContext extension for the ISilverbackBuilder . Inheritance System.Object SilverbackBuilderUseDbContextExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Microsoft.Extensions.DependencyInjection Assembly : Silverback.Core.EFCore30.dll Syntax public static class SilverbackBuilderUseDbContextExtensions Methods | Improve this doc View source UseDbContext<TDbContext>(ISilverbackBuilder) Registers the specified Microsoft.EntityFrameworkCore.DbContext to be used as underlying storage for the services requiring it. Declaration public static ISilverbackBuilder UseDbContext<TDbContext>(this ISilverbackBuilder builder) where TDbContext : DbContext Parameters Type Name Description ISilverbackBuilder builder The ISilverbackBuilder to add the Microsoft.EntityFrameworkCore.DbContext to. Returns Type Description ISilverbackBuilder The ISilverbackBuilder so that additional calls can be chained. Type Parameters Name Description TDbContext The type of the Microsoft.EntityFrameworkCore.DbContext to be used."
  },
  "api/Microsoft.Extensions.DependencyInjection.SilverbackBuilderUseMockedKafkaExtensions.html": {
    "href": "api/Microsoft.Extensions.DependencyInjection.SilverbackBuilderUseMockedKafkaExtensions.html",
    "title": "Class SilverbackBuilderUseMockedKafkaExtensions | Silverback",
    "keywords": "Class SilverbackBuilderUseMockedKafkaExtensions Adds the UseMockedKafka method to the ISilverbackBuilder . Inheritance System.Object SilverbackBuilderUseMockedKafkaExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Microsoft.Extensions.DependencyInjection Assembly : Silverback.Integration.Kafka.Testing.dll Syntax public static class SilverbackBuilderUseMockedKafkaExtensions Methods | Improve this doc View source UseMockedKafka(ISilverbackBuilder, Action<IMockedKafkaOptionsBuilder>) Replaces the Kafka connectivity based on Confluent.Kafka with a mocked in-memory message broker that more or less replicates the Kafka behavior. Declaration public static ISilverbackBuilder UseMockedKafka(this ISilverbackBuilder builder, Action<IMockedKafkaOptionsBuilder> optionsAction = null) Parameters Type Name Description ISilverbackBuilder builder The ISilverbackBuilder . System.Action < IMockedKafkaOptionsBuilder > optionsAction Configures the mock options. Returns Type Description ISilverbackBuilder The ISilverbackBuilder so that additional calls can be chained."
  },
  "api/Microsoft.Extensions.DependencyInjection.SilverbackBuilderUseMockedMqttExtensions.html": {
    "href": "api/Microsoft.Extensions.DependencyInjection.SilverbackBuilderUseMockedMqttExtensions.html",
    "title": "Class SilverbackBuilderUseMockedMqttExtensions | Silverback",
    "keywords": "Class SilverbackBuilderUseMockedMqttExtensions Adds the UseMockedMqtt method to the ISilverbackBuilder . Inheritance System.Object SilverbackBuilderUseMockedMqttExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Microsoft.Extensions.DependencyInjection Assembly : Silverback.Integration.MQTT.Testing.dll Syntax public static class SilverbackBuilderUseMockedMqttExtensions Methods | Improve this doc View source UseMockedMqtt(ISilverbackBuilder, Action<IMockedMqttOptionsBuilder>) Replaces the MQTT connectivity based on MQTTnet with a mocked in-memory message broker that more or less replicates the MQTT broker behavior. Declaration public static ISilverbackBuilder UseMockedMqtt(this ISilverbackBuilder builder, Action<IMockedMqttOptionsBuilder> optionsAction = null) Parameters Type Name Description ISilverbackBuilder builder The ISilverbackBuilder . System.Action < IMockedMqttOptionsBuilder > optionsAction Configures the mock options. Returns Type Description ISilverbackBuilder The ISilverbackBuilder so that additional calls can be chained."
  },
  "api/Microsoft.Extensions.DependencyInjection.SilverbackBuilderUseModelExtensions.html": {
    "href": "api/Microsoft.Extensions.DependencyInjection.SilverbackBuilderUseModelExtensions.html",
    "title": "Class SilverbackBuilderUseModelExtensions | Silverback",
    "keywords": "Class SilverbackBuilderUseModelExtensions Adds the UseModel method to the ISilverbackBuilder . Inheritance System.Object SilverbackBuilderUseModelExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Microsoft.Extensions.DependencyInjection Assembly : Silverback.Core.Model.dll Syntax public static class SilverbackBuilderUseModelExtensions Methods | Improve this doc View source UseModel(ISilverbackBuilder) Registers the default messages model from Silverback.Core.Model package and the specific publishers ( IEventPublisher , ICommandPublisher and IQueryPublisher ). Declaration public static ISilverbackBuilder UseModel(this ISilverbackBuilder builder) Parameters Type Name Description ISilverbackBuilder builder The ISilverbackBuilder to add the model types to. Returns Type Description ISilverbackBuilder The ISilverbackBuilder so that additional calls can be chained."
  },
  "api/Microsoft.Extensions.DependencyInjection.SilverbackBuilderWithLogLevelsExtensions.html": {
    "href": "api/Microsoft.Extensions.DependencyInjection.SilverbackBuilderWithLogLevelsExtensions.html",
    "title": "Class SilverbackBuilderWithLogLevelsExtensions | Silverback",
    "keywords": "Class SilverbackBuilderWithLogLevelsExtensions Adds the WithLogLevels method to the ISilverbackBuilder . Inheritance System.Object SilverbackBuilderWithLogLevelsExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Microsoft.Extensions.DependencyInjection Assembly : Silverback.Core.dll Syntax public static class SilverbackBuilderWithLogLevelsExtensions Methods | Improve this doc View source WithLogLevels(ISilverbackBuilder, Action<ILogLevelConfigurator>) Configures the log levels that should be used to log the standard Silverback events. Declaration public static ISilverbackBuilder WithLogLevels(this ISilverbackBuilder silverbackBuilder, Action<ILogLevelConfigurator> logLevelsConfigurationAction) Parameters Type Name Description ISilverbackBuilder silverbackBuilder The ISilverbackBuilder . System.Action < ILogLevelConfigurator > logLevelsConfigurationAction The log levels configuration action. Returns Type Description ISilverbackBuilder The ISilverbackBuilder so that additional calls can be chained."
  },
  "api/Silverback.Background.DbDistributedLockManager.html": {
    "href": "api/Silverback.Background.DbDistributedLockManager.html",
    "title": "Class DbDistributedLockManager | Silverback",
    "keywords": "Class DbDistributedLockManager Implements a lock mechanism that relies on a shared database table to synchronize different processes. Inheritance System.Object DbDistributedLockManager Implements IDistributedLockManager Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Silverback.Background Assembly : Silverback.Core.dll Syntax public class DbDistributedLockManager : IDistributedLockManager Constructors | Improve this doc View source DbDistributedLockManager(IServiceScopeFactory, ISilverbackLogger<DbDistributedLockManager>) Initializes a new instance of the DbDistributedLockManager class. Declaration public DbDistributedLockManager(IServiceScopeFactory serviceScopeFactory, ISilverbackLogger<DbDistributedLockManager> logger) Parameters Type Name Description Microsoft.Extensions.DependencyInjection.IServiceScopeFactory serviceScopeFactory The Microsoft.Extensions.DependencyInjection.IServiceScopeFactory used to resolve the scoped types. ISilverbackLogger < DbDistributedLockManager > logger The ISilverbackLogger . Methods | Improve this doc View source AcquireAsync(DistributedLockSettings, CancellationToken) Declaration public async Task<DistributedLock> AcquireAsync(DistributedLockSettings settings, CancellationToken cancellationToken = default(CancellationToken)) Parameters Type Name Description DistributedLockSettings settings System.Threading.CancellationToken cancellationToken Returns Type Description System.Threading.Tasks.Task < DistributedLock > | Improve this doc View source CheckIsStillLockedAsync(DistributedLockSettings) Declaration public async Task<bool> CheckIsStillLockedAsync(DistributedLockSettings settings) Parameters Type Name Description DistributedLockSettings settings Returns Type Description System.Threading.Tasks.Task < System.Boolean > | Improve this doc View source ReleaseAsync(DistributedLockSettings) Declaration public async Task ReleaseAsync(DistributedLockSettings settings) Parameters Type Name Description DistributedLockSettings settings Returns Type Description System.Threading.Tasks.Task | Improve this doc View source SendHeartbeatAsync(DistributedLockSettings) Declaration public async Task<bool> SendHeartbeatAsync(DistributedLockSettings settings) Parameters Type Name Description DistributedLockSettings settings Returns Type Description System.Threading.Tasks.Task < System.Boolean > Implements IDistributedLockManager"
  },
  "api/Silverback.Background.DistributedBackgroundService.html": {
    "href": "api/Silverback.Background.DistributedBackgroundService.html",
    "title": "Class DistributedBackgroundService | Silverback",
    "keywords": "Class DistributedBackgroundService Extends the Microsoft.Extensions.Hosting.BackgroundService adding a distributed lock mechanism to prevent concurrent executions. Inheritance System.Object Microsoft.Extensions.Hosting.BackgroundService DistributedBackgroundService RecurringDistributedBackgroundService Implements Microsoft.Extensions.Hosting.IHostedService System.IDisposable Inherited Members Microsoft.Extensions.Hosting.BackgroundService.StartAsync(System.Threading.CancellationToken) Microsoft.Extensions.Hosting.BackgroundService.StopAsync(System.Threading.CancellationToken) Microsoft.Extensions.Hosting.BackgroundService.Dispose() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Silverback.Background Assembly : Silverback.Core.dll Syntax public abstract class DistributedBackgroundService : BackgroundService, IHostedService, IDisposable Constructors | Improve this doc View source DistributedBackgroundService(DistributedLockSettings, IDistributedLockManager, ISilverbackLogger<DistributedBackgroundService>) Initializes a new instance of the DistributedBackgroundService class. Declaration protected DistributedBackgroundService(DistributedLockSettings distributedLockSettings, IDistributedLockManager distributedLockManager, ISilverbackLogger<DistributedBackgroundService> logger) Parameters Type Name Description DistributedLockSettings distributedLockSettings Customizes the lock mechanism settings. IDistributedLockManager distributedLockManager The IDistributedLockManager . ISilverbackLogger < DistributedBackgroundService > logger The ISilverbackLogger . | Improve this doc View source DistributedBackgroundService(IDistributedLockManager, ISilverbackLogger<DistributedBackgroundService>) Initializes a new instance of the DistributedBackgroundService class using the default settings for the lock mechanism. Declaration protected DistributedBackgroundService(IDistributedLockManager distributedLockManager, ISilverbackLogger<DistributedBackgroundService> logger) Parameters Type Name Description IDistributedLockManager distributedLockManager The IDistributedLockManager . ISilverbackLogger < DistributedBackgroundService > logger The ISilverbackLogger . Properties | Improve this doc View source Lock Gets the acquired DistributedLock . Declaration protected DistributedLock Lock { get; } Property Value Type Description DistributedLock Methods | Improve this doc View source ExecuteAsync(CancellationToken) Declaration protected override Task ExecuteAsync(CancellationToken stoppingToken) Parameters Type Name Description System.Threading.CancellationToken stoppingToken Returns Type Description System.Threading.Tasks.Task Overrides Microsoft.Extensions.Hosting.BackgroundService.ExecuteAsync(System.Threading.CancellationToken) | Improve this doc View source ExecuteLockedAsync(CancellationToken) This method is called when the Microsoft.Extensions.Hosting.IHostedService starts and the lock is acquired. The implementation should return a task that represents the lifetime of the long running operation(s) being performed. Declaration protected abstract Task ExecuteLockedAsync(CancellationToken stoppingToken) Parameters Type Name Description System.Threading.CancellationToken stoppingToken A System.Threading.CancellationToken to observe while waiting for the task to complete. Returns Type Description System.Threading.Tasks.Task A System.Threading.Tasks.Task that represents the long running operations. Implements Microsoft.Extensions.Hosting.IHostedService System.IDisposable"
  },
  "api/Silverback.Background.DistributedLock.html": {
    "href": "api/Silverback.Background.DistributedLock.html",
    "title": "Class DistributedLock | Silverback",
    "keywords": "Class DistributedLock Represents a lock that has been acquired through an IDistributedLockManager . Inheritance System.Object DistributedLock Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Silverback.Background Assembly : Silverback.Core.dll Syntax public class DistributedLock Constructors | Improve this doc View source DistributedLock(DistributedLockSettings, IDistributedLockManager) Initializes a new instance of the DistributedLock class. Declaration public DistributedLock(DistributedLockSettings settings, IDistributedLockManager lockManager) Parameters Type Name Description DistributedLockSettings settings Specifies all settings of the lock to be acquired. IDistributedLockManager lockManager The IDistributedLockManager that generated the lock and can be used to keep it alive and finally release it. Properties | Improve this doc View source Status Gets the lock status. Declaration public DistributedLockStatus Status { get; } Property Value Type Description DistributedLockStatus Methods | Improve this doc View source ReleaseAsync() Releases the lock. Declaration public async Task ReleaseAsync() Returns Type Description System.Threading.Tasks.Task A System.Threading.Tasks.Task representing the asynchronous operation. | Improve this doc View source RenewAsync(CancellationToken) Ensures that the lock is still valid, otherwise tries to re-acquire it. Declaration public async Task RenewAsync(CancellationToken cancellationToken = default(CancellationToken)) Parameters Type Name Description System.Threading.CancellationToken cancellationToken A System.Threading.CancellationToken to observe while waiting for the task to complete. Returns Type Description System.Threading.Tasks.Task A System.Threading.Tasks.Task representing the asynchronous operation."
  },
  "api/Silverback.Background.DistributedLockSettings.html": {
    "href": "api/Silverback.Background.DistributedLockSettings.html",
    "title": "Class DistributedLockSettings | Silverback",
    "keywords": "Class DistributedLockSettings The settings to be applied to the configured IDistributedLockManager . Inheritance System.Object DistributedLockSettings NullLockSettings Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Silverback.Background Assembly : Silverback.Core.dll Syntax public class DistributedLockSettings Constructors | Improve this doc View source DistributedLockSettings(String, String, Nullable<TimeSpan>, Nullable<TimeSpan>, Nullable<TimeSpan>, Nullable<TimeSpan>) Initializes a new instance of the DistributedLockSettings class. Declaration public DistributedLockSettings(string resourceName = \"\", string uniqueId = null, TimeSpan? acquireTimeout = null, TimeSpan? acquireRetryInterval = null, TimeSpan? heartbeatTimeout = null, TimeSpan? heartbeatInterval = null) Parameters Type Name Description System.String resourceName The name of the lock / the resource being locked. System.String uniqueId A unique identifier representing the entity trying to acquire the lock. Th default is a new System.Guid . System.Nullable < System.TimeSpan > acquireTimeout After the acquire timeout is expired the lock manager will abort the lock acquisition. The default is no timeout. System.Nullable < System.TimeSpan > acquireRetryInterval The interval at which the lock manager checks if a lock can be acquired for the specified resource. The default is 30 seconds. System.Nullable < System.TimeSpan > heartbeatTimeout After the heartbeat timeout is expired the lock will be considered released. The default is 1 minute. System.Nullable < System.TimeSpan > heartbeatInterval The interval at which the heartbeat has to be sent. The default is 1 second. Properties | Improve this doc View source AcquireRetryInterval Gets the interval at which the lock manager checks if a lock can be acquired for the specified resource. Declaration public TimeSpan AcquireRetryInterval { get; } Property Value Type Description System.TimeSpan | Improve this doc View source AcquireTimeout Gets the timeout after which the lock manager will abort the lock acquisition. Declaration public TimeSpan? AcquireTimeout { get; } Property Value Type Description System.Nullable < System.TimeSpan > | Improve this doc View source FailedHeartbeatsThreshold Gets the maximum number of heartbeats that can be failed to be sent before stopping. Declaration public int FailedHeartbeatsThreshold { get; } Property Value Type Description System.Int32 | Improve this doc View source HeartbeatInterval Gets the interval at which the heartbeat has to be sent. Declaration public TimeSpan HeartbeatInterval { get; } Property Value Type Description System.TimeSpan | Improve this doc View source HeartbeatTimeout Gets the timeout after which the lock will be considered released if no heartbeat is sent. Declaration public TimeSpan HeartbeatTimeout { get; } Property Value Type Description System.TimeSpan | Improve this doc View source NoLock Gets the DistributedLockSettings signaling that no lock is to be checked and acquired. Corresponds to an instance of NullLockSettings . Declaration public static DistributedLockSettings NoLock { get; } Property Value Type Description DistributedLockSettings | Improve this doc View source ResourceName Gets the name of the lock / the resource being locked. Declaration public string ResourceName { get; } Property Value Type Description System.String | Improve this doc View source UniqueId Gets a unique identifier representing the entity trying to acquire the lock. Declaration public string UniqueId { get; } Property Value Type Description System.String"
  },
  "api/Silverback.Background.DistributedLockStatus.html": {
    "href": "api/Silverback.Background.DistributedLockStatus.html",
    "title": "Enum DistributedLockStatus | Silverback",
    "keywords": "Enum DistributedLockStatus Specifies the current status of the DistributedLock . Namespace : Silverback.Background Assembly : Silverback.Core.dll Syntax public enum DistributedLockStatus Fields Name Description Acquired The lock has been acquired. Lost The previously acquired lock has been lost for some reason (such as failure to send the heartbeat). Released The lock has been released."
  },
  "api/Silverback.Background.html": {
    "href": "api/Silverback.Background.html",
    "title": "Namespace Silverback.Background | Silverback",
    "keywords": "Namespace Silverback.Background Classes DbDistributedLockManager Implements a lock mechanism that relies on a shared database table to synchronize different processes. DistributedBackgroundService Extends the Microsoft.Extensions.Hosting.BackgroundService adding a distributed lock mechanism to prevent concurrent executions. DistributedLock Represents a lock that has been acquired through an IDistributedLockManager . DistributedLockSettings The settings to be applied to the configured IDistributedLockManager . NullLockManager This implementation of IDistributedLockManager doesn't actually acquire nor check any lock. Is is used when the NullLockSettings are specified or no other IDistributedLockManager is registered. NullLockSettings Used to signal that no lock has to be acquired nor checked. RecurringDistributedBackgroundService Extends the DistributedBackgroundService calling the execute method at regular intervals. The distributed lock mechanism prevents concurrent executions. Interfaces IDistributedLockManager Implements a lock mechanism that relies on a shared persisted storage (such as a database) to synchronize different processes. Enums DistributedLockStatus Specifies the current status of the DistributedLock ."
  },
  "api/Silverback.Background.IDistributedLockManager.html": {
    "href": "api/Silverback.Background.IDistributedLockManager.html",
    "title": "Interface IDistributedLockManager | Silverback",
    "keywords": "Interface IDistributedLockManager Implements a lock mechanism that relies on a shared persisted storage (such as a database) to synchronize different processes. Namespace : Silverback.Background Assembly : Silverback.Core.dll Syntax public interface IDistributedLockManager Methods | Improve this doc View source AcquireAsync(DistributedLockSettings, CancellationToken) Acquires a new lock on the specified resource. Declaration Task<DistributedLock> AcquireAsync(DistributedLockSettings settings, CancellationToken cancellationToken = default(CancellationToken)) Parameters Type Name Description DistributedLockSettings settings Specifies all settings of the lock to be acquired. System.Threading.CancellationToken cancellationToken A System.Threading.CancellationToken to observe while waiting for the task to complete. Returns Type Description System.Threading.Tasks.Task < DistributedLock > A System.Threading.Tasks.Task<TResult> representing the asynchronous operation. The task result contains the acquired DistributedLock (or null if no lock was actually acquired). | Improve this doc View source CheckIsStillLockedAsync(DistributedLockSettings) Returns a boolean value indicating whether the specified lock is taken already. Declaration Task<bool> CheckIsStillLockedAsync(DistributedLockSettings settings) Parameters Type Name Description DistributedLockSettings settings Specifies the lock to be checked. Returns Type Description System.Threading.Tasks.Task < System.Boolean > A System.Threading.Tasks.Task<TResult> representing the asynchronous operation. The task result contains a boolean value indicating whether the lock is taken. | Improve this doc View source ReleaseAsync(DistributedLockSettings) Releases the lock. Declaration Task ReleaseAsync(DistributedLockSettings settings) Parameters Type Name Description DistributedLockSettings settings Specifies the lock to be released. Returns Type Description System.Threading.Tasks.Task A System.Threading.Tasks.Task representing the asynchronous operation. | Improve this doc View source SendHeartbeatAsync(DistributedLockSettings) Called periodically after the lock has been acquired to send an heartbeat that keeps the lock. Declaration Task<bool> SendHeartbeatAsync(DistributedLockSettings settings) Parameters Type Name Description DistributedLockSettings settings Specifies the lock to be refreshed. Returns Type Description System.Threading.Tasks.Task < System.Boolean > A System.Threading.Tasks.Task<TResult> representing the asynchronous operation. The task result contains a boolean value indicating whether the lock could be refreshed."
  },
  "api/Silverback.Background.NullLockManager.html": {
    "href": "api/Silverback.Background.NullLockManager.html",
    "title": "Class NullLockManager | Silverback",
    "keywords": "Class NullLockManager This implementation of IDistributedLockManager doesn't actually acquire nor check any lock. Is is used when the NullLockSettings are specified or no other IDistributedLockManager is registered. Inheritance System.Object NullLockManager Implements IDistributedLockManager Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Silverback.Background Assembly : Silverback.Core.dll Syntax public class NullLockManager : IDistributedLockManager Methods | Improve this doc View source AcquireAsync(DistributedLockSettings, CancellationToken) Declaration public Task<DistributedLock> AcquireAsync(DistributedLockSettings settings, CancellationToken cancellationToken = default(CancellationToken)) Parameters Type Name Description DistributedLockSettings settings System.Threading.CancellationToken cancellationToken Returns Type Description System.Threading.Tasks.Task < DistributedLock > | Improve this doc View source CheckIsStillLockedAsync(DistributedLockSettings) Declaration public Task<bool> CheckIsStillLockedAsync(DistributedLockSettings settings) Parameters Type Name Description DistributedLockSettings settings Returns Type Description System.Threading.Tasks.Task < System.Boolean > | Improve this doc View source ReleaseAsync(DistributedLockSettings) Declaration public Task ReleaseAsync(DistributedLockSettings settings) Parameters Type Name Description DistributedLockSettings settings Returns Type Description System.Threading.Tasks.Task | Improve this doc View source SendHeartbeatAsync(DistributedLockSettings) Declaration public Task<bool> SendHeartbeatAsync(DistributedLockSettings settings) Parameters Type Name Description DistributedLockSettings settings Returns Type Description System.Threading.Tasks.Task < System.Boolean > Implements IDistributedLockManager"
  },
  "api/Silverback.Background.NullLockSettings.html": {
    "href": "api/Silverback.Background.NullLockSettings.html",
    "title": "Class NullLockSettings | Silverback",
    "keywords": "Class NullLockSettings Used to signal that no lock has to be acquired nor checked. Inheritance System.Object DistributedLockSettings NullLockSettings Inherited Members DistributedLockSettings.NoLock DistributedLockSettings.UniqueId DistributedLockSettings.AcquireTimeout DistributedLockSettings.AcquireRetryInterval DistributedLockSettings.HeartbeatTimeout DistributedLockSettings.HeartbeatInterval DistributedLockSettings.FailedHeartbeatsThreshold DistributedLockSettings.ResourceName System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Silverback.Background Assembly : Silverback.Core.dll Syntax public class NullLockSettings : DistributedLockSettings Constructors | Improve this doc View source NullLockSettings() Initializes a new instance of the NullLockSettings class. Declaration public NullLockSettings()"
  },
  "api/Silverback.Background.RecurringDistributedBackgroundService.html": {
    "href": "api/Silverback.Background.RecurringDistributedBackgroundService.html",
    "title": "Class RecurringDistributedBackgroundService | Silverback",
    "keywords": "Class RecurringDistributedBackgroundService Extends the DistributedBackgroundService calling the execute method at regular intervals. The distributed lock mechanism prevents concurrent executions. Inheritance System.Object Microsoft.Extensions.Hosting.BackgroundService DistributedBackgroundService RecurringDistributedBackgroundService Implements Microsoft.Extensions.Hosting.IHostedService System.IDisposable Inherited Members DistributedBackgroundService.Lock DistributedBackgroundService.ExecuteAsync(CancellationToken) Microsoft.Extensions.Hosting.BackgroundService.StartAsync(System.Threading.CancellationToken) Microsoft.Extensions.Hosting.BackgroundService.StopAsync(System.Threading.CancellationToken) Microsoft.Extensions.Hosting.BackgroundService.Dispose() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Silverback.Background Assembly : Silverback.Core.dll Syntax public abstract class RecurringDistributedBackgroundService : DistributedBackgroundService, IHostedService, IDisposable Constructors | Improve this doc View source RecurringDistributedBackgroundService(TimeSpan, DistributedLockSettings, IDistributedLockManager, ISilverbackLogger<RecurringDistributedBackgroundService>) Initializes a new instance of the RecurringDistributedBackgroundService class. Declaration protected RecurringDistributedBackgroundService(TimeSpan interval, DistributedLockSettings distributedLockSettings, IDistributedLockManager distributedLockManager, ISilverbackLogger<RecurringDistributedBackgroundService> logger) Parameters Type Name Description System.TimeSpan interval The System.TimeSpan interval between each execution. DistributedLockSettings distributedLockSettings Customizes the lock mechanism settings. IDistributedLockManager distributedLockManager The IDistributedLockManager . ISilverbackLogger < RecurringDistributedBackgroundService > logger The ISilverbackLogger . | Improve this doc View source RecurringDistributedBackgroundService(TimeSpan, IDistributedLockManager, ISilverbackLogger<RecurringDistributedBackgroundService>) Initializes a new instance of the RecurringDistributedBackgroundService class using the default settings for the lock mechanism. Declaration protected RecurringDistributedBackgroundService(TimeSpan interval, IDistributedLockManager distributedLockManager, ISilverbackLogger<RecurringDistributedBackgroundService> logger) Parameters Type Name Description System.TimeSpan interval The interval between each execution. IDistributedLockManager distributedLockManager The IDistributedLockManager . ISilverbackLogger < RecurringDistributedBackgroundService > logger The ISilverbackLogger . Methods | Improve this doc View source ExecuteLockedAsync(CancellationToken) Declaration protected override async Task ExecuteLockedAsync(CancellationToken stoppingToken) Parameters Type Name Description System.Threading.CancellationToken stoppingToken Returns Type Description System.Threading.Tasks.Task Overrides DistributedBackgroundService.ExecuteLockedAsync(CancellationToken) | Improve this doc View source ExecuteRecurringAsync(CancellationToken) This method is called at regular intervals after the Microsoft.Extensions.Hosting.IHostedService starts and the lock is acquired. The implementation should return a task that represents the lifetime of the long running operation(s) being performed. Declaration protected abstract Task ExecuteRecurringAsync(CancellationToken stoppingToken) Parameters Type Name Description System.Threading.CancellationToken stoppingToken A System.Threading.CancellationToken to observe while waiting for the task to complete. Returns Type Description System.Threading.Tasks.Task A System.Threading.Tasks.Task that represents the long running operations. | Improve this doc View source Pause() Pauses the execution of the recurring task. Declaration public void Pause() | Improve this doc View source Resume() Resumes the execution of the previously paused recurring task. Declaration public void Resume() Implements Microsoft.Extensions.Hosting.IHostedService System.IDisposable"
  },
  "api/Silverback.Database.DatabaseTableNotFoundException.html": {
    "href": "api/Silverback.Database.DatabaseTableNotFoundException.html",
    "title": "Class DatabaseTableNotFoundException | Silverback",
    "keywords": "Class DatabaseTableNotFoundException The exception that is thrown when a required database table cannot be found via the configured data layer (e.g. Entity Framework Core). Inheritance System.Object System.Exception SilverbackException DatabaseTableNotFoundException Implements System.Runtime.Serialization.ISerializable Inherited Members System.Exception.GetBaseException() System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo, System.Runtime.Serialization.StreamingContext) System.Exception.GetType() System.Exception.ToString() System.Exception.Data System.Exception.HelpLink System.Exception.HResult System.Exception.InnerException System.Exception.Message System.Exception.Source System.Exception.StackTrace System.Exception.TargetSite System.Exception.SerializeObjectState System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Silverback.Database Assembly : Silverback.Core.dll Syntax [Serializable] public class DatabaseTableNotFoundException : SilverbackException, ISerializable Constructors | Improve this doc View source DatabaseTableNotFoundException() Initializes a new instance of the DatabaseTableNotFoundException class. Declaration public DatabaseTableNotFoundException() | Improve this doc View source DatabaseTableNotFoundException(SerializationInfo, StreamingContext) Initializes a new instance of the DatabaseTableNotFoundException class with the serialized data. Declaration protected DatabaseTableNotFoundException(SerializationInfo info, StreamingContext context) Parameters Type Name Description System.Runtime.Serialization.SerializationInfo info The System.Runtime.Serialization.SerializationInfo that holds the serialized object data about the exception being thrown. System.Runtime.Serialization.StreamingContext context The System.Runtime.Serialization.StreamingContext that contains contextual information about the source or destination. | Improve this doc View source DatabaseTableNotFoundException(String) Initializes a new instance of the DatabaseTableNotFoundException class with the specified message. Declaration public DatabaseTableNotFoundException(string message) Parameters Type Name Description System.String message The exception message. | Improve this doc View source DatabaseTableNotFoundException(String, Exception) Initializes a new instance of the DatabaseTableNotFoundException class with the specified message and inner exception. Declaration public DatabaseTableNotFoundException(string message, Exception innerException) Parameters Type Name Description System.String message The exception message. System.Exception innerException The inner exception. Implements System.Runtime.Serialization.ISerializable"
  },
  "api/Silverback.Database.EfCoreDbContext-1.html": {
    "href": "api/Silverback.Database.EfCoreDbContext-1.html",
    "title": "Class EfCoreDbContext<TDbContext> | Silverback",
    "keywords": "Class EfCoreDbContext<TDbContext> An implementation of IDbContext that works with Entity Framework Core. Inheritance System.Object EfCoreDbContext<TDbContext> Implements IDbContext Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Silverback.Database Assembly : Silverback.Core.EFCore30.dll Syntax public class EfCoreDbContext<TDbContext> : IDbContext where TDbContext : DbContext Type Parameters Name Description TDbContext The type of the underlying Microsoft.EntityFrameworkCore.DbContext . Constructors | Improve this doc View source EfCoreDbContext(TDbContext) Initializes a new instance of the EfCoreDbContext<TDbContext> class. Declaration public EfCoreDbContext(TDbContext dbContext) Parameters Type Name Description TDbContext dbContext The wrapped Microsoft.EntityFrameworkCore.DbContext . Methods | Improve this doc View source GetDbSet<TEntity>() Declaration public IDbSet<TEntity> GetDbSet<TEntity>() where TEntity : class Returns Type Description IDbSet <TEntity> Type Parameters Name Description TEntity | Improve this doc View source SaveChanges() Declaration public void SaveChanges() | Improve this doc View source SaveChangesAsync() Declaration public Task SaveChangesAsync() Returns Type Description System.Threading.Tasks.Task Implements IDbContext"
  },
  "api/Silverback.Database.EfCoreDbSet-1.html": {
    "href": "api/Silverback.Database.EfCoreDbSet-1.html",
    "title": "Class EfCoreDbSet<TEntity> | Silverback",
    "keywords": "Class EfCoreDbSet<TEntity> An implementation of IDbSet<TEntity> that works with Entity Framework Core. Inheritance System.Object EfCoreDbSet<TEntity> Implements IDbSet <TEntity> Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Silverback.Database Assembly : Silverback.Core.EFCore30.dll Syntax public class EfCoreDbSet<TEntity> : IDbSet<TEntity> where TEntity : class Type Parameters Name Description TEntity The type of the entity being stored in this set. Constructors | Improve this doc View source EfCoreDbSet(DbSet<TEntity>) Initializes a new instance of the EfCoreDbSet<TEntity> class. Declaration public EfCoreDbSet(DbSet<TEntity> dbSet) Parameters Type Name Description Microsoft.EntityFrameworkCore.DbSet <TEntity> dbSet The underlying Microsoft.EntityFrameworkCore.DbSet<TEntity> . Methods | Improve this doc View source Add(TEntity) Declaration public TEntity Add(TEntity entity) Parameters Type Name Description TEntity entity Returns Type Description TEntity | Improve this doc View source AsQueryable() Declaration public IQueryable<TEntity> AsQueryable() Returns Type Description System.Linq.IQueryable <TEntity> | Improve this doc View source Find(Object[]) Declaration public TEntity Find(params object[] keyValues) Parameters Type Name Description System.Object [] keyValues Returns Type Description TEntity | Improve this doc View source FindAsync(Object[]) Declaration public async Task<TEntity> FindAsync(params object[] keyValues) Parameters Type Name Description System.Object [] keyValues Returns Type Description System.Threading.Tasks.Task <TEntity> | Improve this doc View source GetLocalCache() Declaration public IEnumerable<TEntity> GetLocalCache() Returns Type Description System.Collections.Generic.IEnumerable <TEntity> | Improve this doc View source Remove(TEntity) Declaration public TEntity Remove(TEntity entity) Parameters Type Name Description TEntity entity Returns Type Description TEntity | Improve this doc View source RemoveRange(IEnumerable<TEntity>) Declaration public void RemoveRange(IEnumerable<TEntity> entities) Parameters Type Name Description System.Collections.Generic.IEnumerable <TEntity> entities Implements IDbSet<TEntity>"
  },
  "api/Silverback.Database.html": {
    "href": "api/Silverback.Database.html",
    "title": "Namespace Silverback.Database | Silverback",
    "keywords": "Namespace Silverback.Database Classes DatabaseTableNotFoundException The exception that is thrown when a required database table cannot be found via the configured data layer (e.g. Entity Framework Core). EfCoreDbContext<TDbContext> An implementation of IDbContext that works with Entity Framework Core. EfCoreDbSet<TEntity> An implementation of IDbSet<TEntity> that works with Entity Framework Core. Interfaces IDbContext Abstracts the DbContext functionality to allow for multiple and decoupled implementations. IDbSet<TEntity> Abstracts the DbSet functionality to allow for multiple and decoupled implementations."
  },
  "api/Silverback.Database.IDbContext.html": {
    "href": "api/Silverback.Database.IDbContext.html",
    "title": "Interface IDbContext | Silverback",
    "keywords": "Interface IDbContext Abstracts the DbContext functionality to allow for multiple and decoupled implementations. Namespace : Silverback.Database Assembly : Silverback.Core.dll Syntax public interface IDbContext Methods | Improve this doc View source GetDbSet<TEntity>() Returns an IDbSet<TEntity> for the specified entity type. Declaration IDbSet<TEntity> GetDbSet<TEntity>() where TEntity : class Returns Type Description IDbSet <TEntity> An IDbSet<TEntity> . Type Parameters Name Description TEntity The type of the entity. | Improve this doc View source SaveChanges() Saves all changes made in this context to the database. Declaration void SaveChanges() | Improve this doc View source SaveChangesAsync() Saves all changes made in this context to the database. Declaration Task SaveChangesAsync() Returns Type Description System.Threading.Tasks.Task A System.Threading.Tasks.Task representing the asynchronous operation."
  },
  "api/Silverback.Database.IDbSet-1.html": {
    "href": "api/Silverback.Database.IDbSet-1.html",
    "title": "Interface IDbSet<TEntity> | Silverback",
    "keywords": "Interface IDbSet<TEntity> Abstracts the DbSet functionality to allow for multiple and decoupled implementations. Namespace : Silverback.Database Assembly : Silverback.Core.dll Syntax public interface IDbSet<TEntity> where TEntity : class Type Parameters Name Description TEntity The type of the entity being stored in this set. Methods | Improve this doc View source Add(TEntity) Adds the specified entity to the set and start tracking it. The entity will be inserted into the database when saving changes. Declaration TEntity Add(TEntity entity) Parameters Type Name Description TEntity entity The entity to be added. Returns Type Description TEntity The added entity. | Improve this doc View source AsQueryable() Returns an System.Linq.IQueryable to query the set. Declaration IQueryable<TEntity> AsQueryable() Returns Type Description System.Linq.IQueryable <TEntity> An System.Linq.IQueryable<T> . | Improve this doc View source Find(Object[]) Finds the entity with the specified key(s). Returns null if not found. Declaration TEntity Find(params object[] keyValues) Parameters Type Name Description System.Object [] keyValues The entity keys. Returns Type Description TEntity The entity found, or null . | Improve this doc View source FindAsync(Object[]) Finds the entity with the specified key(s). Returns null if not found. Declaration Task<TEntity> FindAsync(params object[] keyValues) Parameters Type Name Description System.Object [] keyValues The entity keys. Returns Type Description System.Threading.Tasks.Task <TEntity> The entity found, or null . | Improve this doc View source GetLocalCache() Returns the locally cached entities. Declaration IEnumerable<TEntity> GetLocalCache() Returns Type Description System.Collections.Generic.IEnumerable <TEntity> The entities in the local cache. | Improve this doc View source Remove(TEntity) Removes the specified entity from the set causing it to be deleted when saving changes. Declaration TEntity Remove(TEntity entity) Parameters Type Name Description TEntity entity The entity to be removed. Returns Type Description TEntity The removed entity. | Improve this doc View source RemoveRange(IEnumerable<TEntity>) Removes the specified entities from the set causing them to be deleted when saving changes. Declaration void RemoveRange(IEnumerable<TEntity> entities) Parameters Type Name Description System.Collections.Generic.IEnumerable <TEntity> entities The entities to be removed."
  },
  "api/Silverback.Database.Model.html": {
    "href": "api/Silverback.Database.Model.html",
    "title": "Namespace Silverback.Database.Model | Silverback",
    "keywords": "Namespace Silverback.Database.Model Classes Lock The entity written in the locks table by the DbDistributedLockManager ."
  },
  "api/Silverback.Database.Model.Lock.html": {
    "href": "api/Silverback.Database.Model.Lock.html",
    "title": "Class Lock | Silverback",
    "keywords": "Class Lock The entity written in the locks table by the DbDistributedLockManager . Inheritance System.Object Lock Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Silverback.Database.Model Assembly : Silverback.Core.dll Syntax public class Lock Properties | Improve this doc View source Created Gets or sets the record creation date. Declaration public DateTime Created { get; set; } Property Value Type Description System.DateTime | Improve this doc View source Heartbeat Gets or sets the last heartbeat timestamp. Declaration public DateTime Heartbeat { get; set; } Property Value Type Description System.DateTime | Improve this doc View source Name Gets or sets the name of the lock / the resource being locked. Declaration [Key] [MaxLength(500)] public string Name { get; set; } Property Value Type Description System.String | Improve this doc View source Timestamp Gets or sets the concurrency token. Declaration [Timestamp] public byte[] Timestamp { get; set; } Property Value Type Description System.Byte [] | Improve this doc View source UniqueId Gets or sets a unique identifier representing the entity trying to acquire the lock. Declaration [MaxLength(200)] public string UniqueId { get; set; } Property Value Type Description System.String"
  },
  "api/Silverback.Diagnostics.CoreLogEvents.html": {
    "href": "api/Silverback.Diagnostics.CoreLogEvents.html",
    "title": "Class CoreLogEvents | Silverback",
    "keywords": "Class CoreLogEvents Contains the LogEvent constants of all events logged by the Silverback.Core package. Inheritance System.Object CoreLogEvents Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Silverback.Diagnostics Assembly : Silverback.Core.dll Syntax public static class CoreLogEvents Properties | Improve this doc View source AcquiringDistributedLock Gets the LogEvent representing the log that is written when the IDistributedLockManager start trying to acquire a lock. Declaration public static LogEvent AcquiringDistributedLock { get; } Property Value Type Description LogEvent | Improve this doc View source BackgroundServiceException Gets the LogEvent representing the log that is written when an error occurs executing the DistributedBackgroundService . Declaration public static LogEvent BackgroundServiceException { get; } Property Value Type Description LogEvent | Improve this doc View source BackgroundServiceLockAcquired Gets the LogEvent representing the log that is written when the lock has been acquired and the DistributedBackgroundService is being executed. Declaration public static LogEvent BackgroundServiceLockAcquired { get; } Property Value Type Description LogEvent | Improve this doc View source BackgroundServiceStarting Gets the LogEvent representing the log that is written the DistributedBackgroundService is starting. Declaration public static LogEvent BackgroundServiceStarting { get; } Property Value Type Description LogEvent | Improve this doc View source DistributedLockAcquired Gets the LogEvent representing the log that is written when the IDistributedLockManager acquires a lock. Declaration public static LogEvent DistributedLockAcquired { get; } Property Value Type Description LogEvent | Improve this doc View source DistributedLockReleased Gets the LogEvent representing the log that is written when the IDistributedLockManager releases a lock. Declaration public static LogEvent DistributedLockReleased { get; } Property Value Type Description LogEvent | Improve this doc View source FailedToAcquireDistributedLock Gets the LogEvent representing the log that is written when an error occurs while the IDistributedLockManager acquires a lock. Declaration public static LogEvent FailedToAcquireDistributedLock { get; } Property Value Type Description LogEvent | Improve this doc View source FailedToCheckDistributedLock Gets the LogEvent representing the log that is written when an error occurs while the IDistributedLockManager checks whether a lock is still valid. Declaration public static LogEvent FailedToCheckDistributedLock { get; } Property Value Type Description LogEvent | Improve this doc View source FailedToReleaseDistributedLock Gets the LogEvent representing the log that is written when an error occurs while the IDistributedLockManager releases a lock. Declaration public static LogEvent FailedToReleaseDistributedLock { get; } Property Value Type Description LogEvent | Improve this doc View source FailedToSendDistributedLockHeartbeat Gets the LogEvent representing the log that is written when an error occurs while the IDistributedLockManager tries to send the heartbeat to keep the lock alive. Declaration public static LogEvent FailedToSendDistributedLockHeartbeat { get; } Property Value Type Description LogEvent | Improve this doc View source RecurringBackgroundServiceException Gets the LogEvent representing the log that is written when an exception is thrown during an execution of the RecurringDistributedBackgroundService . Declaration public static LogEvent RecurringBackgroundServiceException { get; } Property Value Type Description LogEvent | Improve this doc View source RecurringBackgroundServiceSleeping Gets the LogEvent representing the log that is written when the RecurringDistributedBackgroundService is sleeping in between the executions. Declaration public static LogEvent RecurringBackgroundServiceSleeping { get; } Property Value Type Description LogEvent | Improve this doc View source RecurringBackgroundServiceStopped Gets the LogEvent representing the log that is written when the RecurringDistributedBackgroundService is stopped. Declaration public static LogEvent RecurringBackgroundServiceStopped { get; } Property Value Type Description LogEvent | Improve this doc View source SubscriberResultDiscarded Gets the LogEvent representing the log that is written when the IPublisher discards the return value of a subscribed method because it doesn't match with the expected return type. Declaration public static LogEvent SubscriberResultDiscarded { get; } Property Value Type Description LogEvent"
  },
  "api/Silverback.Diagnostics.html": {
    "href": "api/Silverback.Diagnostics.html",
    "title": "Namespace Silverback.Diagnostics | Silverback",
    "keywords": "Namespace Silverback.Diagnostics Classes CoreLogEvents Contains the LogEvent constants of all events logged by the Silverback.Core package. LogEvent Encapsulates the log level, id and message. RabbitLogEvents Contains the LogEvent constants of all events logged by the Silverback.Integration.RabbitMQ package. Interfaces ILogLevelDictionary Maps Microsoft.Extensions.Logging.EventId s to the Microsoft.Extensions.Logging.LogLevel that should be used for it. ISilverbackLogger Used to perform logging in Silverback. ISilverbackLogger<TCategoryName> Used to perform logging in Silverback."
  },
  "api/Silverback.Diagnostics.ILogLevelDictionary.html": {
    "href": "api/Silverback.Diagnostics.ILogLevelDictionary.html",
    "title": "Interface ILogLevelDictionary | Silverback",
    "keywords": "Interface ILogLevelDictionary Maps Microsoft.Extensions.Logging.EventId s to the Microsoft.Extensions.Logging.LogLevel that should be used for it. Inherited Members System.Collections.Generic.IReadOnlyDictionary<Microsoft.Extensions.Logging.EventId, System.Func<System.Exception, Microsoft.Extensions.Logging.LogLevel, System.Lazy<System.String>, Microsoft.Extensions.Logging.LogLevel>>.ContainsKey(Microsoft.Extensions.Logging.EventId) System.Collections.Generic.IReadOnlyDictionary<Microsoft.Extensions.Logging.EventId, System.Func<System.Exception, Microsoft.Extensions.Logging.LogLevel, System.Lazy<System.String>, Microsoft.Extensions.Logging.LogLevel>>.TryGetValue(Microsoft.Extensions.Logging.EventId, System.Func<System.Exception, Microsoft.Extensions.Logging.LogLevel, System.Lazy<System.String>, Microsoft.Extensions.Logging.LogLevel>) System.Collections.Generic.IReadOnlyDictionary<Microsoft.Extensions.Logging.EventId, System.Func<System.Exception, Microsoft.Extensions.Logging.LogLevel, System.Lazy<System.String>, Microsoft.Extensions.Logging.LogLevel>>.Item[Microsoft.Extensions.Logging.EventId] System.Collections.Generic.IReadOnlyDictionary<Microsoft.Extensions.Logging.EventId, System.Func<System.Exception, Microsoft.Extensions.Logging.LogLevel, System.Lazy<System.String>, Microsoft.Extensions.Logging.LogLevel>>.Keys System.Collections.Generic.IReadOnlyDictionary<Microsoft.Extensions.Logging.EventId, System.Func<System.Exception, Microsoft.Extensions.Logging.LogLevel, System.Lazy<System.String>, Microsoft.Extensions.Logging.LogLevel>>.Values System.Collections.Generic.IReadOnlyCollection<System.Collections.Generic.KeyValuePair<Microsoft.Extensions.Logging.EventId, System.Func<System.Exception, Microsoft.Extensions.Logging.LogLevel, System.Lazy<System.String>, Microsoft.Extensions.Logging.LogLevel>>>.Count System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<Microsoft.Extensions.Logging.EventId, System.Func<System.Exception, Microsoft.Extensions.Logging.LogLevel, System.Lazy<System.String>, Microsoft.Extensions.Logging.LogLevel>>>.GetEnumerator() System.Collections.IEnumerable.GetEnumerator() Namespace : Silverback.Diagnostics Assembly : Silverback.Core.dll Syntax public interface ILogLevelDictionary : IReadOnlyDictionary<EventId, Func<Exception, LogLevel, Lazy<string>, LogLevel>>, IReadOnlyCollection<KeyValuePair<EventId, Func<Exception, LogLevel, Lazy<string>, LogLevel>>>, IEnumerable<KeyValuePair<EventId, Func<Exception, LogLevel, Lazy<string>, LogLevel>>>, IEnumerable"
  },
  "api/Silverback.Diagnostics.ISilverbackLogger.html": {
    "href": "api/Silverback.Diagnostics.ISilverbackLogger.html",
    "title": "Interface ISilverbackLogger | Silverback",
    "keywords": "Interface ISilverbackLogger Used to perform logging in Silverback. Namespace : Silverback.Diagnostics Assembly : Silverback.Core.dll Syntax public interface ISilverbackLogger Properties | Improve this doc View source InnerLogger Gets the underlying Microsoft.Extensions.Logging.ILogger . Declaration ILogger InnerLogger { get; } Property Value Type Description Microsoft.Extensions.Logging.ILogger Methods | Improve this doc View source IsEnabled(LogEvent) Checks if the given LogEvent is enabled according to its default or overridden Microsoft.Extensions.Logging.LogLevel . Declaration bool IsEnabled(LogEvent logEvent) Parameters Type Name Description LogEvent logEvent The LogEvent to be checked. Returns Type Description System.Boolean true if enabled."
  },
  "api/Silverback.Diagnostics.ISilverbackLogger-1.html": {
    "href": "api/Silverback.Diagnostics.ISilverbackLogger-1.html",
    "title": "Interface ISilverbackLogger<TCategoryName> | Silverback",
    "keywords": "Interface ISilverbackLogger<TCategoryName> Used to perform logging in Silverback. Inherited Members ISilverbackLogger.InnerLogger ISilverbackLogger.IsEnabled(LogEvent) Namespace : Silverback.Diagnostics Assembly : Silverback.Core.dll Syntax public interface ISilverbackLogger<out TCategoryName> : ISilverbackLogger Type Parameters Name Description TCategoryName The type who's name is used for the logger category name."
  },
  "api/Silverback.Diagnostics.LogEvent.html": {
    "href": "api/Silverback.Diagnostics.LogEvent.html",
    "title": "Class LogEvent | Silverback",
    "keywords": "Class LogEvent Encapsulates the log level, id and message. Inheritance System.Object LogEvent Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Silverback.Diagnostics Assembly : Silverback.Core.dll Syntax public class LogEvent Constructors | Improve this doc View source LogEvent(LogLevel, EventId, String) Initializes a new instance of the LogEvent class. Declaration public LogEvent(LogLevel level, EventId eventId, string message) Parameters Type Name Description Microsoft.Extensions.Logging.LogLevel level The default Microsoft.Extensions.Logging.LogLevel . Microsoft.Extensions.Logging.EventId eventId The EventId . System.String message The logged message. Properties | Improve this doc View source EventId Gets the EventId . Declaration public EventId EventId { get; } Property Value Type Description Microsoft.Extensions.Logging.EventId | Improve this doc View source Level Gets the default Microsoft.Extensions.Logging.LogLevel . Declaration public LogLevel Level { get; } Property Value Type Description Microsoft.Extensions.Logging.LogLevel | Improve this doc View source Message Gets the logged message. Declaration public string Message { get; } Property Value Type Description System.String"
  },
  "api/Silverback.Diagnostics.RabbitLogEvents.html": {
    "href": "api/Silverback.Diagnostics.RabbitLogEvents.html",
    "title": "Class RabbitLogEvents | Silverback",
    "keywords": "Class RabbitLogEvents Contains the LogEvent constants of all events logged by the Silverback.Integration.RabbitMQ package. Inheritance System.Object RabbitLogEvents Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Silverback.Diagnostics Assembly : Silverback.Integration.RabbitMQ.dll Syntax public static class RabbitLogEvents Properties | Improve this doc View source Commit Gets the LogEvent representing the log that is written when a delivery tag is successfully committed. Declaration public static LogEvent Commit { get; } Property Value Type Description LogEvent | Improve this doc View source CommitError Reserved, not used anymore. Declaration [Obsolete(\"Logged in the base consumer.\", true)] public static LogEvent CommitError { get; } Property Value Type Description LogEvent | Improve this doc View source ConsumingMessage Gets the LogEvent representing the log that is written when a message is consumed from a Rabbit queue. Declaration public static LogEvent ConsumingMessage { get; } Property Value Type Description LogEvent | Improve this doc View source ProducerQueueProcessingCanceled Gets the LogEvent representing the log that is written when the processing of the producer queue is being stopped (usually because the application is exiting). Declaration public static LogEvent ProducerQueueProcessingCanceled { get; } Property Value Type Description LogEvent | Improve this doc View source Rollback Gets the LogEvent representing the log that is written when a delivery tag is successfully rolled back. Declaration public static LogEvent Rollback { get; } Property Value Type Description LogEvent | Improve this doc View source RollbackError Reserved, not used anymore. Declaration [Obsolete(\"Logged in the base consumer.\", true)] public static LogEvent RollbackError { get; } Property Value Type Description LogEvent"
  },
  "api/Silverback.Domain.DomainEntity.html": {
    "href": "api/Silverback.Domain.DomainEntity.html",
    "title": "Class DomainEntity | Silverback",
    "keywords": "Class DomainEntity The base class for the domain entities that encapsulate domain events. Inheritance System.Object MessagesSource < IDomainEvent > DomainEntity Implements IMessagesSource Inherited Members MessagesSource<IDomainEvent>.GetMessages() MessagesSource<IDomainEvent>.ClearMessages() MessagesSource<IDomainEvent>.AddEvent(IDomainEvent) MessagesSource<IDomainEvent>.AddEvent<TEvent>(Boolean) MessagesSource<IDomainEvent>.RemoveEvent(IDomainEvent) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Silverback.Domain Assembly : Silverback.Core.Model.dll Syntax public abstract class DomainEntity : MessagesSource<IDomainEvent>, IMessagesSource Remarks It's not mandatory to use this base class as long as long as the domain entities implement the IMessagesSource interface. Properties | Improve this doc View source DomainEvents Gets the domain events that have been added but not yet published. Declaration [NotMapped] public IEnumerable<IDomainEvent> DomainEvents { get; } Property Value Type Description System.Collections.Generic.IEnumerable < IDomainEvent > Implements IMessagesSource"
  },
  "api/Silverback.Domain.DomainEvent-1.html": {
    "href": "api/Silverback.Domain.DomainEvent-1.html",
    "title": "Class DomainEvent<TEntity> | Silverback",
    "keywords": "Class DomainEvent<TEntity> Inheritance System.Object DomainEvent<TEntity> Implements IDomainEvent <TEntity> IDomainEvent IMessageWithSource IEvent IMessage Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Silverback.Domain Assembly : Silverback.Core.Model.dll Syntax public abstract class DomainEvent<TEntity> : IDomainEvent<TEntity>, IDomainEvent, IMessageWithSource, IEvent, IMessage where TEntity : class Type Parameters Name Description TEntity Properties | Improve this doc View source Source Declaration public TEntity Source { get; set; } Property Value Type Description TEntity Explicit Interface Implementations | Improve this doc View source IMessageWithSource.Source Declaration object IMessageWithSource.Source { get; set; } Returns Type Description System.Object Implements IDomainEvent<TEntity> IDomainEvent IMessageWithSource IEvent IMessage"
  },
  "api/Silverback.Domain.EntityEvent.html": {
    "href": "api/Silverback.Domain.EntityEvent.html",
    "title": "Class EntityEvent | Silverback",
    "keywords": "Class EntityEvent Inheritance System.Object EntityEvent Implements IEntityEvent Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Silverback.Domain Assembly : Silverback.EventSourcing.dll Syntax public abstract class EntityEvent : IEntityEvent Properties | Improve this doc View source Sequence Declaration [JsonIgnore] public int Sequence { get; set; } Property Value Type Description System.Int32 | Improve this doc View source Timestamp Declaration [JsonIgnore] public DateTime Timestamp { get; set; } Property Value Type Description System.DateTime Implements IEntityEvent"
  },
  "api/Silverback.Domain.EventSourcingDomainEntity-1.html": {
    "href": "api/Silverback.Domain.EventSourcingDomainEntity-1.html",
    "title": "Class EventSourcingDomainEntity<TKey> | Silverback",
    "keywords": "Class EventSourcingDomainEntity<TKey> The base class for the domain entities that are persisted in the event store. Inheritance System.Object MessagesSource < System.Object > EventSourcingDomainEntity <TKey, System.Object > EventSourcingDomainEntity<TKey> Implements IMessagesSource IEventSourcingDomainEntity <TKey> IEventSourcingDomainEntity Inherited Members EventSourcingDomainEntity<TKey, Object>.DomainEvents EventSourcingDomainEntity<TKey, Object>.Events EventSourcingDomainEntity<TKey, Object>.Id EventSourcingDomainEntity<TKey, Object>.GetVersion() EventSourcingDomainEntity<TKey, Object>.GetNewEvents() EventSourcingDomainEntity<TKey, Object>.AddAndApplyEvent(IEntityEvent) MessagesSource<Object>.GetMessages() MessagesSource<Object>.ClearMessages() MessagesSource<Object>.AddEvent(Object) MessagesSource<Object>.AddEvent<TEvent>(Boolean) MessagesSource<Object>.RemoveEvent(Object) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Silverback.Domain Assembly : Silverback.EventSourcing.dll Syntax public abstract class EventSourcingDomainEntity<TKey> : EventSourcingDomainEntity<TKey, object>, IMessagesSource, IEventSourcingDomainEntity<TKey>, IEventSourcingDomainEntity Type Parameters Name Description TKey The type of the entity key. Remarks It's not mandatory to use this base class as long as long as the domain entities implement the IEventSourcingDomainEntity<TKey> interface. Constructors | Improve this doc View source EventSourcingDomainEntity() Initializes a new instance of the EventSourcingDomainEntity<TKey> class. Declaration protected EventSourcingDomainEntity() | Improve this doc View source EventSourcingDomainEntity(IReadOnlyCollection<IEntityEvent>) Initializes a new instance of the EventSourcingDomainEntity<TKey> class from the stored events. Declaration protected EventSourcingDomainEntity(IReadOnlyCollection<IEntityEvent> events) Parameters Type Name Description System.Collections.Generic.IReadOnlyCollection < IEntityEvent > events The stored events to be re-applied to rebuild the entity state. Implements IMessagesSource IEventSourcingDomainEntity<TKey> IEventSourcingDomainEntity"
  },
  "api/Silverback.Domain.EventSourcingDomainEntity-2.html": {
    "href": "api/Silverback.Domain.EventSourcingDomainEntity-2.html",
    "title": "Class EventSourcingDomainEntity<TKey, TDomainEvent> | Silverback",
    "keywords": "Class EventSourcingDomainEntity<TKey, TDomainEvent> The base class for the domain entities that are persisted in the event store. Inheritance System.Object MessagesSource <TDomainEvent> EventSourcingDomainEntity<TKey, TDomainEvent> EventSourcingDomainEntity<TKey> Implements IMessagesSource IEventSourcingDomainEntity <TKey> IEventSourcingDomainEntity Inherited Members MessagesSource<TDomainEvent>.GetMessages() MessagesSource<TDomainEvent>.ClearMessages() MessagesSource<TDomainEvent>.AddEvent(TDomainEvent) MessagesSource<TDomainEvent>.AddEvent<TEvent>(Boolean) MessagesSource<TDomainEvent>.RemoveEvent(TDomainEvent) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Silverback.Domain Assembly : Silverback.EventSourcing.dll Syntax public abstract class EventSourcingDomainEntity<TKey, TDomainEvent> : MessagesSource<TDomainEvent>, IMessagesSource, IEventSourcingDomainEntity<TKey>, IEventSourcingDomainEntity Type Parameters Name Description TKey The type of the entity key. TDomainEvent The base type of the domain events. Remarks It's not mandatory to use this base class as long as long as the domain entities implement the IEventSourcingDomainEntity<TKey> interface. Constructors | Improve this doc View source EventSourcingDomainEntity() Initializes a new instance of the EventSourcingDomainEntity<TKey, TDomainEvent> class. Declaration protected EventSourcingDomainEntity() | Improve this doc View source EventSourcingDomainEntity(IReadOnlyCollection<IEntityEvent>) Initializes a new instance of the EventSourcingDomainEntity<TKey, TDomainEvent> class from the stored events. Declaration protected EventSourcingDomainEntity(IReadOnlyCollection<IEntityEvent> events) Parameters Type Name Description System.Collections.Generic.IReadOnlyCollection < IEntityEvent > events The stored events to be re-applied to rebuild the entity state. Properties | Improve this doc View source DomainEvents Gets the domain events that have been added but not yet published. Declaration [NotMapped] public IEnumerable<TDomainEvent> DomainEvents { get; } Property Value Type Description System.Collections.Generic.IEnumerable <TDomainEvent> | Improve this doc View source Events Gets the events that have been applied to build the current state. Declaration [NotMapped] public IEnumerable<IEntityEvent> Events { get; } Property Value Type Description System.Collections.Generic.IEnumerable < IEntityEvent > | Improve this doc View source Id Declaration public TKey Id { get; protected set; } Property Value Type Description TKey Methods | Improve this doc View source AddAndApplyEvent(IEntityEvent) Adds the specified event and applies it to update the entity state. Declaration protected virtual IEntityEvent AddAndApplyEvent(IEntityEvent entityEvent) Parameters Type Name Description IEntityEvent entityEvent The event to be added. Returns Type Description IEntityEvent The IEntityEvent that was added and applied. | Improve this doc View source GetNewEvents() Declaration public IEnumerable<IEntityEvent> GetNewEvents() Returns Type Description System.Collections.Generic.IEnumerable < IEntityEvent > | Improve this doc View source GetVersion() Declaration public int GetVersion() Returns Type Description System.Int32 Implements IMessagesSource IEventSourcingDomainEntity<TKey> IEventSourcingDomainEntity"
  },
  "api/Silverback.Domain.EventSourcingException.html": {
    "href": "api/Silverback.Domain.EventSourcingException.html",
    "title": "Class EventSourcingException | Silverback",
    "keywords": "Class EventSourcingException The exception that is thrown when the stored events cannot be applied back to the domain entity. Inheritance System.Object System.Exception SilverbackException EventSourcingException Implements System.Runtime.Serialization.ISerializable Inherited Members System.Exception.GetBaseException() System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo, System.Runtime.Serialization.StreamingContext) System.Exception.GetType() System.Exception.ToString() System.Exception.Data System.Exception.HelpLink System.Exception.HResult System.Exception.InnerException System.Exception.Message System.Exception.Source System.Exception.StackTrace System.Exception.TargetSite System.Exception.SerializeObjectState System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Silverback.Domain Assembly : Silverback.EventSourcing.dll Syntax [Serializable] public class EventSourcingException : SilverbackException, ISerializable Constructors | Improve this doc View source EventSourcingException() Initializes a new instance of the EventSourcingException class. Declaration public EventSourcingException() | Improve this doc View source EventSourcingException(SerializationInfo, StreamingContext) Initializes a new instance of the EventSourcingException class with the serialized data. Declaration protected EventSourcingException(SerializationInfo info, StreamingContext context) Parameters Type Name Description System.Runtime.Serialization.SerializationInfo info The System.Runtime.Serialization.SerializationInfo that holds the serialized object data about the exception being thrown. System.Runtime.Serialization.StreamingContext context The System.Runtime.Serialization.StreamingContext that contains contextual information about the source or destination. | Improve this doc View source EventSourcingException(String) Initializes a new instance of the EventSourcingException class with the specified message. Declaration public EventSourcingException(string message) Parameters Type Name Description System.String message The exception message. | Improve this doc View source EventSourcingException(String, Exception) Initializes a new instance of the EventSourcingException class with the specified message and inner exception. Declaration public EventSourcingException(string message, Exception innerException) Parameters Type Name Description System.String message The exception message. System.Exception innerException The inner exception. Implements System.Runtime.Serialization.ISerializable"
  },
  "api/Silverback.Domain.html": {
    "href": "api/Silverback.Domain.html",
    "title": "Namespace Silverback.Domain | Silverback",
    "keywords": "Namespace Silverback.Domain Classes DomainEntity The base class for the domain entities that encapsulate domain events. DomainEvent<TEntity> EntityEvent EventSourcingDomainEntity<TKey> The base class for the domain entities that are persisted in the event store. EventSourcingDomainEntity<TKey, TDomainEvent> The base class for the domain entities that are persisted in the event store. EventSourcingException The exception that is thrown when the stored events cannot be applied back to the domain entity. Interfaces IAggregateRoot This empty interface has no other purpose than help recognizing the aggregate root. IDomainEvent An event that generates inside the domain (model). IDomainEvent<TEntity> IEntityEvent A recorded event that can be re-applied to rebuild the entity status."
  },
  "api/Silverback.Domain.IAggregateRoot.html": {
    "href": "api/Silverback.Domain.IAggregateRoot.html",
    "title": "Interface IAggregateRoot | Silverback",
    "keywords": "Interface IAggregateRoot This empty interface has no other purpose than help recognizing the aggregate root. Namespace : Silverback.Domain Assembly : Silverback.Core.Model.dll Syntax public interface IAggregateRoot"
  },
  "api/Silverback.Domain.IDomainEvent.html": {
    "href": "api/Silverback.Domain.IDomainEvent.html",
    "title": "Interface IDomainEvent | Silverback",
    "keywords": "Interface IDomainEvent An event that generates inside the domain (model). Inherited Members IMessageWithSource.Source Namespace : Silverback.Domain Assembly : Silverback.Core.Model.dll Syntax public interface IDomainEvent : IMessageWithSource, IEvent, IMessage"
  },
  "api/Silverback.Domain.IDomainEvent-1.html": {
    "href": "api/Silverback.Domain.IDomainEvent-1.html",
    "title": "Interface IDomainEvent<TEntity> | Silverback",
    "keywords": "Interface IDomainEvent<TEntity> Namespace : Silverback.Domain Assembly : Silverback.Core.Model.dll Syntax public interface IDomainEvent<out TEntity> : IDomainEvent, IMessageWithSource, IEvent, IMessage where TEntity : class Type Parameters Name Description TEntity The type of the related domain entity. Properties | Improve this doc View source Source Gets the reference to the domain entity that generated this event. Declaration TEntity Source { get; } Property Value Type Description TEntity"
  },
  "api/Silverback.Domain.IEntityEvent.html": {
    "href": "api/Silverback.Domain.IEntityEvent.html",
    "title": "Interface IEntityEvent | Silverback",
    "keywords": "Interface IEntityEvent A recorded event that can be re-applied to rebuild the entity status. Namespace : Silverback.Domain Assembly : Silverback.EventSourcing.dll Syntax public interface IEntityEvent Properties | Improve this doc View source Sequence Gets or sets the sequence number that is used to replay the messages in the right order. Declaration int Sequence { get; set; } Property Value Type Description System.Int32 | Improve this doc View source Timestamp Gets or sets the datetime when the event occured. Declaration DateTime Timestamp { get; set; } Property Value Type Description System.DateTime"
  },
  "api/Silverback.EntityFrameworkCore.DbContextEventsPublisher.html": {
    "href": "api/Silverback.EntityFrameworkCore.DbContextEventsPublisher.html",
    "title": "Class DbContextEventsPublisher | Silverback",
    "keywords": "Class DbContextEventsPublisher Exposes some methods to handle domain events as part of the SaveChanges transaction. Inheritance System.Object DbContextEventsPublisher Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Silverback.EntityFrameworkCore Assembly : Silverback.Core.EFCore30.dll Syntax public class DbContextEventsPublisher Constructors | Improve this doc View source DbContextEventsPublisher(IPublisher, DbContext) Initializes a new instance of the DbContextEventsPublisher class. Declaration public DbContextEventsPublisher(IPublisher publisher, DbContext dbContext) Parameters Type Name Description IPublisher publisher The IPublisher to be used to publish the events to the internal bus. Microsoft.EntityFrameworkCore.DbContext dbContext The Microsoft.EntityFrameworkCore.DbContext to be scanned for domain events. | Improve this doc View source DbContextEventsPublisher(Func<Object, IEnumerable<Object>>, Action<Object>, IPublisher, DbContext) Initializes a new instance of the DbContextEventsPublisher class. Declaration public DbContextEventsPublisher(Func<object, IEnumerable<object>> eventsSelector, Action<object> clearEventsAction, IPublisher publisher, DbContext dbContext) Parameters Type Name Description System.Func < System.Object , System.Collections.Generic.IEnumerable < System.Object >> eventsSelector The custom delegate to be used to get the events out of the entities being saved. System.Action < System.Object > clearEventsAction The custom delegate to be used to clear the events from the entities after they have been published. IPublisher publisher The IPublisher to be used to publish the events to the internal bus. Microsoft.EntityFrameworkCore.DbContext dbContext The Microsoft.EntityFrameworkCore.DbContext to be scanned for domain events. Methods | Improve this doc View source ExecuteSaveTransaction(Func<Int32>) Publishes the domain events generated by the tracked entities and then executes the provided save changes procedure. Declaration public int ExecuteSaveTransaction(Func<int> saveChanges) Parameters Type Name Description System.Func < System.Int32 > saveChanges The delegate to the original SaveChanges method. Returns Type Description System.Int32 The number of entities saved to the database. | Improve this doc View source ExecuteSaveTransactionAsync(Func<Task<Int32>>) Publishes the domain events generated by the tracked entities and then executes the provided save changes procedure. Declaration public Task<int> ExecuteSaveTransactionAsync(Func<Task<int>> saveChangesAsync) Parameters Type Name Description System.Func < System.Threading.Tasks.Task < System.Int32 >> saveChangesAsync The delegate to the original SaveChangesAsync method. Returns Type Description System.Threading.Tasks.Task < System.Int32 > A System.Threading.Tasks.Task<TResult> representing the asynchronous operation. The task result contains the number of entities saved to the database."
  },
  "api/Silverback.EntityFrameworkCore.html": {
    "href": "api/Silverback.EntityFrameworkCore.html",
    "title": "Namespace Silverback.EntityFrameworkCore | Silverback",
    "keywords": "Namespace Silverback.EntityFrameworkCore Classes DbContextEventsPublisher Exposes some methods to handle domain events as part of the SaveChanges transaction."
  },
  "api/Silverback.EventStore.DbEventStoreRepository-4.html": {
    "href": "api/Silverback.EventStore.DbEventStoreRepository-4.html",
    "title": "Class DbEventStoreRepository<TDomainEntity, TKey, TEventStoreEntity, TEventEntity> | Silverback",
    "keywords": "Class DbEventStoreRepository<TDomainEntity, TKey, TEventStoreEntity, TEventEntity> The base class for the event store repositories that persist the events into a database. Inheritance System.Object EventStoreRepository <TDomainEntity, TEventStoreEntity, TEventEntity> DbEventStoreRepository<TDomainEntity, TKey, TEventStoreEntity, TEventEntity> Inherited Members EventStoreRepository<TDomainEntity, TEventStoreEntity, TEventEntity>.Store(TDomainEntity) EventStoreRepository<TDomainEntity, TEventStoreEntity, TEventEntity>.StoreAsync(TDomainEntity) EventStoreRepository<TDomainEntity, TEventStoreEntity, TEventEntity>.Remove(TDomainEntity) EventStoreRepository<TDomainEntity, TEventStoreEntity, TEventEntity>.RemoveAsync(TDomainEntity) EventStoreRepository<TDomainEntity, TEventStoreEntity, TEventEntity>.GetEventStoreEntity(TDomainEntity, Boolean) EventStoreRepository<TDomainEntity, TEventStoreEntity, TEventEntity>.GetEventStoreEntityAsync(TDomainEntity, Boolean) EventStoreRepository<TDomainEntity, TEventStoreEntity, TEventEntity>.AddEventStoreEntity(TEventStoreEntity) EventStoreRepository<TDomainEntity, TEventStoreEntity, TEventEntity>.GetEventStoreEntity(TDomainEntity) EventStoreRepository<TDomainEntity, TEventStoreEntity, TEventEntity>.GetEventStoreEntityAsync(TDomainEntity) EventStoreRepository<TDomainEntity, TEventStoreEntity, TEventEntity>.MapEventStoreEntity(TDomainEntity, TEventStoreEntity) EventStoreRepository<TDomainEntity, TEventStoreEntity, TEventEntity>.GetDomainEntity(TEventStoreEntity, Nullable<DateTime>) EventStoreRepository<TDomainEntity, TEventStoreEntity, TEventEntity>.MapEventEntity(IEntityEvent) EventStoreRepository<TDomainEntity, TEventStoreEntity, TEventEntity>.MapEvent(TEventEntity) EventStoreRepository<TDomainEntity, TEventStoreEntity, TEventEntity>.RemoveCore(TEventStoreEntity) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Silverback.EventStore Assembly : Silverback.EventSourcing.dll Syntax public abstract class DbEventStoreRepository<TDomainEntity, TKey, TEventStoreEntity, TEventEntity> : EventStoreRepository<TDomainEntity, TEventStoreEntity, TEventEntity> where TDomainEntity : class, IEventSourcingDomainEntity<TKey> where TEventStoreEntity : EventStoreEntity<TEventEntity>, new() where TEventEntity : class, IEventEntity, new() Type Parameters Name Description TDomainEntity The type of the domain entity whose events are stored in this repository. TKey The type of the domain entity key. TEventStoreEntity The type of event store entity being persisted to the underlying storage. TEventEntity The base type of the events that will be associated to the event store entity. Constructors | Improve this doc View source DbEventStoreRepository(IDbContext) Initializes a new instance of the DbEventStoreRepository<TDomainEntity, TKey, TEventStoreEntity, TEventEntity> class. Declaration protected DbEventStoreRepository(IDbContext dbContext) Parameters Type Name Description IDbContext dbContext The IDbContext to use as storage. Properties | Improve this doc View source EventStores Gets the System.Linq.IQueryable<T> of event store entities. Declaration protected IQueryable<TEventStoreEntity> EventStores { get; } Property Value Type Description System.Linq.IQueryable <TEventStoreEntity> Remarks This System.Linq.IQueryable<T> is pre-configured to include the events and is meant for read only (changes are not being tracked). Methods | Improve this doc View source AddEventStoreEntity(TEventStoreEntity) Declaration protected override void AddEventStoreEntity(TEventStoreEntity eventStoreEntity) Parameters Type Name Description TEventStoreEntity eventStoreEntity Overrides Silverback.EventStore.EventStoreRepository<TDomainEntity, TEventStoreEntity, TEventEntity>.AddEventStoreEntity(TEventStoreEntity) | Improve this doc View source Find(Expression<Func<TEventStoreEntity, Boolean>>, Nullable<DateTime>) Finds the event store matching the specified predicate and if found returns the domain entity after having applied the stored events. Declaration public TDomainEntity Find(Expression<Func<TEventStoreEntity, bool>> predicate, DateTime? snapshot = null) Parameters Type Name Description System.Linq.Expressions.Expression < System.Func <TEventStoreEntity, System.Boolean >> predicate The predicate applied to get the desired event store. System.Nullable < System.DateTime > snapshot The optional snapshot datetime. When not null only the events registered until the specified datetime are applied, returning the entity in its state back in that moment. Returns Type Description TDomainEntity The domain entity or null if not found. | Improve this doc View source FindAsync(Expression<Func<TEventStoreEntity, Boolean>>, Nullable<DateTime>) Finds the event store matching the specified predicate and if found returns the domain entity after having applied the stored events. Declaration public async Task<TDomainEntity> FindAsync(Expression<Func<TEventStoreEntity, bool>> predicate, DateTime? snapshot = null) Parameters Type Name Description System.Linq.Expressions.Expression < System.Func <TEventStoreEntity, System.Boolean >> predicate The predicate applied to get the desired event store. System.Nullable < System.DateTime > snapshot The optional snapshot datetime. When not null only the events registered until the specified datetime are applied, returning the entity in its state back in that moment. Returns Type Description System.Threading.Tasks.Task <TDomainEntity> A System.Threading.Tasks.Task<TResult> representing the asynchronous operation. The task result contains the domain entity or null if not found. | Improve this doc View source GetEventStoreEntity(TDomainEntity) Declaration protected override TEventStoreEntity GetEventStoreEntity(TDomainEntity domainEntity) Parameters Type Name Description TDomainEntity domainEntity Returns Type Description TEventStoreEntity Overrides Silverback.EventStore.EventStoreRepository<TDomainEntity, TEventStoreEntity, TEventEntity>.GetEventStoreEntity(TDomainEntity) | Improve this doc View source GetEventStoreEntityAsync(TDomainEntity) Declaration protected override async Task<TEventStoreEntity> GetEventStoreEntityAsync(TDomainEntity domainEntity) Parameters Type Name Description TDomainEntity domainEntity Returns Type Description System.Threading.Tasks.Task <TEventStoreEntity> Overrides Silverback.EventStore.EventStoreRepository<TDomainEntity, TEventStoreEntity, TEventEntity>.GetEventStoreEntityAsync(TDomainEntity) | Improve this doc View source RemoveCore(TEventStoreEntity) Declaration protected override void RemoveCore(TEventStoreEntity eventStore) Parameters Type Name Description TEventStoreEntity eventStore Overrides Silverback.EventStore.EventStoreRepository<TDomainEntity, TEventStoreEntity, TEventEntity>.RemoveCore(TEventStoreEntity)"
  },
  "api/Silverback.EventStore.EventEntity.html": {
    "href": "api/Silverback.EventStore.EventEntity.html",
    "title": "Class EventEntity | Silverback",
    "keywords": "Class EventEntity Inheritance System.Object EventEntity Implements IEventEntity Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Silverback.EventStore Assembly : Silverback.EventSourcing.dll Syntax public abstract class EventEntity : IEventEntity Properties | Improve this doc View source ClrType Declaration [MaxLength(500)] public string ClrType { get; set; } Property Value Type Description System.String | Improve this doc View source Sequence Declaration public int Sequence { get; set; } Property Value Type Description System.Int32 | Improve this doc View source SerializedEvent Declaration public string SerializedEvent { get; set; } Property Value Type Description System.String | Improve this doc View source Timestamp Declaration public DateTime Timestamp { get; set; } Property Value Type Description System.DateTime Implements IEventEntity"
  },
  "api/Silverback.EventStore.EventStoreConcurrencyException.html": {
    "href": "api/Silverback.EventStore.EventStoreConcurrencyException.html",
    "title": "Class EventStoreConcurrencyException | Silverback",
    "keywords": "Class EventStoreConcurrencyException The exception that is thrown when the event store detects that the record being saved has been modified since it was read. Inheritance System.Object System.Exception SilverbackException EventStoreException EventStoreConcurrencyException Implements System.Runtime.Serialization.ISerializable Inherited Members System.Exception.GetBaseException() System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo, System.Runtime.Serialization.StreamingContext) System.Exception.GetType() System.Exception.ToString() System.Exception.Data System.Exception.HelpLink System.Exception.HResult System.Exception.InnerException System.Exception.Message System.Exception.Source System.Exception.StackTrace System.Exception.TargetSite System.Exception.SerializeObjectState System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Silverback.EventStore Assembly : Silverback.EventSourcing.dll Syntax [Serializable] public class EventStoreConcurrencyException : EventStoreException, ISerializable Constructors | Improve this doc View source EventStoreConcurrencyException() Initializes a new instance of the EventStoreConcurrencyException class. Declaration public EventStoreConcurrencyException() | Improve this doc View source EventStoreConcurrencyException(SerializationInfo, StreamingContext) Initializes a new instance of the EventStoreConcurrencyException class with the serialized data. Declaration protected EventStoreConcurrencyException(SerializationInfo info, StreamingContext context) Parameters Type Name Description System.Runtime.Serialization.SerializationInfo info The System.Runtime.Serialization.SerializationInfo that holds the serialized object data about the exception being thrown. System.Runtime.Serialization.StreamingContext context The System.Runtime.Serialization.StreamingContext that contains contextual information about the source or destination. | Improve this doc View source EventStoreConcurrencyException(String) Initializes a new instance of the EventStoreConcurrencyException class with the specified message. Declaration public EventStoreConcurrencyException(string message) Parameters Type Name Description System.String message The exception message. | Improve this doc View source EventStoreConcurrencyException(String, Exception) Initializes a new instance of the EventStoreConcurrencyException class with the specified message and inner exception. Declaration public EventStoreConcurrencyException(string message, Exception innerException) Parameters Type Name Description System.String message The exception message. System.Exception innerException The inner exception. Implements System.Runtime.Serialization.ISerializable"
  },
  "api/Silverback.EventStore.EventStoreEntity-1.html": {
    "href": "api/Silverback.EventStore.EventStoreEntity-1.html",
    "title": "Class EventStoreEntity<TEventEntity> | Silverback",
    "keywords": "Class EventStoreEntity<TEventEntity> Inheritance System.Object MessagesSource < System.Object > EventStoreEntity<TEventEntity> Implements IMessagesSource IEventStoreEntity <TEventEntity> Inherited Members MessagesSource<Object>.GetMessages() MessagesSource<Object>.ClearMessages() MessagesSource<Object>.AddEvent(Object) MessagesSource<Object>.AddEvent<TEvent>(Boolean) MessagesSource<Object>.RemoveEvent(Object) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Silverback.EventStore Assembly : Silverback.EventSourcing.dll Syntax public class EventStoreEntity<TEventEntity> : MessagesSource<object>, IMessagesSource, IEventStoreEntity<TEventEntity> where TEventEntity : IEventEntity Type Parameters Name Description TEventEntity Properties | Improve this doc View source EntityVersion Declaration public int EntityVersion { get; set; } Property Value Type Description System.Int32 | Improve this doc View source Events Declaration public ICollection<TEventEntity> Events { get; } Property Value Type Description System.Collections.Generic.ICollection <TEventEntity> Methods | Improve this doc View source AddDomainEvents(IEnumerable<Object>) Declaration public void AddDomainEvents(IEnumerable<object> events) Parameters Type Name Description System.Collections.Generic.IEnumerable < System.Object > events Implements IMessagesSource IEventStoreEntity<TEventEntity>"
  },
  "api/Silverback.EventStore.EventStoreException.html": {
    "href": "api/Silverback.EventStore.EventStoreException.html",
    "title": "Class EventStoreException | Silverback",
    "keywords": "Class EventStoreException The base class for the exceptions related to the event store. Inheritance System.Object System.Exception SilverbackException EventStoreException EventStoreConcurrencyException EventStoreNotFoundException Implements System.Runtime.Serialization.ISerializable Inherited Members System.Exception.GetBaseException() System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo, System.Runtime.Serialization.StreamingContext) System.Exception.GetType() System.Exception.ToString() System.Exception.Data System.Exception.HelpLink System.Exception.HResult System.Exception.InnerException System.Exception.Message System.Exception.Source System.Exception.StackTrace System.Exception.TargetSite System.Exception.SerializeObjectState System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Silverback.EventStore Assembly : Silverback.EventSourcing.dll Syntax [Serializable] public abstract class EventStoreException : SilverbackException, ISerializable Constructors | Improve this doc View source EventStoreException() Initializes a new instance of the EventStoreException class. Declaration protected EventStoreException() | Improve this doc View source EventStoreException(SerializationInfo, StreamingContext) Initializes a new instance of the EventStoreException class with the serialized data. Declaration protected EventStoreException(SerializationInfo info, StreamingContext context) Parameters Type Name Description System.Runtime.Serialization.SerializationInfo info The System.Runtime.Serialization.SerializationInfo that holds the serialized object data about the exception being thrown. System.Runtime.Serialization.StreamingContext context The System.Runtime.Serialization.StreamingContext that contains contextual information about the source or destination. | Improve this doc View source EventStoreException(String) Initializes a new instance of the EventStoreException class with the specified message. Declaration protected EventStoreException(string message) Parameters Type Name Description System.String message The exception message. | Improve this doc View source EventStoreException(String, Exception) Initializes a new instance of the EventStoreException class with the specified message and inner exception. Declaration protected EventStoreException(string message, Exception innerException) Parameters Type Name Description System.String message The exception message. System.Exception innerException The inner exception. Implements System.Runtime.Serialization.ISerializable"
  },
  "api/Silverback.EventStore.EventStoreNotFoundException.html": {
    "href": "api/Silverback.EventStore.EventStoreNotFoundException.html",
    "title": "Class EventStoreNotFoundException | Silverback",
    "keywords": "Class EventStoreNotFoundException The exception that is thrown when the event store entity cannot be found. Inheritance System.Object System.Exception SilverbackException EventStoreException EventStoreNotFoundException Implements System.Runtime.Serialization.ISerializable Inherited Members System.Exception.GetBaseException() System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo, System.Runtime.Serialization.StreamingContext) System.Exception.GetType() System.Exception.ToString() System.Exception.Data System.Exception.HelpLink System.Exception.HResult System.Exception.InnerException System.Exception.Message System.Exception.Source System.Exception.StackTrace System.Exception.TargetSite System.Exception.SerializeObjectState System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Silverback.EventStore Assembly : Silverback.EventSourcing.dll Syntax [Serializable] public class EventStoreNotFoundException : EventStoreException, ISerializable Constructors | Improve this doc View source EventStoreNotFoundException() Initializes a new instance of the EventStoreNotFoundException class. Declaration public EventStoreNotFoundException() | Improve this doc View source EventStoreNotFoundException(SerializationInfo, StreamingContext) Initializes a new instance of the EventStoreNotFoundException class with the serialized data. Declaration protected EventStoreNotFoundException(SerializationInfo info, StreamingContext context) Parameters Type Name Description System.Runtime.Serialization.SerializationInfo info The System.Runtime.Serialization.SerializationInfo that holds the serialized object data about the exception being thrown. System.Runtime.Serialization.StreamingContext context The System.Runtime.Serialization.StreamingContext that contains contextual information about the source or destination. | Improve this doc View source EventStoreNotFoundException(String) Initializes a new instance of the EventStoreNotFoundException class with the specified message. Declaration public EventStoreNotFoundException(string message) Parameters Type Name Description System.String message The exception message. | Improve this doc View source EventStoreNotFoundException(String, Exception) Initializes a new instance of the EventStoreNotFoundException class with the specified message and inner exception. Declaration public EventStoreNotFoundException(string message, Exception innerException) Parameters Type Name Description System.String message The exception message. System.Exception innerException The inner exception. Implements System.Runtime.Serialization.ISerializable"
  },
  "api/Silverback.EventStore.EventStoreRepository-3.html": {
    "href": "api/Silverback.EventStore.EventStoreRepository-3.html",
    "title": "Class EventStoreRepository<TDomainEntity, TEventStoreEntity, TEventEntity> | Silverback",
    "keywords": "Class EventStoreRepository<TDomainEntity, TEventStoreEntity, TEventEntity> The base class for the event store repositories. Inheritance System.Object EventStoreRepository<TDomainEntity, TEventStoreEntity, TEventEntity> DbEventStoreRepository<TDomainEntity, TKey, TEventStoreEntity, TEventEntity> Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Silverback.EventStore Assembly : Silverback.EventSourcing.dll Syntax public abstract class EventStoreRepository<TDomainEntity, TEventStoreEntity, TEventEntity> where TDomainEntity : class, IEventSourcingDomainEntity where TEventStoreEntity : class, IEventStoreEntity<TEventEntity>, new() where TEventEntity : class, IEventEntity, new() Type Parameters Name Description TDomainEntity The type of the domain entity whose events are stored in this repository. TEventStoreEntity The type of event store entity being persisted to the underlying storage. TEventEntity The base type of the events that will be associated to the event store entity. Methods | Improve this doc View source AddEventStoreEntity(TEventStoreEntity) Adds the new event store entity to the storage, without committing yet. Declaration protected abstract void AddEventStoreEntity(TEventStoreEntity eventStoreEntity) Parameters Type Name Description TEventStoreEntity eventStoreEntity The event store entity to be added. Remarks In EF Core this equals to adding the entity to the DbSet without calling SaveChanges (that will be called later by the framework). | Improve this doc View source GetDomainEntity(TEventStoreEntity, Nullable<DateTime>) Rebuilds the domain entity applying the stored events. Declaration protected virtual TDomainEntity GetDomainEntity(TEventStoreEntity eventStoreEntity, DateTime? snapshot = null) Parameters Type Name Description TEventStoreEntity eventStoreEntity The event store entity referencing the events to be applied. System.Nullable < System.DateTime > snapshot The optional datetime of the snapshot to build. Specifying it will cause only the events up to this datetime to be applied. Returns Type Description TDomainEntity The domain entity rebuilt from the stored events. | Improve this doc View source GetEventStoreEntity(TDomainEntity) Returns the event store entity related to the specified domain entity. Declaration protected abstract TEventStoreEntity GetEventStoreEntity(TDomainEntity domainEntity) Parameters Type Name Description TDomainEntity domainEntity The domain entity. Returns Type Description TEventStoreEntity The event store entity. | Improve this doc View source GetEventStoreEntity(TDomainEntity, Boolean) Returns the event store entity related to the specified domain entity. Declaration protected virtual TEventStoreEntity GetEventStoreEntity(TDomainEntity domainEntity, bool addIfNotFound) Parameters Type Name Description TDomainEntity domainEntity The domain entity. System.Boolean addIfNotFound Specifies whether the entity must be created when not found. Returns Type Description TEventStoreEntity The event store entity. | Improve this doc View source GetEventStoreEntityAsync(TDomainEntity) Returns the event store entity related to the specified domain entity. Declaration protected abstract Task<TEventStoreEntity> GetEventStoreEntityAsync(TDomainEntity domainEntity) Parameters Type Name Description TDomainEntity domainEntity The domain entity. Returns Type Description System.Threading.Tasks.Task <TEventStoreEntity> A System.Threading.Tasks.Task<TResult> representing the asynchronous operation. The task result contains the event store entity. | Improve this doc View source GetEventStoreEntityAsync(TDomainEntity, Boolean) Returns the event store entity related to the specified domain entity. Declaration protected virtual async Task<TEventStoreEntity> GetEventStoreEntityAsync(TDomainEntity domainEntity, bool addIfNotFound) Parameters Type Name Description TDomainEntity domainEntity The domain entity. System.Boolean addIfNotFound Specifies whether the entity must be created when not found. Returns Type Description System.Threading.Tasks.Task <TEventStoreEntity> A System.Threading.Tasks.Task<TResult> representing the asynchronous operation. The task result contains the event store entity. | Improve this doc View source MapEvent(TEventEntity) Maps the persisted entity back to the IEntityEvent . Declaration protected virtual IEntityEvent MapEvent(TEventEntity eventEntity) Parameters Type Name Description TEventEntity eventEntity The stored event entity to be mapped. Returns Type Description IEntityEvent The IEntityEvent . | Improve this doc View source MapEventEntity(IEntityEvent) Maps the IEntityEvent to the related entity being persisted into the underlying storage. Declaration protected virtual TEventEntity MapEventEntity(IEntityEvent entityEvent) Parameters Type Name Description IEntityEvent entityEvent The entity event to be mapped. Returns Type Description TEventEntity The entity representing the IEntityEvent . | Improve this doc View source MapEventStoreEntity(TDomainEntity, TEventStoreEntity) Maps the domain entity to the event store entity. Declaration protected virtual void MapEventStoreEntity(TDomainEntity domainEntity, TEventStoreEntity eventStoreEntity) Parameters Type Name Description TDomainEntity domainEntity The domain entity to be mapped. TEventStoreEntity eventStoreEntity The event store entity to be initialized after the domain entity. Remarks This method should map the entity keys only. The events are handled automatically. | Improve this doc View source Remove(TDomainEntity) Removes the specified domain entity from the event store. Declaration public TEventStoreEntity Remove(TDomainEntity domainEntity) Parameters Type Name Description TDomainEntity domainEntity The domain entity to be removed. Returns Type Description TEventStoreEntity The event store entity that was removed. | Improve this doc View source RemoveAsync(TDomainEntity) Removes the specified domain entity from the event store. Declaration public async Task<TEventStoreEntity> RemoveAsync(TDomainEntity domainEntity) Parameters Type Name Description TDomainEntity domainEntity The domain entity to be removed. Returns Type Description System.Threading.Tasks.Task <TEventStoreEntity> A System.Threading.Tasks.Task<TResult> representing the asynchronous operation. The task result contains the event store entity that was removed. | Improve this doc View source RemoveCore(TEventStoreEntity) Removes the event store entity and all related events from the store. Declaration protected abstract void RemoveCore(TEventStoreEntity eventStore) Parameters Type Name Description TEventStoreEntity eventStore The entity to be removed. | Improve this doc View source Store(TDomainEntity) Stores the specified domain entity into the event store. Declaration public TEventStoreEntity Store(TDomainEntity domainEntity) Parameters Type Name Description TDomainEntity domainEntity The domain entity to be stored. Returns Type Description TEventStoreEntity The event store entity that was persisted. | Improve this doc View source StoreAsync(TDomainEntity) Stores the specified domain entity into the event store. Declaration public async Task<TEventStoreEntity> StoreAsync(TDomainEntity domainEntity) Parameters Type Name Description TDomainEntity domainEntity The domain entity to be stored. Returns Type Description System.Threading.Tasks.Task <TEventStoreEntity> A System.Threading.Tasks.Task<TResult> representing the asynchronous operation. The task result contains the event store entity that was persisted."
  },
  "api/Silverback.EventStore.html": {
    "href": "api/Silverback.EventStore.html",
    "title": "Namespace Silverback.EventStore | Silverback",
    "keywords": "Namespace Silverback.EventStore Classes DbEventStoreRepository<TDomainEntity, TKey, TEventStoreEntity, TEventEntity> The base class for the event store repositories that persist the events into a database. EventEntity EventStoreConcurrencyException The exception that is thrown when the event store detects that the record being saved has been modified since it was read. EventStoreEntity<TEventEntity> EventStoreException The base class for the exceptions related to the event store. EventStoreNotFoundException The exception that is thrown when the event store entity cannot be found. EventStoreRepository<TDomainEntity, TEventStoreEntity, TEventEntity> The base class for the event store repositories. Interfaces IEventEntity The stored entity that contains the information about an event applied to a domain entity. IEventSourcingDomainEntity A domain entity that is persisted in the event store. IEventSourcingDomainEntity<TKey> A domain entity that is persisted in the event store. IEventStoreEntity<TEventEntity> The stored entity that contain/references all the events applied to a domain entity."
  },
  "api/Silverback.EventStore.IEventEntity.html": {
    "href": "api/Silverback.EventStore.IEventEntity.html",
    "title": "Interface IEventEntity | Silverback",
    "keywords": "Interface IEventEntity The stored entity that contains the information about an event applied to a domain entity. Namespace : Silverback.EventStore Assembly : Silverback.EventSourcing.dll Syntax public interface IEventEntity Properties | Improve this doc View source ClrType Gets or sets the assembly qualified name of the event class. Declaration string ClrType { get; set; } Property Value Type Description System.String | Improve this doc View source Sequence Gets or sets the sequence number that is used to replay the messages in the right order. Declaration int Sequence { get; set; } Property Value Type Description System.Int32 | Improve this doc View source SerializedEvent Gets or sets the serialized event. Declaration string SerializedEvent { get; set; } Property Value Type Description System.String | Improve this doc View source Timestamp Gets or sets the datetime when the event occured. Declaration DateTime Timestamp { get; set; } Property Value Type Description System.DateTime"
  },
  "api/Silverback.EventStore.IEventSourcingDomainEntity.html": {
    "href": "api/Silverback.EventStore.IEventSourcingDomainEntity.html",
    "title": "Interface IEventSourcingDomainEntity | Silverback",
    "keywords": "Interface IEventSourcingDomainEntity A domain entity that is persisted in the event store. Namespace : Silverback.EventStore Assembly : Silverback.EventSourcing.dll Syntax public interface IEventSourcingDomainEntity Methods | Improve this doc View source GetNewEvents() Returns the new events that have to be persisted. Declaration IEnumerable<IEntityEvent> GetNewEvents() Returns Type Description System.Collections.Generic.IEnumerable < IEntityEvent > The new events to be persisted. | Improve this doc View source GetVersion() Returns the version of the entity. In the default implementation this is a sequence that is increment every time a new event is applied. Declaration int GetVersion() Returns Type Description System.Int32 The entity version."
  },
  "api/Silverback.EventStore.IEventSourcingDomainEntity-1.html": {
    "href": "api/Silverback.EventStore.IEventSourcingDomainEntity-1.html",
    "title": "Interface IEventSourcingDomainEntity<TKey> | Silverback",
    "keywords": "Interface IEventSourcingDomainEntity<TKey> A domain entity that is persisted in the event store. Inherited Members IEventSourcingDomainEntity.GetVersion() IEventSourcingDomainEntity.GetNewEvents() Namespace : Silverback.EventStore Assembly : Silverback.EventSourcing.dll Syntax public interface IEventSourcingDomainEntity<out TKey> : IEventSourcingDomainEntity Type Parameters Name Description TKey The type of the entity key. Properties | Improve this doc View source Id Gets the entity identifier. Declaration TKey Id { get; } Property Value Type Description TKey"
  },
  "api/Silverback.EventStore.IEventStoreEntity-1.html": {
    "href": "api/Silverback.EventStore.IEventStoreEntity-1.html",
    "title": "Interface IEventStoreEntity<TEventEntity> | Silverback",
    "keywords": "Interface IEventStoreEntity<TEventEntity> The stored entity that contain/references all the events applied to a domain entity. Namespace : Silverback.EventStore Assembly : Silverback.EventSourcing.dll Syntax public interface IEventStoreEntity<TEventEntity> where TEventEntity : IEventEntity Type Parameters Name Description TEventEntity The type of the related event entity that will be referenced. Properties | Improve this doc View source EntityVersion Gets or sets the version of the entity. Declaration int EntityVersion { get; set; } Property Value Type Description System.Int32 Remarks In the default implementation this is a sequence that is increment every time a new event is applied. | Improve this doc View source Events Gets the events that have been applied to the domain entity. Declaration ICollection<TEventEntity> Events { get; } Property Value Type Description System.Collections.Generic.ICollection <TEventEntity> Methods | Improve this doc View source AddDomainEvents(IEnumerable<Object>) Adds the specified events. Declaration void AddDomainEvents(IEnumerable<object> events) Parameters Type Name Description System.Collections.Generic.IEnumerable < System.Object > events The events to be stored."
  },
  "api/Silverback.html": {
    "href": "api/Silverback.html",
    "title": "Namespace Silverback | Silverback",
    "keywords": "Namespace Silverback Classes InstanceIdentifier The identifier used to distinguish the instances of the same type. Used mostly for logging and debugging. SilverbackException The base class for all the custom exceptions thrown by Silverback. Interfaces ISorted Declares a SortIndex property that can be used to properly order the objects implementing this interface."
  },
  "api/Silverback.InstanceIdentifier.html": {
    "href": "api/Silverback.InstanceIdentifier.html",
    "title": "Class InstanceIdentifier | Silverback",
    "keywords": "Class InstanceIdentifier The identifier used to distinguish the instances of the same type. Used mostly for logging and debugging. Inheritance System.Object InstanceIdentifier Implements System.IEquatable < InstanceIdentifier > Inherited Members System.Object.Equals(System.Object, System.Object) System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Silverback Assembly : Silverback.Core.dll Syntax public sealed class InstanceIdentifier : IEquatable<InstanceIdentifier> Remarks Using this class instead of a System.Guid allocates more memory (about 152 bytes, instead of the 16 bytes used by a System.Guid ) because the value is stored directly as string to avoid extra allocations in the ToString() method (e.g. when writing to a log). This is also a reference type and passing is around requires less allocations. Constructors | Improve this doc View source InstanceIdentifier(Nullable<Guid>) Initializes a new instance of the InstanceIdentifier class. Declaration public InstanceIdentifier(Guid? value = null) Parameters Type Name Description System.Nullable < System.Guid > value The System.Guid representing the identifier value. If null a random one will be generated. Properties | Improve this doc View source Value Gets the identifier. Declaration public string Value { get; } Property Value Type Description System.String Methods | Improve this doc View source Equals(InstanceIdentifier) Declaration public bool Equals(InstanceIdentifier other) Parameters Type Name Description InstanceIdentifier other Returns Type Description System.Boolean | Improve this doc View source Equals(Object) Declaration public override bool Equals(object obj) Parameters Type Name Description System.Object obj Returns Type Description System.Boolean Overrides System.Object.Equals(System.Object) | Improve this doc View source GetHashCode() Declaration public override int GetHashCode() Returns Type Description System.Int32 Overrides System.Object.GetHashCode() | Improve this doc View source ToString() Converts the InstanceIdentifier to a string. Declaration public override string ToString() Returns Type Description System.String The identifier value. Overrides System.Object.ToString() Operators | Improve this doc View source Equality(InstanceIdentifier, InstanceIdentifier) Declaration public static bool operator ==(InstanceIdentifier left, InstanceIdentifier right) Parameters Type Name Description InstanceIdentifier left InstanceIdentifier right Returns Type Description System.Boolean | Improve this doc View source Implicit(InstanceIdentifier to String) Converts the InstanceIdentifier to a string. Declaration public static implicit operator string (InstanceIdentifier identifier) Parameters Type Name Description InstanceIdentifier identifier The InstanceIdentifier to be converted. Returns Type Description System.String The identifier value. | Improve this doc View source Inequality(InstanceIdentifier, InstanceIdentifier) Declaration public static bool operator !=(InstanceIdentifier left, InstanceIdentifier right) Parameters Type Name Description InstanceIdentifier left InstanceIdentifier right Returns Type Description System.Boolean Implements System.IEquatable<T>"
  },
  "api/Silverback.ISorted.html": {
    "href": "api/Silverback.ISorted.html",
    "title": "Interface ISorted | Silverback",
    "keywords": "Interface ISorted Declares a SortIndex property that can be used to properly order the objects implementing this interface. Namespace : Silverback Assembly : Silverback.Core.dll Syntax public interface ISorted Remarks Used for example to sort the behaviors. The SortBySortIndex extension method can be used to sort the enumerable collections of objects implementing this interface. Properties | Improve this doc View source SortIndex Gets the sort index. Declaration int SortIndex { get; } Property Value Type Description System.Int32"
  },
  "api/Silverback.Messaging.Broker.html": {
    "href": "api/Silverback.Messaging.Broker.html",
    "title": "Namespace Silverback.Messaging.Broker | Silverback",
    "keywords": "Namespace Silverback.Messaging.Broker Classes RabbitBroker An Silverback.Messaging.Broker.IBroker implementation for RabbitMQ. RabbitConsumer RabbitDeliveryTag Represents the unique message identifier assigned by the message broker. RabbitProducer"
  },
  "api/Silverback.Messaging.Broker.Kafka.html": {
    "href": "api/Silverback.Messaging.Broker.Kafka.html",
    "title": "Namespace Silverback.Messaging.Broker.Kafka | Silverback",
    "keywords": "Namespace Silverback.Messaging.Broker.Kafka Classes MockedConfluentAdminClientBuilder The builder for the Silverback.Messaging.Broker.Kafka.Mocks.MockedConfluentAdminClient . MockedConfluentConsumerBuilder The builder for the Silverback.Messaging.Broker.Kafka.Mocks.MockedConfluentConsumer . MockedConfluentProducerBuilder The builder for the Silverback.Messaging.Broker.Kafka.Mocks.MockedConfluentProducer ."
  },
  "api/Silverback.Messaging.Broker.Kafka.MockedConfluentAdminClientBuilder.html": {
    "href": "api/Silverback.Messaging.Broker.Kafka.MockedConfluentAdminClientBuilder.html",
    "title": "Class MockedConfluentAdminClientBuilder | Silverback",
    "keywords": "Class MockedConfluentAdminClientBuilder The builder for the Silverback.Messaging.Broker.Kafka.Mocks.MockedConfluentAdminClient . Inheritance System.Object MockedConfluentAdminClientBuilder Implements Silverback.Messaging.Broker.Kafka.IConfluentAdminClientBuilder Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Silverback.Messaging.Broker.Kafka Assembly : Silverback.Integration.Kafka.Testing.dll Syntax public class MockedConfluentAdminClientBuilder : IConfluentAdminClientBuilder Constructors | Improve this doc View source MockedConfluentAdminClientBuilder(IMockedKafkaOptions) Initializes a new instance of the MockedConfluentAdminClientBuilder class. Declaration public MockedConfluentAdminClientBuilder(IMockedKafkaOptions options) Parameters Type Name Description IMockedKafkaOptions options The IMockedKafkaOptions . Methods | Improve this doc View source Build(ClientConfig) Declaration public IAdminClient Build(ClientConfig config) Parameters Type Name Description Confluent.Kafka.ClientConfig config Returns Type Description Confluent.Kafka.IAdminClient Implements Silverback.Messaging.Broker.Kafka.IConfluentAdminClientBuilder"
  },
  "api/Silverback.Messaging.Broker.Kafka.MockedConfluentConsumerBuilder.html": {
    "href": "api/Silverback.Messaging.Broker.Kafka.MockedConfluentConsumerBuilder.html",
    "title": "Class MockedConfluentConsumerBuilder | Silverback",
    "keywords": "Class MockedConfluentConsumerBuilder The builder for the Silverback.Messaging.Broker.Kafka.Mocks.MockedConfluentConsumer . Inheritance System.Object MockedConfluentConsumerBuilder Implements Silverback.Messaging.Broker.Kafka.IConfluentConsumerBuilder Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Silverback.Messaging.Broker.Kafka Assembly : Silverback.Integration.Kafka.Testing.dll Syntax public class MockedConfluentConsumerBuilder : IConfluentConsumerBuilder Constructors | Improve this doc View source MockedConfluentConsumerBuilder(IServiceProvider, IMockedKafkaOptions) Initializes a new instance of the MockedConfluentConsumerBuilder class. Declaration public MockedConfluentConsumerBuilder(IServiceProvider serviceProvider, IMockedKafkaOptions options) Parameters Type Name Description System.IServiceProvider serviceProvider The System.IServiceProvider to be used to resolve the required services. IMockedKafkaOptions options The IMockedKafkaOptions . Methods | Improve this doc View source Build() Declaration public IConsumer<byte[], byte[]> Build() Returns Type Description Confluent.Kafka.IConsumer < System.Byte [], System.Byte []> | Improve this doc View source SetConfig(ConsumerConfig) Declaration public IConfluentConsumerBuilder SetConfig(ConsumerConfig config) Parameters Type Name Description Confluent.Kafka.ConsumerConfig config Returns Type Description Silverback.Messaging.Broker.Kafka.IConfluentConsumerBuilder | Improve this doc View source SetErrorHandler(Action<IConsumer<Byte[], Byte[]>, Error>) Declaration public IConfluentConsumerBuilder SetErrorHandler(Action<IConsumer<byte[], byte[]>, Error> errorHandler) Parameters Type Name Description System.Action < Confluent.Kafka.IConsumer < System.Byte [], System.Byte []>, Confluent.Kafka.Error > errorHandler Returns Type Description Silverback.Messaging.Broker.Kafka.IConfluentConsumerBuilder | Improve this doc View source SetLogHandler(Action<IConsumer<Byte[], Byte[]>, LogMessage>) Declaration public IConfluentConsumerBuilder SetLogHandler(Action<IConsumer<byte[], byte[]>, LogMessage> logHandler) Parameters Type Name Description System.Action < Confluent.Kafka.IConsumer < System.Byte [], System.Byte []>, Confluent.Kafka.LogMessage > logHandler Returns Type Description Silverback.Messaging.Broker.Kafka.IConfluentConsumerBuilder | Improve this doc View source SetOffsetsCommittedHandler(Action<IConsumer<Byte[], Byte[]>, CommittedOffsets>) Declaration public IConfluentConsumerBuilder SetOffsetsCommittedHandler(Action<IConsumer<byte[], byte[]>, CommittedOffsets> offsetsCommittedHandler) Parameters Type Name Description System.Action < Confluent.Kafka.IConsumer < System.Byte [], System.Byte []>, Confluent.Kafka.CommittedOffsets > offsetsCommittedHandler Returns Type Description Silverback.Messaging.Broker.Kafka.IConfluentConsumerBuilder | Improve this doc View source SetPartitionsAssignedHandler(Action<IConsumer<Byte[], Byte[]>, List<TopicPartition>>) Declaration public IConfluentConsumerBuilder SetPartitionsAssignedHandler(Action<IConsumer<byte[], byte[]>, List<TopicPartition>> partitionsAssignedHandler) Parameters Type Name Description System.Action < Confluent.Kafka.IConsumer < System.Byte [], System.Byte []>, System.Collections.Generic.List < Confluent.Kafka.TopicPartition >> partitionsAssignedHandler Returns Type Description Silverback.Messaging.Broker.Kafka.IConfluentConsumerBuilder | Improve this doc View source SetPartitionsAssignedHandler(Func<IConsumer<Byte[], Byte[]>, List<TopicPartition>, IEnumerable<TopicPartitionOffset>>) Declaration public IConfluentConsumerBuilder SetPartitionsAssignedHandler(Func<IConsumer<byte[], byte[]>, List<TopicPartition>, IEnumerable<TopicPartitionOffset>> partitionsAssignedHandler) Parameters Type Name Description System.Func < Confluent.Kafka.IConsumer < System.Byte [], System.Byte []>, System.Collections.Generic.List < Confluent.Kafka.TopicPartition >, System.Collections.Generic.IEnumerable < Confluent.Kafka.TopicPartitionOffset >> partitionsAssignedHandler Returns Type Description Silverback.Messaging.Broker.Kafka.IConfluentConsumerBuilder | Improve this doc View source SetPartitionsRevokedHandler(Action<IConsumer<Byte[], Byte[]>, List<TopicPartitionOffset>>) Declaration public IConfluentConsumerBuilder SetPartitionsRevokedHandler(Action<IConsumer<byte[], byte[]>, List<TopicPartitionOffset>> partitionsRevokedHandler) Parameters Type Name Description System.Action < Confluent.Kafka.IConsumer < System.Byte [], System.Byte []>, System.Collections.Generic.List < Confluent.Kafka.TopicPartitionOffset >> partitionsRevokedHandler Returns Type Description Silverback.Messaging.Broker.Kafka.IConfluentConsumerBuilder | Improve this doc View source SetPartitionsRevokedHandler(Func<IConsumer<Byte[], Byte[]>, List<TopicPartitionOffset>, IEnumerable<TopicPartitionOffset>>) Declaration public IConfluentConsumerBuilder SetPartitionsRevokedHandler(Func<IConsumer<byte[], byte[]>, List<TopicPartitionOffset>, IEnumerable<TopicPartitionOffset>> partitionsRevokedHandler) Parameters Type Name Description System.Func < Confluent.Kafka.IConsumer < System.Byte [], System.Byte []>, System.Collections.Generic.List < Confluent.Kafka.TopicPartitionOffset >, System.Collections.Generic.IEnumerable < Confluent.Kafka.TopicPartitionOffset >> partitionsRevokedHandler Returns Type Description Silverback.Messaging.Broker.Kafka.IConfluentConsumerBuilder | Improve this doc View source SetStatisticsHandler(Action<IConsumer<Byte[], Byte[]>, String>) Declaration public IConfluentConsumerBuilder SetStatisticsHandler(Action<IConsumer<byte[], byte[]>, string> statisticsHandler) Parameters Type Name Description System.Action < Confluent.Kafka.IConsumer < System.Byte [], System.Byte []>, System.String > statisticsHandler Returns Type Description Silverback.Messaging.Broker.Kafka.IConfluentConsumerBuilder Implements Silverback.Messaging.Broker.Kafka.IConfluentConsumerBuilder"
  },
  "api/Silverback.Messaging.Broker.Kafka.MockedConfluentProducerBuilder.html": {
    "href": "api/Silverback.Messaging.Broker.Kafka.MockedConfluentProducerBuilder.html",
    "title": "Class MockedConfluentProducerBuilder | Silverback",
    "keywords": "Class MockedConfluentProducerBuilder The builder for the Silverback.Messaging.Broker.Kafka.Mocks.MockedConfluentProducer . Inheritance System.Object MockedConfluentProducerBuilder Implements Silverback.Messaging.Broker.Kafka.IConfluentProducerBuilder Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Silverback.Messaging.Broker.Kafka Assembly : Silverback.Integration.Kafka.Testing.dll Syntax public class MockedConfluentProducerBuilder : IConfluentProducerBuilder Constructors | Improve this doc View source MockedConfluentProducerBuilder(IServiceProvider) Initializes a new instance of the MockedConfluentProducerBuilder class. Declaration public MockedConfluentProducerBuilder(IServiceProvider serviceProvider) Parameters Type Name Description System.IServiceProvider serviceProvider The System.IServiceProvider to be used to resolve the required services. Methods | Improve this doc View source Build() Declaration public IProducer<byte[], byte[]> Build() Returns Type Description Confluent.Kafka.IProducer < System.Byte [], System.Byte []> | Improve this doc View source SetConfig(ProducerConfig) Declaration public IConfluentProducerBuilder SetConfig(ProducerConfig config) Parameters Type Name Description Confluent.Kafka.ProducerConfig config Returns Type Description Silverback.Messaging.Broker.Kafka.IConfluentProducerBuilder | Improve this doc View source SetLogHandler(Action<IProducer<Byte[], Byte[]>, LogMessage>) Declaration public IConfluentProducerBuilder SetLogHandler(Action<IProducer<byte[], byte[]>, LogMessage> logHandler) Parameters Type Name Description System.Action < Confluent.Kafka.IProducer < System.Byte [], System.Byte []>, Confluent.Kafka.LogMessage > logHandler Returns Type Description Silverback.Messaging.Broker.Kafka.IConfluentProducerBuilder | Improve this doc View source SetStatisticsHandler(Action<IProducer<Byte[], Byte[]>, String>) Declaration public IConfluentProducerBuilder SetStatisticsHandler(Action<IProducer<byte[], byte[]>, string> statisticsHandler) Parameters Type Name Description System.Action < Confluent.Kafka.IProducer < System.Byte [], System.Byte []>, System.String > statisticsHandler Returns Type Description Silverback.Messaging.Broker.Kafka.IConfluentProducerBuilder Implements Silverback.Messaging.Broker.Kafka.IConfluentProducerBuilder"
  },
  "api/Silverback.Messaging.Broker.Kafka.Mocks.html": {
    "href": "api/Silverback.Messaging.Broker.Kafka.Mocks.html",
    "title": "Namespace Silverback.Messaging.Broker.Kafka.Mocks | Silverback",
    "keywords": "Namespace Silverback.Messaging.Broker.Kafka.Mocks Interfaces IInMemoryPartition A mocked topic partition where the messages are just stored in memory. IInMemoryTopic A mocked topic where the messages are just stored in memory. Note that it isn't obviously possible to accurately replicate the message broker behavior and this implementation is just intended for testing purposes. IMockedConfluentConsumer A mocked implementation of Confluent.Kafka.IConsumer<TKey, TValue> from Confluent.Kafka that consumes from an IInMemoryTopic ."
  },
  "api/Silverback.Messaging.Broker.Kafka.Mocks.IInMemoryPartition.html": {
    "href": "api/Silverback.Messaging.Broker.Kafka.Mocks.IInMemoryPartition.html",
    "title": "Interface IInMemoryPartition | Silverback",
    "keywords": "Interface IInMemoryPartition A mocked topic partition where the messages are just stored in memory. Namespace : Silverback.Messaging.Broker.Kafka.Mocks Assembly : Silverback.Integration.Kafka.Testing.dll Syntax public interface IInMemoryPartition Properties | Improve this doc View source FirstOffset Gets the Confluent.Kafka.Offset of the first message in the partition. Declaration Offset FirstOffset { get; } Property Value Type Description Confluent.Kafka.Offset | Improve this doc View source LastOffset Gets the Confluent.Kafka.Offset of the latest message in the partition. Declaration Offset LastOffset { get; } Property Value Type Description Confluent.Kafka.Offset | Improve this doc View source Partition Gets the Partition (index). Declaration Partition Partition { get; } Property Value Type Description Confluent.Kafka.Partition | Improve this doc View source TotalMessagesCount Gets the total number of messages written to the partition. Declaration int TotalMessagesCount { get; } Property Value Type Description System.Int32 Methods | Improve this doc View source GetAllMessages() Gets all messages currently stored in the partition. Declaration IReadOnlyCollection<Message<byte[], byte[]>> GetAllMessages() Returns Type Description System.Collections.Generic.IReadOnlyCollection < Confluent.Kafka.Message < System.Byte [], System.Byte []>> The messages. | Improve this doc View source TryPull(Offset, out ConsumeResult<Byte[], Byte[]>) Pulls the next message from the partition, if available. Declaration bool TryPull(Offset offset, out ConsumeResult<byte[], byte[]> result) Parameters Type Name Description Confluent.Kafka.Offset offset The offset of the next message to be pulled. Confluent.Kafka.ConsumeResult < System.Byte [], System.Byte []> result The Confluent.Kafka.ConsumeResult<TKey, TValue> wrapping the pulled message. Returns Type Description System.Boolean A value indicating whether a message was available for pulling."
  },
  "api/Silverback.Messaging.Broker.Kafka.Mocks.IInMemoryTopic.html": {
    "href": "api/Silverback.Messaging.Broker.Kafka.Mocks.IInMemoryTopic.html",
    "title": "Interface IInMemoryTopic | Silverback",
    "keywords": "Interface IInMemoryTopic A mocked topic where the messages are just stored in memory. Note that it isn't obviously possible to accurately replicate the message broker behavior and this implementation is just intended for testing purposes. Namespace : Silverback.Messaging.Broker.Kafka.Mocks Assembly : Silverback.Integration.Kafka.Testing.dll Syntax public interface IInMemoryTopic Properties | Improve this doc View source BootstrapServers Gets the bootstrap servers string used to identify the target broker. Declaration string BootstrapServers { get; } Property Value Type Description System.String | Improve this doc View source MessagesCount Gets the total number of messages written into all the partitions of the topic. Declaration int MessagesCount { get; } Property Value Type Description System.Int32 | Improve this doc View source Name Gets the topic name. Declaration string Name { get; } Property Value Type Description System.String | Improve this doc View source Partitions Gets the partitions in the topic. Declaration IReadOnlyList<IInMemoryPartition> Partitions { get; } Property Value Type Description System.Collections.Generic.IReadOnlyList < IInMemoryPartition > Methods | Improve this doc View source AbortTransaction(Guid) Aborts the transaction. Declaration void AbortTransaction(Guid transactionalUniqueId) Parameters Type Name Description System.Guid transactionalUniqueId The transactional unique identifier. | Improve this doc View source Assign(IMockedConfluentConsumer, Partition) Assigns the specified partition to the consumer. Declaration void Assign(IMockedConfluentConsumer consumer, Partition partition) Parameters Type Name Description IMockedConfluentConsumer consumer The IMockedConfluentConsumer instance. Confluent.Kafka.Partition partition The partition. | Improve this doc View source Commit(String, IEnumerable<TopicPartitionOffset>) Commits the offsets of the specified consumer group. Declaration IReadOnlyCollection<TopicPartitionOffset> Commit(string groupId, IEnumerable<TopicPartitionOffset> partitionOffsets) Parameters Type Name Description System.String groupId The consumer group id. System.Collections.Generic.IEnumerable < Confluent.Kafka.TopicPartitionOffset > partitionOffsets The offsets to be committed. Returns Type Description System.Collections.Generic.IReadOnlyCollection < Confluent.Kafka.TopicPartitionOffset > The actual committed offsets. | Improve this doc View source CommitTransaction(Guid) Commits the transaction. Declaration void CommitTransaction(Guid transactionalUniqueId) Parameters Type Name Description System.Guid transactionalUniqueId The transactional unique identifier. | Improve this doc View source EnsurePartitionsAssigned(IMockedConfluentConsumer, TimeSpan, CancellationToken) Ensures that a partition assignment has been given to the specified consumer, otherwise triggers the assignment process. Declaration void EnsurePartitionsAssigned(IMockedConfluentConsumer consumer, TimeSpan assignmentDelay, CancellationToken cancellationToken) Parameters Type Name Description IMockedConfluentConsumer consumer The consumer. System.TimeSpan assignmentDelay The delay to be applied before assigning the partitions. System.Threading.CancellationToken cancellationToken A System.Threading.CancellationToken to observe while waiting for the task to complete. | Improve this doc View source GetAllMessages() Gets all messages written into all the partitions of the topic. Declaration IReadOnlyList<Message<byte[], byte[]>> GetAllMessages() Returns Type Description System.Collections.Generic.IReadOnlyList < Confluent.Kafka.Message < System.Byte [], System.Byte []>> The messages written into the topic. | Improve this doc View source GetCommittedOffset(Partition, String) Gets the latest committed Confluent.Kafka.Offset for the specified partition. Declaration Offset GetCommittedOffset(Partition partition, string groupId) Parameters Type Name Description Confluent.Kafka.Partition partition The partition. System.String groupId The consumer group id. Returns Type Description Confluent.Kafka.Offset The latest Confluent.Kafka.Offset . | Improve this doc View source GetCommittedOffsets(String) Gets the latest committed Confluent.Kafka.Offset for each partition. Declaration IReadOnlyCollection<TopicPartitionOffset> GetCommittedOffsets(string groupId) Parameters Type Name Description System.String groupId The consumer group id. Returns Type Description System.Collections.Generic.IReadOnlyCollection < Confluent.Kafka.TopicPartitionOffset > The collection containing the latest Confluent.Kafka.Offset for each partition. | Improve this doc View source GetCommittedOffsetsCount(String) Gets the number of committed offsets for the specified consumer group. This number is usually equal to the number of consumed messages. Declaration long GetCommittedOffsetsCount(string groupId) Parameters Type Name Description System.String groupId The consumer group id. Returns Type Description System.Int64 The number of committed offsets. | Improve this doc View source GetFirstOffset(Partition) Gets the Confluent.Kafka.Offset of the first message in the specified partition. Declaration Offset GetFirstOffset(Partition partition) Parameters Type Name Description Confluent.Kafka.Partition partition The partition. Returns Type Description Confluent.Kafka.Offset The Confluent.Kafka.Offset of the first message in the partition. | Improve this doc View source GetLastOffset(Partition) Gets the Confluent.Kafka.Offset of the latest message written to the specified partition. Declaration Offset GetLastOffset(Partition partition) Parameters Type Name Description Confluent.Kafka.Partition partition The partition. Returns Type Description Confluent.Kafka.Offset The Confluent.Kafka.Offset of the latest message in the partition. | Improve this doc View source Push(Int32, Message<Byte[], Byte[]>, Guid) Writes a message to the topic. Declaration Offset Push(int partition, Message<byte[], byte[]> message, Guid transactionalUniqueId) Parameters Type Name Description System.Int32 partition The index of the partition to be written to. Confluent.Kafka.Message < System.Byte [], System.Byte []> message The message to be written. System.Guid transactionalUniqueId The transactional unique identifier. Returns Type Description Confluent.Kafka.Offset The Confluent.Kafka.Offset at which the message was written. | Improve this doc View source Rebalance() Simulates a rebalance and causes all assignments to be revoked and reassigned. Declaration void Rebalance() | Improve this doc View source Subscribe(IMockedConfluentConsumer) Subscribes the consumer to the topic. Declaration void Subscribe(IMockedConfluentConsumer consumer) Parameters Type Name Description IMockedConfluentConsumer consumer The IMockedConfluentConsumer instance. | Improve this doc View source Unsubscribe(IMockedConfluentConsumer) Unsubscribes the consumer from the topic. Declaration void Unsubscribe(IMockedConfluentConsumer consumer) Parameters Type Name Description IMockedConfluentConsumer consumer The IMockedConfluentConsumer instance. | Improve this doc View source WaitUntilAllMessagesAreConsumedAsync(CancellationToken) Returns a System.Threading.Tasks.Task that completes when all messages routed to the consumers have been processed and committed. Declaration Task WaitUntilAllMessagesAreConsumedAsync(CancellationToken cancellationToken = default(CancellationToken)) Parameters Type Name Description System.Threading.CancellationToken cancellationToken A System.Threading.CancellationToken to observe while waiting for the task to complete. Returns Type Description System.Threading.Tasks.Task A System.Threading.Tasks.Task that completes when all messages have been processed."
  },
  "api/Silverback.Messaging.Broker.Kafka.Mocks.IMockedConfluentConsumer.html": {
    "href": "api/Silverback.Messaging.Broker.Kafka.Mocks.IMockedConfluentConsumer.html",
    "title": "Interface IMockedConfluentConsumer | Silverback",
    "keywords": "Interface IMockedConfluentConsumer A mocked implementation of Confluent.Kafka.IConsumer<TKey, TValue> from Confluent.Kafka that consumes from an IInMemoryTopic . Inherited Members Confluent.Kafka.IConsumer<System.Byte[], System.Byte[]>.Consume(System.Int32) Confluent.Kafka.IConsumer<System.Byte[], System.Byte[]>.Consume(System.Threading.CancellationToken) Confluent.Kafka.IConsumer<System.Byte[], System.Byte[]>.Consume(System.TimeSpan) Confluent.Kafka.IConsumer<System.Byte[], System.Byte[]>.Subscribe(System.Collections.Generic.IEnumerable<System.String>) Confluent.Kafka.IConsumer<System.Byte[], System.Byte[]>.Subscribe(System.String) Confluent.Kafka.IConsumer<System.Byte[], System.Byte[]>.Unsubscribe() Confluent.Kafka.IConsumer<System.Byte[], System.Byte[]>.Assign(Confluent.Kafka.TopicPartition) Confluent.Kafka.IConsumer<System.Byte[], System.Byte[]>.Assign(Confluent.Kafka.TopicPartitionOffset) Confluent.Kafka.IConsumer<System.Byte[], System.Byte[]>.Assign(System.Collections.Generic.IEnumerable<Confluent.Kafka.TopicPartitionOffset>) Confluent.Kafka.IConsumer<System.Byte[], System.Byte[]>.Assign(System.Collections.Generic.IEnumerable<Confluent.Kafka.TopicPartition>) Confluent.Kafka.IConsumer<System.Byte[], System.Byte[]>.IncrementalAssign(System.Collections.Generic.IEnumerable<Confluent.Kafka.TopicPartitionOffset>) Confluent.Kafka.IConsumer<System.Byte[], System.Byte[]>.IncrementalAssign(System.Collections.Generic.IEnumerable<Confluent.Kafka.TopicPartition>) Confluent.Kafka.IConsumer<System.Byte[], System.Byte[]>.IncrementalUnassign(System.Collections.Generic.IEnumerable<Confluent.Kafka.TopicPartition>) Confluent.Kafka.IConsumer<System.Byte[], System.Byte[]>.Unassign() Confluent.Kafka.IConsumer<System.Byte[], System.Byte[]>.StoreOffset(Confluent.Kafka.ConsumeResult<System.Byte[], System.Byte[]>) Confluent.Kafka.IConsumer<System.Byte[], System.Byte[]>.StoreOffset(Confluent.Kafka.TopicPartitionOffset) Confluent.Kafka.IConsumer<System.Byte[], System.Byte[]>.Commit() Confluent.Kafka.IConsumer<System.Byte[], System.Byte[]>.Commit(System.Collections.Generic.IEnumerable<Confluent.Kafka.TopicPartitionOffset>) Confluent.Kafka.IConsumer<System.Byte[], System.Byte[]>.Commit(Confluent.Kafka.ConsumeResult<System.Byte[], System.Byte[]>) Confluent.Kafka.IConsumer<System.Byte[], System.Byte[]>.Seek(Confluent.Kafka.TopicPartitionOffset) Confluent.Kafka.IConsumer<System.Byte[], System.Byte[]>.Pause(System.Collections.Generic.IEnumerable<Confluent.Kafka.TopicPartition>) Confluent.Kafka.IConsumer<System.Byte[], System.Byte[]>.Resume(System.Collections.Generic.IEnumerable<Confluent.Kafka.TopicPartition>) Confluent.Kafka.IConsumer<System.Byte[], System.Byte[]>.Committed(System.TimeSpan) Confluent.Kafka.IConsumer<System.Byte[], System.Byte[]>.Committed(System.Collections.Generic.IEnumerable<Confluent.Kafka.TopicPartition>, System.TimeSpan) Confluent.Kafka.IConsumer<System.Byte[], System.Byte[]>.Position(Confluent.Kafka.TopicPartition) Confluent.Kafka.IConsumer<System.Byte[], System.Byte[]>.PositionTopicPartitionOffset(Confluent.Kafka.TopicPartition) Confluent.Kafka.IConsumer<System.Byte[], System.Byte[]>.OffsetsForTimes(System.Collections.Generic.IEnumerable<Confluent.Kafka.TopicPartitionTimestamp>, System.TimeSpan) Confluent.Kafka.IConsumer<System.Byte[], System.Byte[]>.GetWatermarkOffsets(Confluent.Kafka.TopicPartition) Confluent.Kafka.IConsumer<System.Byte[], System.Byte[]>.QueryWatermarkOffsets(Confluent.Kafka.TopicPartition, System.TimeSpan) Confluent.Kafka.IConsumer<System.Byte[], System.Byte[]>.Close() Confluent.Kafka.IConsumer<System.Byte[], System.Byte[]>.MemberId Confluent.Kafka.IConsumer<System.Byte[], System.Byte[]>.Assignment Confluent.Kafka.IConsumer<System.Byte[], System.Byte[]>.Subscription Confluent.Kafka.IConsumer<System.Byte[], System.Byte[]>.ConsumerGroupMetadata Confluent.Kafka.IClient.AddBrokers(System.String) Confluent.Kafka.IClient.SetSaslCredentials(System.String, System.String) Confluent.Kafka.IClient.Handle Confluent.Kafka.IClient.Name System.IDisposable.Dispose() Namespace : Silverback.Messaging.Broker.Kafka.Mocks Assembly : Silverback.Integration.Kafka.Testing.dll Syntax public interface IMockedConfluentConsumer : IConsumer<byte[], byte[]>, IClient, IDisposable Properties | Improve this doc View source Disposed Gets a value indicating whether this instance was disposed. Declaration bool Disposed { get; } Property Value Type Description System.Boolean | Improve this doc View source EnablePartitionEof Gets a value indicating whether the partition EOF event has to be emitted. Declaration bool EnablePartitionEof { get; } Property Value Type Description System.Boolean | Improve this doc View source GroupId Gets the consumer group id. Declaration string GroupId { get; } Property Value Type Description System.String | Improve this doc View source PartitionsAssigned Gets a value indicating whether the partitions have been assigned to the consumer. Declaration bool PartitionsAssigned { get; } Property Value Type Description System.Boolean Remarks This value indicates that the rebalance process is over. It could be that no partition has actually been assigned."
  },
  "api/Silverback.Messaging.Broker.Mqtt.html": {
    "href": "api/Silverback.Messaging.Broker.Mqtt.html",
    "title": "Namespace Silverback.Messaging.Broker.Mqtt | Silverback",
    "keywords": "Namespace Silverback.Messaging.Broker.Mqtt Classes MockedMqttNetClientFactory The factory used to create the MockedMqttClient instances."
  },
  "api/Silverback.Messaging.Broker.Mqtt.MockedMqttNetClientFactory.html": {
    "href": "api/Silverback.Messaging.Broker.Mqtt.MockedMqttNetClientFactory.html",
    "title": "Class MockedMqttNetClientFactory | Silverback",
    "keywords": "Class MockedMqttNetClientFactory The factory used to create the MockedMqttClient instances. Inheritance System.Object MockedMqttNetClientFactory Implements Silverback.Messaging.Broker.Mqtt.IMqttNetClientFactory Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Silverback.Messaging.Broker.Mqtt Assembly : Silverback.Integration.MQTT.Testing.dll Syntax public class MockedMqttNetClientFactory : IMqttNetClientFactory Constructors | Improve this doc View source MockedMqttNetClientFactory(IInMemoryMqttBroker, IMockedMqttOptions) Initializes a new instance of the MockedMqttNetClientFactory class. Declaration public MockedMqttNetClientFactory(IInMemoryMqttBroker broker, IMockedMqttOptions options) Parameters Type Name Description IInMemoryMqttBroker broker The IInMemoryMqttBroker . IMockedMqttOptions options The IMockedMqttOptions . Methods | Improve this doc View source CreateClient() Declaration public IMqttClient CreateClient() Returns Type Description MQTTnet.Client.IMqttClient Implements Silverback.Messaging.Broker.Mqtt.IMqttNetClientFactory"
  },
  "api/Silverback.Messaging.Broker.Mqtt.Mocks.html": {
    "href": "api/Silverback.Messaging.Broker.Mqtt.Mocks.html",
    "title": "Namespace Silverback.Messaging.Broker.Mqtt.Mocks | Silverback",
    "keywords": "Namespace Silverback.Messaging.Broker.Mqtt.Mocks Classes MockedMqttClient A mocked implementation of MQTTnet.Client.IMqttClient from MQTTnet that connects with an in-memory broker. Interfaces IClientSession The session of a client connected to the IInMemoryMqttBroker . IInMemoryMqttBroker A mocked MQTT broker where the messages are just exchanged in-memory. Note that it isn't obviously possible to accurately replicate the message broker behavior and this implementation is just intended for testing purposes."
  },
  "api/Silverback.Messaging.Broker.Mqtt.Mocks.IClientSession.html": {
    "href": "api/Silverback.Messaging.Broker.Mqtt.Mocks.IClientSession.html",
    "title": "Interface IClientSession | Silverback",
    "keywords": "Interface IClientSession The session of a client connected to the IInMemoryMqttBroker . Namespace : Silverback.Messaging.Broker.Mqtt.Mocks Assembly : Silverback.Integration.MQTT.Testing.dll Syntax public interface IClientSession Properties | Improve this doc View source PendingMessagesCount Gets the number of pending messages ready to be pushed to the client. Declaration int PendingMessagesCount { get; } Property Value Type Description System.Int32"
  },
  "api/Silverback.Messaging.Broker.Mqtt.Mocks.IInMemoryMqttBroker.html": {
    "href": "api/Silverback.Messaging.Broker.Mqtt.Mocks.IInMemoryMqttBroker.html",
    "title": "Interface IInMemoryMqttBroker | Silverback",
    "keywords": "Interface IInMemoryMqttBroker A mocked MQTT broker where the messages are just exchanged in-memory. Note that it isn't obviously possible to accurately replicate the message broker behavior and this implementation is just intended for testing purposes. Namespace : Silverback.Messaging.Broker.Mqtt.Mocks Assembly : Silverback.Integration.MQTT.Testing.dll Syntax public interface IInMemoryMqttBroker Methods | Improve this doc View source Connect(MqttClientOptions, MockedMqttClient) Connects the specified client. Declaration void Connect(MqttClientOptions clientOptions, MockedMqttClient mockedMqttClient) Parameters Type Name Description MQTTnet.Client.MqttClientOptions clientOptions The client options. MockedMqttClient mockedMqttClient The MockedMqttClient . | Improve this doc View source Disconnect(String) Disconnects the specified client. Declaration void Disconnect(string clientId) Parameters Type Name Description System.String clientId The client identifier. | Improve this doc View source GetClientSession(String) Gets the IClientSession of the specified client. Declaration IClientSession GetClientSession(string clientId) Parameters Type Name Description System.String clientId The client id. Returns Type Description IClientSession The IClientSession . | Improve this doc View source GetMessages(String) Gets the messages that have been published to the specified topic. Declaration IReadOnlyList<MqttApplicationMessage> GetMessages(string topic) Parameters Type Name Description System.String topic The name of the topic. Returns Type Description System.Collections.Generic.IReadOnlyList < MQTTnet.MqttApplicationMessage > The messages published to the topic. | Improve this doc View source PublishAsync(String, MqttApplicationMessage, MqttClientOptions) Publishes a message. Declaration Task PublishAsync(string clientId, MqttApplicationMessage message, MqttClientOptions clientOptions) Parameters Type Name Description System.String clientId The client identifier. MQTTnet.MqttApplicationMessage message The MQTTnet.MqttApplicationMessage to be published. MQTTnet.Client.MqttClientOptions clientOptions The MQTTnet.Client.MqttClientOptions of the producing MQTTnet.Client.MqttClient . Returns Type Description System.Threading.Tasks.Task A System.Threading.Tasks.Task representing the asynchronous operation. | Improve this doc View source Subscribe(String, IReadOnlyCollection<String>) Subscribes the specified client to the specified topics. Declaration void Subscribe(string clientId, IReadOnlyCollection<string> topics) Parameters Type Name Description System.String clientId The client identifier. System.Collections.Generic.IReadOnlyCollection < System.String > topics The name of the topics or the topic filter strings. | Improve this doc View source Unsubscribe(String, IReadOnlyCollection<String>) Unsubscribes the specified client from the specified topics. Declaration void Unsubscribe(string clientId, IReadOnlyCollection<string> topics) Parameters Type Name Description System.String clientId The client identifier. System.Collections.Generic.IReadOnlyCollection < System.String > topics The name of the topics or the topic filter strings. | Improve this doc View source WaitUntilAllMessagesAreConsumedAsync(CancellationToken) Returns a System.Threading.Tasks.Task that completes when all messages routed to the consumers have been processed and committed. Declaration Task WaitUntilAllMessagesAreConsumedAsync(CancellationToken cancellationToken = default(CancellationToken)) Parameters Type Name Description System.Threading.CancellationToken cancellationToken A System.Threading.CancellationToken to observe while waiting for the task to complete. Returns Type Description System.Threading.Tasks.Task A System.Threading.Tasks.Task that completes when all messages have been processed."
  },
  "api/Silverback.Messaging.Broker.Mqtt.Mocks.MockedMqttClient.html": {
    "href": "api/Silverback.Messaging.Broker.Mqtt.Mocks.MockedMqttClient.html",
    "title": "Class MockedMqttClient | Silverback",
    "keywords": "Class MockedMqttClient A mocked implementation of MQTTnet.Client.IMqttClient from MQTTnet that connects with an in-memory broker. Inheritance System.Object MockedMqttClient Implements MQTTnet.Client.IMqttClient System.IDisposable Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Silverback.Messaging.Broker.Mqtt.Mocks Assembly : Silverback.Integration.MQTT.Testing.dll Syntax public sealed class MockedMqttClient : IMqttClient, IDisposable Constructors | Improve this doc View source MockedMqttClient(IInMemoryMqttBroker, IMockedMqttOptions) Initializes a new instance of the MockedMqttClient class. Declaration public MockedMqttClient(IInMemoryMqttBroker broker, IMockedMqttOptions mockOptions) Parameters Type Name Description IInMemoryMqttBroker broker The IInMemoryMqttBroker . IMockedMqttOptions mockOptions The IMockedMqttOptions . Properties | Improve this doc View source IsConnected Declaration public bool IsConnected { get; } Property Value Type Description System.Boolean | Improve this doc View source IsConsumerConnected Gets a value indicating whether the client is connected and a message handler is bound to it. Declaration public bool IsConsumerConnected { get; } Property Value Type Description System.Boolean | Improve this doc View source Options Declaration public MqttClientOptions Options { get; } Property Value Type Description MQTTnet.Client.MqttClientOptions Methods | Improve this doc View source ConnectAsync(MqttClientOptions, CancellationToken) Declaration public async Task<MqttClientConnectResult> ConnectAsync(MqttClientOptions options, CancellationToken cancellationToken = default(CancellationToken)) Parameters Type Name Description MQTTnet.Client.MqttClientOptions options System.Threading.CancellationToken cancellationToken Returns Type Description System.Threading.Tasks.Task < MQTTnet.Client.MqttClientConnectResult > | Improve this doc View source DisconnectAsync(MqttClientDisconnectOptions, CancellationToken) Declaration public async Task DisconnectAsync(MqttClientDisconnectOptions options, CancellationToken cancellationToken = default(CancellationToken)) Parameters Type Name Description MQTTnet.Client.MqttClientDisconnectOptions options System.Threading.CancellationToken cancellationToken Returns Type Description System.Threading.Tasks.Task | Improve this doc View source Dispose() Declaration public void Dispose() | Improve this doc View source PingAsync(CancellationToken) Declaration public Task PingAsync(CancellationToken cancellationToken = default(CancellationToken)) Parameters Type Name Description System.Threading.CancellationToken cancellationToken Returns Type Description System.Threading.Tasks.Task | Improve this doc View source PublishAsync(MqttApplicationMessage, CancellationToken) Declaration public async Task<MqttClientPublishResult> PublishAsync(MqttApplicationMessage applicationMessage, CancellationToken cancellationToken = default(CancellationToken)) Parameters Type Name Description MQTTnet.MqttApplicationMessage applicationMessage System.Threading.CancellationToken cancellationToken Returns Type Description System.Threading.Tasks.Task < MQTTnet.Client.MqttClientPublishResult > | Improve this doc View source SendExtendedAuthenticationExchangeDataAsync(MqttExtendedAuthenticationExchangeData, CancellationToken) Declaration public Task SendExtendedAuthenticationExchangeDataAsync(MqttExtendedAuthenticationExchangeData data, CancellationToken cancellationToken = default(CancellationToken)) Parameters Type Name Description MQTTnet.Client.MqttExtendedAuthenticationExchangeData data System.Threading.CancellationToken cancellationToken Returns Type Description System.Threading.Tasks.Task | Improve this doc View source SubscribeAsync(MqttClientSubscribeOptions, CancellationToken) Declaration public Task<MqttClientSubscribeResult> SubscribeAsync(MqttClientSubscribeOptions options, CancellationToken cancellationToken = default(CancellationToken)) Parameters Type Name Description MQTTnet.Client.MqttClientSubscribeOptions options System.Threading.CancellationToken cancellationToken Returns Type Description System.Threading.Tasks.Task < MQTTnet.Client.MqttClientSubscribeResult > | Improve this doc View source UnsubscribeAsync(MqttClientUnsubscribeOptions, CancellationToken) Declaration public Task<MqttClientUnsubscribeResult> UnsubscribeAsync(MqttClientUnsubscribeOptions options, CancellationToken cancellationToken = default(CancellationToken)) Parameters Type Name Description MQTTnet.Client.MqttClientUnsubscribeOptions options System.Threading.CancellationToken cancellationToken Returns Type Description System.Threading.Tasks.Task < MQTTnet.Client.MqttClientUnsubscribeResult > Events | Improve this doc View source ApplicationMessageReceivedAsync Declaration public event Func<MqttApplicationMessageReceivedEventArgs, Task> ApplicationMessageReceivedAsync Event Type Type Description System.Func < MQTTnet.Client.MqttApplicationMessageReceivedEventArgs , System.Threading.Tasks.Task > | Improve this doc View source ConnectedAsync Declaration public event Func<MqttClientConnectedEventArgs, Task> ConnectedAsync Event Type Type Description System.Func < MQTTnet.Client.MqttClientConnectedEventArgs , System.Threading.Tasks.Task > | Improve this doc View source ConnectingAsync Declaration public event Func<MqttClientConnectingEventArgs, Task> ConnectingAsync Event Type Type Description System.Func < MQTTnet.Client.MqttClientConnectingEventArgs , System.Threading.Tasks.Task > | Improve this doc View source DisconnectedAsync Declaration public event Func<MqttClientDisconnectedEventArgs, Task> DisconnectedAsync Event Type Type Description System.Func < MQTTnet.Client.MqttClientDisconnectedEventArgs , System.Threading.Tasks.Task > | Improve this doc View source InspectPacketAsync Declaration public event Func<InspectMqttPacketEventArgs, Task> InspectPacketAsync Event Type Type Description System.Func < MQTTnet.Diagnostics.InspectMqttPacketEventArgs , System.Threading.Tasks.Task > Implements MQTTnet.Client.IMqttClient System.IDisposable"
  },
  "api/Silverback.Messaging.Broker.Rabbit.html": {
    "href": "api/Silverback.Messaging.Broker.Rabbit.html",
    "title": "Namespace Silverback.Messaging.Broker.Rabbit | Silverback",
    "keywords": "Namespace Silverback.Messaging.Broker.Rabbit Classes RabbitConnectionFactory"
  },
  "api/Silverback.Messaging.Broker.Rabbit.RabbitConnectionFactory.html": {
    "href": "api/Silverback.Messaging.Broker.Rabbit.RabbitConnectionFactory.html",
    "title": "Class RabbitConnectionFactory | Silverback",
    "keywords": "Class RabbitConnectionFactory Inheritance System.Object RabbitConnectionFactory Implements System.IDisposable Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Silverback.Messaging.Broker.Rabbit Assembly : Silverback.Integration.RabbitMQ.dll Syntax public sealed class RabbitConnectionFactory : IRabbitConnectionFactory, IDisposable Methods | Improve this doc View source Dispose() Declaration public void Dispose() | Improve this doc View source GetChannel(RabbitConsumerEndpoint) Declaration public (IModel Channel, string QueueName) GetChannel(RabbitConsumerEndpoint endpoint) Parameters Type Name Description RabbitConsumerEndpoint endpoint Returns Type Description System.ValueTuple < RabbitMQ.Client.IModel , System.String > | Improve this doc View source GetChannel(RabbitProducerEndpoint, String) Declaration public IModel GetChannel(RabbitProducerEndpoint endpoint, string actualEndpointName) Parameters Type Name Description RabbitProducerEndpoint endpoint System.String actualEndpointName Returns Type Description RabbitMQ.Client.IModel Implements System.IDisposable"
  },
  "api/Silverback.Messaging.Broker.RabbitBroker.html": {
    "href": "api/Silverback.Messaging.Broker.RabbitBroker.html",
    "title": "Class RabbitBroker | Silverback",
    "keywords": "Class RabbitBroker An Silverback.Messaging.Broker.IBroker implementation for RabbitMQ. Inheritance System.Object Silverback.Messaging.Broker.Broker < RabbitProducerEndpoint , RabbitConsumerEndpoint > RabbitBroker Implements Silverback.Messaging.Broker.IBroker System.IDisposable Inherited Members Silverback.Messaging.Broker.Broker<Silverback.Messaging.RabbitProducerEndpoint, Silverback.Messaging.RabbitConsumerEndpoint>.ProducerEndpointType Silverback.Messaging.Broker.Broker<Silverback.Messaging.RabbitProducerEndpoint, Silverback.Messaging.RabbitConsumerEndpoint>.ConsumerEndpointType Silverback.Messaging.Broker.Broker<Silverback.Messaging.RabbitProducerEndpoint, Silverback.Messaging.RabbitConsumerEndpoint>.Producers Silverback.Messaging.Broker.Broker<Silverback.Messaging.RabbitProducerEndpoint, Silverback.Messaging.RabbitConsumerEndpoint>.Consumers Silverback.Messaging.Broker.Broker<Silverback.Messaging.RabbitProducerEndpoint, Silverback.Messaging.RabbitConsumerEndpoint>.IsConnected Silverback.Messaging.Broker.Broker<Silverback.Messaging.RabbitProducerEndpoint, Silverback.Messaging.RabbitConsumerEndpoint>.GetProducer(Silverback.Messaging.IProducerEndpoint) Silverback.Messaging.Broker.Broker<Silverback.Messaging.RabbitProducerEndpoint, Silverback.Messaging.RabbitConsumerEndpoint>.GetProducer(System.String) Silverback.Messaging.Broker.Broker<Silverback.Messaging.RabbitProducerEndpoint, Silverback.Messaging.RabbitConsumerEndpoint>.AddConsumer(Silverback.Messaging.IConsumerEndpoint) Silverback.Messaging.Broker.Broker<Silverback.Messaging.RabbitProducerEndpoint, Silverback.Messaging.RabbitConsumerEndpoint>.ConnectAsync() Silverback.Messaging.Broker.Broker<Silverback.Messaging.RabbitProducerEndpoint, Silverback.Messaging.RabbitConsumerEndpoint>.DisconnectAsync() Silverback.Messaging.Broker.Broker<Silverback.Messaging.RabbitProducerEndpoint, Silverback.Messaging.RabbitConsumerEndpoint>.Dispose() Silverback.Messaging.Broker.Broker<Silverback.Messaging.RabbitProducerEndpoint, Silverback.Messaging.RabbitConsumerEndpoint>.InstantiateProducer(Silverback.Messaging.RabbitProducerEndpoint, Silverback.Messaging.Broker.Behaviors.IBrokerBehaviorsProvider<Silverback.Messaging.Broker.Behaviors.IProducerBehavior>, System.IServiceProvider) Silverback.Messaging.Broker.Broker<Silverback.Messaging.RabbitProducerEndpoint, Silverback.Messaging.RabbitConsumerEndpoint>.InstantiateConsumer(Silverback.Messaging.RabbitConsumerEndpoint, Silverback.Messaging.Broker.Behaviors.IBrokerBehaviorsProvider<Silverback.Messaging.Broker.Behaviors.IConsumerBehavior>, System.IServiceProvider) Silverback.Messaging.Broker.Broker<Silverback.Messaging.RabbitProducerEndpoint, Silverback.Messaging.RabbitConsumerEndpoint>.ConnectAsync(System.Collections.Generic.IReadOnlyCollection<Silverback.Messaging.Broker.IProducer>, System.Collections.Generic.IReadOnlyCollection<Silverback.Messaging.Broker.IConsumer>) Silverback.Messaging.Broker.Broker<Silverback.Messaging.RabbitProducerEndpoint, Silverback.Messaging.RabbitConsumerEndpoint>.DisconnectAsync(System.Collections.Generic.IReadOnlyCollection<Silverback.Messaging.Broker.IProducer>, System.Collections.Generic.IReadOnlyCollection<Silverback.Messaging.Broker.IConsumer>) Silverback.Messaging.Broker.Broker<Silverback.Messaging.RabbitProducerEndpoint, Silverback.Messaging.RabbitConsumerEndpoint>.Dispose(System.Boolean) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Silverback.Messaging.Broker Assembly : Silverback.Integration.RabbitMQ.dll Syntax public class RabbitBroker : Broker<RabbitProducerEndpoint, RabbitConsumerEndpoint>, IBroker, IDisposable Constructors | Improve this doc View source RabbitBroker(IServiceProvider) Initializes a new instance of the RabbitBroker class. Declaration public RabbitBroker(IServiceProvider serviceProvider) Parameters Type Name Description System.IServiceProvider serviceProvider The System.IServiceProvider to be used to resolve the required services. Methods | Improve this doc View source InstantiateConsumer(RabbitConsumerEndpoint, IBrokerBehaviorsProvider<IConsumerBehavior>, IServiceProvider) Declaration protected override IConsumer InstantiateConsumer(RabbitConsumerEndpoint endpoint, IBrokerBehaviorsProvider<IConsumerBehavior> behaviorsProvider, IServiceProvider serviceProvider) Parameters Type Name Description RabbitConsumerEndpoint endpoint Silverback.Messaging.Broker.Behaviors.IBrokerBehaviorsProvider < Silverback.Messaging.Broker.Behaviors.IConsumerBehavior > behaviorsProvider System.IServiceProvider serviceProvider Returns Type Description Silverback.Messaging.Broker.IConsumer Overrides Silverback.Messaging.Broker.Broker<Silverback.Messaging.RabbitProducerEndpoint, Silverback.Messaging.RabbitConsumerEndpoint>.InstantiateConsumer(Silverback.Messaging.RabbitConsumerEndpoint, Silverback.Messaging.Broker.Behaviors.IBrokerBehaviorsProvider<Silverback.Messaging.Broker.Behaviors.IConsumerBehavior>, System.IServiceProvider) | Improve this doc View source InstantiateProducer(RabbitProducerEndpoint, IBrokerBehaviorsProvider<IProducerBehavior>, IServiceProvider) Declaration protected override IProducer InstantiateProducer(RabbitProducerEndpoint endpoint, IBrokerBehaviorsProvider<IProducerBehavior> behaviorsProvider, IServiceProvider serviceProvider) Parameters Type Name Description RabbitProducerEndpoint endpoint Silverback.Messaging.Broker.Behaviors.IBrokerBehaviorsProvider < Silverback.Messaging.Broker.Behaviors.IProducerBehavior > behaviorsProvider System.IServiceProvider serviceProvider Returns Type Description Silverback.Messaging.Broker.IProducer Overrides Silverback.Messaging.Broker.Broker<Silverback.Messaging.RabbitProducerEndpoint, Silverback.Messaging.RabbitConsumerEndpoint>.InstantiateProducer(Silverback.Messaging.RabbitProducerEndpoint, Silverback.Messaging.Broker.Behaviors.IBrokerBehaviorsProvider<Silverback.Messaging.Broker.Behaviors.IProducerBehavior>, System.IServiceProvider) Implements Silverback.Messaging.Broker.IBroker System.IDisposable"
  },
  "api/Silverback.Messaging.Broker.RabbitConsumer.html": {
    "href": "api/Silverback.Messaging.Broker.RabbitConsumer.html",
    "title": "Class RabbitConsumer | Silverback",
    "keywords": "Class RabbitConsumer Inheritance System.Object Silverback.Messaging.Broker.Consumer Silverback.Messaging.Broker.Consumer < RabbitBroker , RabbitConsumerEndpoint , RabbitDeliveryTag > RabbitConsumer Implements Silverback.Messaging.Broker.IConsumer System.IDisposable Inherited Members Silverback.Messaging.Broker.Consumer<Silverback.Messaging.Broker.RabbitBroker, Silverback.Messaging.RabbitConsumerEndpoint, Silverback.Messaging.Broker.RabbitDeliveryTag>.Broker Silverback.Messaging.Broker.Consumer<Silverback.Messaging.Broker.RabbitBroker, Silverback.Messaging.RabbitConsumerEndpoint, Silverback.Messaging.Broker.RabbitDeliveryTag>.Endpoint Silverback.Messaging.Broker.Consumer<Silverback.Messaging.Broker.RabbitBroker, Silverback.Messaging.RabbitConsumerEndpoint, Silverback.Messaging.Broker.RabbitDeliveryTag>.CommitCoreAsync(System.Collections.Generic.IReadOnlyCollection<Silverback.Messaging.Broker.IBrokerMessageIdentifier>) Silverback.Messaging.Broker.Consumer<Silverback.Messaging.Broker.RabbitBroker, Silverback.Messaging.RabbitConsumerEndpoint, Silverback.Messaging.Broker.RabbitDeliveryTag>.RollbackCoreAsync(System.Collections.Generic.IReadOnlyCollection<Silverback.Messaging.Broker.IBrokerMessageIdentifier>) Silverback.Messaging.Broker.Consumer<Silverback.Messaging.Broker.RabbitBroker, Silverback.Messaging.RabbitConsumerEndpoint, Silverback.Messaging.Broker.RabbitDeliveryTag>.CommitCoreAsync(System.Collections.Generic.IReadOnlyCollection<Silverback.Messaging.Broker.RabbitDeliveryTag>) Silverback.Messaging.Broker.Consumer<Silverback.Messaging.Broker.RabbitBroker, Silverback.Messaging.RabbitConsumerEndpoint, Silverback.Messaging.Broker.RabbitDeliveryTag>.RollbackCoreAsync(System.Collections.Generic.IReadOnlyCollection<Silverback.Messaging.Broker.RabbitDeliveryTag>) Silverback.Messaging.Broker.Consumer<Silverback.Messaging.Broker.RabbitBroker, Silverback.Messaging.RabbitConsumerEndpoint, Silverback.Messaging.Broker.RabbitDeliveryTag>.GetSequenceStore(Silverback.Messaging.Broker.IBrokerMessageIdentifier) Silverback.Messaging.Broker.Consumer<Silverback.Messaging.Broker.RabbitBroker, Silverback.Messaging.RabbitConsumerEndpoint, Silverback.Messaging.Broker.RabbitDeliveryTag>.GetSequenceStore(Silverback.Messaging.Broker.RabbitDeliveryTag) Silverback.Messaging.Broker.Consumer.Id Silverback.Messaging.Broker.Consumer.Broker Silverback.Messaging.Broker.Consumer.Endpoint Silverback.Messaging.Broker.Consumer.StatusInfo Silverback.Messaging.Broker.Consumer.IsConnecting Silverback.Messaging.Broker.Consumer.IsConnected Silverback.Messaging.Broker.Consumer.IsConsuming Silverback.Messaging.Broker.Consumer.ServiceProvider Silverback.Messaging.Broker.Consumer.SequenceStores Silverback.Messaging.Broker.Consumer.IsDisconnecting Silverback.Messaging.Broker.Consumer.IsStopping Silverback.Messaging.Broker.Consumer.ConnectAsync() Silverback.Messaging.Broker.Consumer.DisconnectAsync() Silverback.Messaging.Broker.Consumer.TriggerReconnectAsync() Silverback.Messaging.Broker.Consumer.StartAsync() Silverback.Messaging.Broker.Consumer.StopAsync() Silverback.Messaging.Broker.Consumer.CommitAsync(Silverback.Messaging.Broker.IBrokerMessageIdentifier) Silverback.Messaging.Broker.Consumer.CommitAsync(System.Collections.Generic.IReadOnlyCollection<Silverback.Messaging.Broker.IBrokerMessageIdentifier>) Silverback.Messaging.Broker.Consumer.RollbackAsync(Silverback.Messaging.Broker.IBrokerMessageIdentifier) Silverback.Messaging.Broker.Consumer.RollbackAsync(System.Collections.Generic.IReadOnlyCollection<Silverback.Messaging.Broker.IBrokerMessageIdentifier>) Silverback.Messaging.Broker.Consumer.IncrementFailedAttempts(Silverback.Messaging.Messages.IRawInboundEnvelope) Silverback.Messaging.Broker.Consumer.Dispose() Silverback.Messaging.Broker.Consumer.GetCurrentSequenceStores() Silverback.Messaging.Broker.Consumer.CommitCoreAsync(System.Collections.Generic.IReadOnlyCollection<Silverback.Messaging.Broker.IBrokerMessageIdentifier>) Silverback.Messaging.Broker.Consumer.RollbackCoreAsync(System.Collections.Generic.IReadOnlyCollection<Silverback.Messaging.Broker.IBrokerMessageIdentifier>) Silverback.Messaging.Broker.Consumer.GetSequenceStore(Silverback.Messaging.Broker.IBrokerMessageIdentifier) Silverback.Messaging.Broker.Consumer.HandleMessageAsync(System.Byte[], System.Collections.Generic.IReadOnlyCollection<Silverback.Messaging.Messages.MessageHeader>, System.String, Silverback.Messaging.Broker.IBrokerMessageIdentifier) Silverback.Messaging.Broker.Consumer.SetReadyStatus() Silverback.Messaging.Broker.Consumer.RevertReadyStatus() Silverback.Messaging.Broker.Consumer.Dispose(System.Boolean) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Silverback.Messaging.Broker Assembly : Silverback.Integration.RabbitMQ.dll Syntax public class RabbitConsumer : Consumer<RabbitBroker, RabbitConsumerEndpoint, RabbitDeliveryTag>, IConsumer, IDisposable Constructors | Improve this doc View source RabbitConsumer(RabbitBroker, RabbitConsumerEndpoint, IBrokerBehaviorsProvider<IConsumerBehavior>, IServiceProvider, IInboundLogger<RabbitConsumer>) Initializes a new instance of the RabbitConsumer class. Declaration public RabbitConsumer(RabbitBroker broker, RabbitConsumerEndpoint endpoint, IBrokerBehaviorsProvider<IConsumerBehavior> behaviorsProvider, IServiceProvider serviceProvider, IInboundLogger<RabbitConsumer> logger) Parameters Type Name Description RabbitBroker broker The Silverback.Messaging.Broker.IBroker that is instantiating the consumer. RabbitConsumerEndpoint endpoint The endpoint to be consumed. Silverback.Messaging.Broker.Behaviors.IBrokerBehaviorsProvider < Silverback.Messaging.Broker.Behaviors.IConsumerBehavior > behaviorsProvider The Silverback.Messaging.Broker.Behaviors.IBrokerBehaviorsProvider<TBehavior> . System.IServiceProvider serviceProvider The System.IServiceProvider to be used to resolve the needed services. Silverback.Diagnostics.IInboundLogger < RabbitConsumer > logger The Silverback.Diagnostics.IInboundLogger<TCategoryName> . Methods | Improve this doc View source CommitCoreAsync(IReadOnlyCollection<RabbitDeliveryTag>) Declaration protected override Task CommitCoreAsync(IReadOnlyCollection<RabbitDeliveryTag> brokerMessageIdentifiers) Parameters Type Name Description System.Collections.Generic.IReadOnlyCollection < RabbitDeliveryTag > brokerMessageIdentifiers Returns Type Description System.Threading.Tasks.Task Overrides Silverback.Messaging.Broker.Consumer<Silverback.Messaging.Broker.RabbitBroker, Silverback.Messaging.RabbitConsumerEndpoint, Silverback.Messaging.Broker.RabbitDeliveryTag>.CommitCoreAsync(System.Collections.Generic.IReadOnlyCollection<Silverback.Messaging.Broker.RabbitDeliveryTag>) | Improve this doc View source ConnectCoreAsync() Declaration protected override Task ConnectCoreAsync() Returns Type Description System.Threading.Tasks.Task Overrides Silverback.Messaging.Broker.Consumer.ConnectCoreAsync() | Improve this doc View source DisconnectCoreAsync() Declaration protected override Task DisconnectCoreAsync() Returns Type Description System.Threading.Tasks.Task Overrides Silverback.Messaging.Broker.Consumer.DisconnectCoreAsync() | Improve this doc View source RollbackCoreAsync(IReadOnlyCollection<RabbitDeliveryTag>) Declaration protected override Task RollbackCoreAsync(IReadOnlyCollection<RabbitDeliveryTag> brokerMessageIdentifiers) Parameters Type Name Description System.Collections.Generic.IReadOnlyCollection < RabbitDeliveryTag > brokerMessageIdentifiers Returns Type Description System.Threading.Tasks.Task Overrides Silverback.Messaging.Broker.Consumer<Silverback.Messaging.Broker.RabbitBroker, Silverback.Messaging.RabbitConsumerEndpoint, Silverback.Messaging.Broker.RabbitDeliveryTag>.RollbackCoreAsync(System.Collections.Generic.IReadOnlyCollection<Silverback.Messaging.Broker.RabbitDeliveryTag>) | Improve this doc View source StartCoreAsync() Declaration protected override Task StartCoreAsync() Returns Type Description System.Threading.Tasks.Task Overrides Silverback.Messaging.Broker.Consumer.StartCoreAsync() | Improve this doc View source StopCoreAsync() Declaration protected override Task StopCoreAsync() Returns Type Description System.Threading.Tasks.Task Overrides Silverback.Messaging.Broker.Consumer.StopCoreAsync() | Improve this doc View source WaitUntilConsumingStoppedCoreAsync() Declaration protected override Task WaitUntilConsumingStoppedCoreAsync() Returns Type Description System.Threading.Tasks.Task Overrides Silverback.Messaging.Broker.Consumer.WaitUntilConsumingStoppedCoreAsync() Implements Silverback.Messaging.Broker.IConsumer System.IDisposable"
  },
  "api/Silverback.Messaging.Broker.RabbitDeliveryTag.html": {
    "href": "api/Silverback.Messaging.Broker.RabbitDeliveryTag.html",
    "title": "Class RabbitDeliveryTag | Silverback",
    "keywords": "Class RabbitDeliveryTag Represents the unique message identifier assigned by the message broker. Inheritance System.Object RabbitDeliveryTag Implements Silverback.Messaging.Broker.IBrokerMessageIdentifier System.IEquatable < Silverback.Messaging.Broker.IBrokerMessageIdentifier > Inherited Members System.Object.Equals(System.Object, System.Object) System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Silverback.Messaging.Broker Assembly : Silverback.Integration.RabbitMQ.dll Syntax public sealed class RabbitDeliveryTag : IBrokerMessageIdentifier, IEquatable<IBrokerMessageIdentifier> Constructors | Improve this doc View source RabbitDeliveryTag(String, String) Initializes a new instance of the RabbitDeliveryTag class. Declaration public RabbitDeliveryTag(string key, string value) Parameters Type Name Description System.String key The unique key of the queue, topic or partition the message was produced to or consumed from. System.String value The identifier value. | Improve this doc View source RabbitDeliveryTag(String, UInt64) Initializes a new instance of the RabbitDeliveryTag class. Declaration public RabbitDeliveryTag(string consumerTag, ulong deliveryTag) Parameters Type Name Description System.String consumerTag The consumer identifier. System.UInt64 deliveryTag The delivery (message) identifier. Properties | Improve this doc View source ConsumerTag Gets the consumer identifier. Declaration public string ConsumerTag { get; } Property Value Type Description System.String | Improve this doc View source DeliveryTag Gets the delivery (message) identifier. Declaration public ulong DeliveryTag { get; } Property Value Type Description System.UInt64 | Improve this doc View source Key Declaration public string Key { get; } Property Value Type Description System.String | Improve this doc View source Value Declaration public string Value { get; } Property Value Type Description System.String Methods | Improve this doc View source Equals(IBrokerMessageIdentifier) Declaration public bool Equals(IBrokerMessageIdentifier other) Parameters Type Name Description Silverback.Messaging.Broker.IBrokerMessageIdentifier other Returns Type Description System.Boolean | Improve this doc View source Equals(Object) Declaration public override bool Equals(object obj) Parameters Type Name Description System.Object obj Returns Type Description System.Boolean Overrides System.Object.Equals(System.Object) | Improve this doc View source GetHashCode() Declaration public override int GetHashCode() Returns Type Description System.Int32 Overrides System.Object.GetHashCode() | Improve this doc View source ToLogString() Declaration public string ToLogString() Returns Type Description System.String | Improve this doc View source ToVerboseLogString() Declaration public string ToVerboseLogString() Returns Type Description System.String Implements Silverback.Messaging.Broker.IBrokerMessageIdentifier System.IEquatable<T>"
  },
  "api/Silverback.Messaging.Broker.RabbitProducer.html": {
    "href": "api/Silverback.Messaging.Broker.RabbitProducer.html",
    "title": "Class RabbitProducer | Silverback",
    "keywords": "Class RabbitProducer Inheritance System.Object Silverback.Messaging.Broker.Producer Silverback.Messaging.Broker.Producer < RabbitBroker , RabbitProducerEndpoint > RabbitProducer Implements Silverback.Messaging.Broker.IProducer System.IDisposable Inherited Members Silverback.Messaging.Broker.Producer<Silverback.Messaging.Broker.RabbitBroker, Silverback.Messaging.RabbitProducerEndpoint>.Broker Silverback.Messaging.Broker.Producer<Silverback.Messaging.Broker.RabbitBroker, Silverback.Messaging.RabbitProducerEndpoint>.Endpoint Silverback.Messaging.Broker.Producer.Id Silverback.Messaging.Broker.Producer.Broker Silverback.Messaging.Broker.Producer.Endpoint Silverback.Messaging.Broker.Producer.IsConnecting Silverback.Messaging.Broker.Producer.IsConnected Silverback.Messaging.Broker.Producer.ConnectAsync() Silverback.Messaging.Broker.Producer.DisconnectAsync() Silverback.Messaging.Broker.Producer.Produce(System.Object, System.Collections.Generic.IReadOnlyCollection<Silverback.Messaging.Messages.MessageHeader>) Silverback.Messaging.Broker.Producer.Produce(Silverback.Messaging.Messages.IOutboundEnvelope) Silverback.Messaging.Broker.Producer.Produce(System.Object, System.Collections.Generic.IReadOnlyCollection<Silverback.Messaging.Messages.MessageHeader>, System.Action<Silverback.Messaging.Broker.IBrokerMessageIdentifier>, System.Action<System.Exception>) Silverback.Messaging.Broker.Producer.Produce(Silverback.Messaging.Messages.IOutboundEnvelope, System.Action<Silverback.Messaging.Broker.IBrokerMessageIdentifier>, System.Action<System.Exception>) Silverback.Messaging.Broker.Producer.RawProduce(System.Byte[], System.Collections.Generic.IReadOnlyCollection<Silverback.Messaging.Messages.MessageHeader>) Silverback.Messaging.Broker.Producer.RawProduce(System.IO.Stream, System.Collections.Generic.IReadOnlyCollection<Silverback.Messaging.Messages.MessageHeader>) Silverback.Messaging.Broker.Producer.RawProduce(System.String, System.Byte[], System.Collections.Generic.IReadOnlyCollection<Silverback.Messaging.Messages.MessageHeader>) Silverback.Messaging.Broker.Producer.RawProduce(System.String, System.IO.Stream, System.Collections.Generic.IReadOnlyCollection<Silverback.Messaging.Messages.MessageHeader>) Silverback.Messaging.Broker.Producer.RawProduce(System.Byte[], System.Collections.Generic.IReadOnlyCollection<Silverback.Messaging.Messages.MessageHeader>, System.Action<Silverback.Messaging.Broker.IBrokerMessageIdentifier>, System.Action<System.Exception>) Silverback.Messaging.Broker.Producer.RawProduce(System.IO.Stream, System.Collections.Generic.IReadOnlyCollection<Silverback.Messaging.Messages.MessageHeader>, System.Action<Silverback.Messaging.Broker.IBrokerMessageIdentifier>, System.Action<System.Exception>) Silverback.Messaging.Broker.Producer.RawProduce(System.String, System.Byte[], System.Collections.Generic.IReadOnlyCollection<Silverback.Messaging.Messages.MessageHeader>, System.Action<Silverback.Messaging.Broker.IBrokerMessageIdentifier>, System.Action<System.Exception>) Silverback.Messaging.Broker.Producer.RawProduce(System.String, System.IO.Stream, System.Collections.Generic.IReadOnlyCollection<Silverback.Messaging.Messages.MessageHeader>, System.Action<Silverback.Messaging.Broker.IBrokerMessageIdentifier>, System.Action<System.Exception>) Silverback.Messaging.Broker.Producer.ProduceAsync(System.Object, System.Collections.Generic.IReadOnlyCollection<Silverback.Messaging.Messages.MessageHeader>) Silverback.Messaging.Broker.Producer.ProduceAsync(Silverback.Messaging.Messages.IOutboundEnvelope) Silverback.Messaging.Broker.Producer.ProduceAsync(System.Object, System.Collections.Generic.IReadOnlyCollection<Silverback.Messaging.Messages.MessageHeader>, System.Action<Silverback.Messaging.Broker.IBrokerMessageIdentifier>, System.Action<System.Exception>) Silverback.Messaging.Broker.Producer.ProduceAsync(Silverback.Messaging.Messages.IOutboundEnvelope, System.Action<Silverback.Messaging.Broker.IBrokerMessageIdentifier>, System.Action<System.Exception>) Silverback.Messaging.Broker.Producer.RawProduceAsync(System.Byte[], System.Collections.Generic.IReadOnlyCollection<Silverback.Messaging.Messages.MessageHeader>) Silverback.Messaging.Broker.Producer.RawProduceAsync(System.IO.Stream, System.Collections.Generic.IReadOnlyCollection<Silverback.Messaging.Messages.MessageHeader>) Silverback.Messaging.Broker.Producer.RawProduceAsync(System.String, System.Byte[], System.Collections.Generic.IReadOnlyCollection<Silverback.Messaging.Messages.MessageHeader>) Silverback.Messaging.Broker.Producer.RawProduceAsync(System.String, System.IO.Stream, System.Collections.Generic.IReadOnlyCollection<Silverback.Messaging.Messages.MessageHeader>) Silverback.Messaging.Broker.Producer.RawProduceAsync(System.Byte[], System.Collections.Generic.IReadOnlyCollection<Silverback.Messaging.Messages.MessageHeader>, System.Action<Silverback.Messaging.Broker.IBrokerMessageIdentifier>, System.Action<System.Exception>) Silverback.Messaging.Broker.Producer.RawProduceAsync(System.IO.Stream, System.Collections.Generic.IReadOnlyCollection<Silverback.Messaging.Messages.MessageHeader>, System.Action<Silverback.Messaging.Broker.IBrokerMessageIdentifier>, System.Action<System.Exception>) Silverback.Messaging.Broker.Producer.RawProduceAsync(System.String, System.Byte[], System.Collections.Generic.IReadOnlyCollection<Silverback.Messaging.Messages.MessageHeader>, System.Action<Silverback.Messaging.Broker.IBrokerMessageIdentifier>, System.Action<System.Exception>) Silverback.Messaging.Broker.Producer.RawProduceAsync(System.String, System.IO.Stream, System.Collections.Generic.IReadOnlyCollection<Silverback.Messaging.Messages.MessageHeader>, System.Action<Silverback.Messaging.Broker.IBrokerMessageIdentifier>, System.Action<System.Exception>) Silverback.Messaging.Broker.Producer.ConnectCoreAsync() Silverback.Messaging.Broker.Producer.DisconnectCoreAsync() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Silverback.Messaging.Broker Assembly : Silverback.Integration.RabbitMQ.dll Syntax public sealed class RabbitProducer : Producer<RabbitBroker, RabbitProducerEndpoint>, IProducer, IDisposable Constructors | Improve this doc View source RabbitProducer(RabbitBroker, RabbitProducerEndpoint, IBrokerBehaviorsProvider<IProducerBehavior>, IServiceProvider, IOutboundLogger<Producer>) Initializes a new instance of the RabbitProducer class. Declaration public RabbitProducer(RabbitBroker broker, RabbitProducerEndpoint endpoint, IBrokerBehaviorsProvider<IProducerBehavior> behaviorsProvider, IServiceProvider serviceProvider, IOutboundLogger<Producer> logger) Parameters Type Name Description RabbitBroker broker The Silverback.Messaging.Broker.IBroker that instantiated this producer. RabbitProducerEndpoint endpoint The endpoint to produce to. Silverback.Messaging.Broker.Behaviors.IBrokerBehaviorsProvider < Silverback.Messaging.Broker.Behaviors.IProducerBehavior > behaviorsProvider The Silverback.Messaging.Broker.Behaviors.IBrokerBehaviorsProvider<TBehavior> . System.IServiceProvider serviceProvider The System.IServiceProvider to be used to resolve the needed services. Silverback.Diagnostics.IOutboundLogger < Silverback.Messaging.Broker.Producer > logger The ISilverbackLogger . Methods | Improve this doc View source Dispose() Declaration public void Dispose() | Improve this doc View source ProduceCore(Object, Byte[], IReadOnlyCollection<MessageHeader>, String) Declaration protected override IBrokerMessageIdentifier ProduceCore(object message, byte[] messageBytes, IReadOnlyCollection<MessageHeader> headers, string actualEndpointName) Parameters Type Name Description System.Object message System.Byte [] messageBytes System.Collections.Generic.IReadOnlyCollection < Silverback.Messaging.Messages.MessageHeader > headers System.String actualEndpointName Returns Type Description Silverback.Messaging.Broker.IBrokerMessageIdentifier Overrides Silverback.Messaging.Broker.Producer.ProduceCore(System.Object, System.Byte[], System.Collections.Generic.IReadOnlyCollection<Silverback.Messaging.Messages.MessageHeader>, System.String) | Improve this doc View source ProduceCore(Object, Byte[], IReadOnlyCollection<MessageHeader>, String, Action<IBrokerMessageIdentifier>, Action<Exception>) Declaration protected override void ProduceCore(object message, byte[] messageBytes, IReadOnlyCollection<MessageHeader> headers, string actualEndpointName, Action<IBrokerMessageIdentifier> onSuccess, Action<Exception> onError) Parameters Type Name Description System.Object message System.Byte [] messageBytes System.Collections.Generic.IReadOnlyCollection < Silverback.Messaging.Messages.MessageHeader > headers System.String actualEndpointName System.Action < Silverback.Messaging.Broker.IBrokerMessageIdentifier > onSuccess System.Action < System.Exception > onError Overrides Silverback.Messaging.Broker.Producer.ProduceCore(System.Object, System.Byte[], System.Collections.Generic.IReadOnlyCollection<Silverback.Messaging.Messages.MessageHeader>, System.String, System.Action<Silverback.Messaging.Broker.IBrokerMessageIdentifier>, System.Action<System.Exception>) | Improve this doc View source ProduceCore(Object, Stream, IReadOnlyCollection<MessageHeader>, String) Declaration protected override IBrokerMessageIdentifier ProduceCore(object message, Stream messageStream, IReadOnlyCollection<MessageHeader> headers, string actualEndpointName) Parameters Type Name Description System.Object message System.IO.Stream messageStream System.Collections.Generic.IReadOnlyCollection < Silverback.Messaging.Messages.MessageHeader > headers System.String actualEndpointName Returns Type Description Silverback.Messaging.Broker.IBrokerMessageIdentifier Overrides Silverback.Messaging.Broker.Producer.ProduceCore(System.Object, System.IO.Stream, System.Collections.Generic.IReadOnlyCollection<Silverback.Messaging.Messages.MessageHeader>, System.String) | Improve this doc View source ProduceCore(Object, Stream, IReadOnlyCollection<MessageHeader>, String, Action<IBrokerMessageIdentifier>, Action<Exception>) Declaration protected override void ProduceCore(object message, Stream messageStream, IReadOnlyCollection<MessageHeader> headers, string actualEndpointName, Action<IBrokerMessageIdentifier> onSuccess, Action<Exception> onError) Parameters Type Name Description System.Object message System.IO.Stream messageStream System.Collections.Generic.IReadOnlyCollection < Silverback.Messaging.Messages.MessageHeader > headers System.String actualEndpointName System.Action < Silverback.Messaging.Broker.IBrokerMessageIdentifier > onSuccess System.Action < System.Exception > onError Overrides Silverback.Messaging.Broker.Producer.ProduceCore(System.Object, System.IO.Stream, System.Collections.Generic.IReadOnlyCollection<Silverback.Messaging.Messages.MessageHeader>, System.String, System.Action<Silverback.Messaging.Broker.IBrokerMessageIdentifier>, System.Action<System.Exception>) | Improve this doc View source ProduceCoreAsync(Object, Byte[], IReadOnlyCollection<MessageHeader>, String) Declaration protected override async Task<IBrokerMessageIdentifier> ProduceCoreAsync(object message, byte[] messageBytes, IReadOnlyCollection<MessageHeader> headers, string actualEndpointName) Parameters Type Name Description System.Object message System.Byte [] messageBytes System.Collections.Generic.IReadOnlyCollection < Silverback.Messaging.Messages.MessageHeader > headers System.String actualEndpointName Returns Type Description System.Threading.Tasks.Task < Silverback.Messaging.Broker.IBrokerMessageIdentifier > Overrides Silverback.Messaging.Broker.Producer.ProduceCoreAsync(System.Object, System.Byte[], System.Collections.Generic.IReadOnlyCollection<Silverback.Messaging.Messages.MessageHeader>, System.String) | Improve this doc View source ProduceCoreAsync(Object, Byte[], IReadOnlyCollection<MessageHeader>, String, Action<IBrokerMessageIdentifier>, Action<Exception>) Declaration protected override async Task ProduceCoreAsync(object message, byte[] messageBytes, IReadOnlyCollection<MessageHeader> headers, string actualEndpointName, Action<IBrokerMessageIdentifier> onSuccess, Action<Exception> onError) Parameters Type Name Description System.Object message System.Byte [] messageBytes System.Collections.Generic.IReadOnlyCollection < Silverback.Messaging.Messages.MessageHeader > headers System.String actualEndpointName System.Action < Silverback.Messaging.Broker.IBrokerMessageIdentifier > onSuccess System.Action < System.Exception > onError Returns Type Description System.Threading.Tasks.Task Overrides Silverback.Messaging.Broker.Producer.ProduceCoreAsync(System.Object, System.Byte[], System.Collections.Generic.IReadOnlyCollection<Silverback.Messaging.Messages.MessageHeader>, System.String, System.Action<Silverback.Messaging.Broker.IBrokerMessageIdentifier>, System.Action<System.Exception>) | Improve this doc View source ProduceCoreAsync(Object, Stream, IReadOnlyCollection<MessageHeader>, String) Declaration protected override async Task<IBrokerMessageIdentifier> ProduceCoreAsync(object message, Stream messageStream, IReadOnlyCollection<MessageHeader> headers, string actualEndpointName) Parameters Type Name Description System.Object message System.IO.Stream messageStream System.Collections.Generic.IReadOnlyCollection < Silverback.Messaging.Messages.MessageHeader > headers System.String actualEndpointName Returns Type Description System.Threading.Tasks.Task < Silverback.Messaging.Broker.IBrokerMessageIdentifier > Overrides Silverback.Messaging.Broker.Producer.ProduceCoreAsync(System.Object, System.IO.Stream, System.Collections.Generic.IReadOnlyCollection<Silverback.Messaging.Messages.MessageHeader>, System.String) | Improve this doc View source ProduceCoreAsync(Object, Stream, IReadOnlyCollection<MessageHeader>, String, Action<IBrokerMessageIdentifier>, Action<Exception>) Declaration protected override async Task ProduceCoreAsync(object message, Stream messageStream, IReadOnlyCollection<MessageHeader> headers, string actualEndpointName, Action<IBrokerMessageIdentifier> onSuccess, Action<Exception> onError) Parameters Type Name Description System.Object message System.IO.Stream messageStream System.Collections.Generic.IReadOnlyCollection < Silverback.Messaging.Messages.MessageHeader > headers System.String actualEndpointName System.Action < Silverback.Messaging.Broker.IBrokerMessageIdentifier > onSuccess System.Action < System.Exception > onError Returns Type Description System.Threading.Tasks.Task Overrides Silverback.Messaging.Broker.Producer.ProduceCoreAsync(System.Object, System.IO.Stream, System.Collections.Generic.IReadOnlyCollection<Silverback.Messaging.Messages.MessageHeader>, System.String, System.Action<Silverback.Messaging.Broker.IBrokerMessageIdentifier>, System.Action<System.Exception>) Implements Silverback.Messaging.Broker.IProducer System.IDisposable"
  },
  "api/Silverback.Messaging.Configuration.ConsumerEndpointBuilderDeserializeJsonUsingNewtonsoftExtensions.html": {
    "href": "api/Silverback.Messaging.Configuration.ConsumerEndpointBuilderDeserializeJsonUsingNewtonsoftExtensions.html",
    "title": "Class ConsumerEndpointBuilderDeserializeJsonUsingNewtonsoftExtensions | Silverback",
    "keywords": "Class ConsumerEndpointBuilderDeserializeJsonUsingNewtonsoftExtensions Adds the DeserializeJsonUsingNewtonsoft method to the Silverback.Messaging.Configuration.ConsumerEndpointBuilder<TEndpoint, TBuilder> . Inheritance System.Object ConsumerEndpointBuilderDeserializeJsonUsingNewtonsoftExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Silverback.Messaging.Configuration Assembly : Silverback.Integration.Newtonsoft.dll Syntax public static class ConsumerEndpointBuilderDeserializeJsonUsingNewtonsoftExtensions Methods | Improve this doc View source DeserializeJsonUsingNewtonsoft<TBuilder>(IConsumerEndpointBuilder<TBuilder>, Action<INewtonsoftJsonMessageSerializerBuilder>) Sets the serializer to an instance of NewtonsoftJsonMessageSerializer (or NewtonsoftJsonMessageSerializer<TMessage> ) to deserialize the consumed JSON. By default this serializer relies on the message type header to determine the type of the message to be deserialized. This behavior can be changed using the builder action and specifying a fixed message type. Declaration public static TBuilder DeserializeJsonUsingNewtonsoft<TBuilder>(this IConsumerEndpointBuilder<TBuilder> endpointBuilder, Action<INewtonsoftJsonMessageSerializerBuilder> serializerBuilderAction = null) where TBuilder : IConsumerEndpointBuilder<TBuilder> Parameters Type Name Description Silverback.Messaging.Configuration.IConsumerEndpointBuilder <TBuilder> endpointBuilder The endpoint builder. System.Action < INewtonsoftJsonMessageSerializerBuilder > serializerBuilderAction An optional System.Action<T> that takes the INewtonsoftJsonMessageSerializerBuilder and configures it. Returns Type Description TBuilder The endpoint builder so that additional calls can be chained. Type Parameters Name Description TBuilder The actual builder type."
  },
  "api/Silverback.Messaging.Configuration.html": {
    "href": "api/Silverback.Messaging.Configuration.html",
    "title": "Namespace Silverback.Messaging.Configuration | Silverback",
    "keywords": "Namespace Silverback.Messaging.Configuration Classes ConsumerEndpointBuilderDeserializeJsonUsingNewtonsoftExtensions Adds the DeserializeJsonUsingNewtonsoft method to the Silverback.Messaging.Configuration.ConsumerEndpointBuilder<TEndpoint, TBuilder> . NewtonsoftJsonMessageSerializerBuilder ProducerEndpointBuilderSerializeAsJsonUsingNewtonsoftExtensions Adds the SerializeAsJsonUsingNewtonsoft method to the Silverback.Messaging.ProducerEndpoint . RabbitBrokerOptionsConfigurator This class will be located via assembly scanning and invoked when a RabbitBroker is added to the Microsoft.Extensions.DependencyInjection.IServiceCollection . SilverbackBuilderHandleMessageOfTypeExtensions Adds the HandleMessageOfType methods to the ISilverbackBuilder . Interfaces IBusOptions Stores the internal bus configuration (subscribers, etc.). ILogLevelConfigurator Configure and stores the Microsoft.Extensions.Logging.LogLevel overrides. INewtonsoftJsonMessageSerializerBuilder Builds the NewtonsoftJsonMessageSerializer or NewtonsoftJsonMessageSerializer<TMessage> . ISilverbackBuilder Exposes the methods to configure Silverback and enable its optional features adding the needed services to the Microsoft.Extensions.DependencyInjection.IServiceCollection ."
  },
  "api/Silverback.Messaging.Configuration.IBusOptions.html": {
    "href": "api/Silverback.Messaging.Configuration.IBusOptions.html",
    "title": "Interface IBusOptions | Silverback",
    "keywords": "Interface IBusOptions Stores the internal bus configuration (subscribers, etc.). Namespace : Silverback.Messaging.Configuration Assembly : Silverback.Core.dll Syntax public interface IBusOptions Properties | Improve this doc View source MessageTypes Gets the collection of handled message types. These types will be recognized as messages and thus automatically republished when returned by a subscribed method. Declaration IList<Type> MessageTypes { get; } Property Value Type Description System.Collections.Generic.IList < System.Type > | Improve this doc View source Subscriptions Gets the collection of ISubscription . A single subscription can resolve to multiple subscribed methods. Declaration IList<ISubscription> Subscriptions { get; } Property Value Type Description System.Collections.Generic.IList < ISubscription >"
  },
  "api/Silverback.Messaging.Configuration.ILogLevelConfigurator.html": {
    "href": "api/Silverback.Messaging.Configuration.ILogLevelConfigurator.html",
    "title": "Interface ILogLevelConfigurator | Silverback",
    "keywords": "Interface ILogLevelConfigurator Configure and stores the Microsoft.Extensions.Logging.LogLevel overrides. Namespace : Silverback.Messaging.Configuration Assembly : Silverback.Core.dll Syntax public interface ILogLevelConfigurator Methods | Improve this doc View source Build() Builds the ILogLevelDictionary based on the current state of the configurator. Declaration ILogLevelDictionary Build() Returns Type Description ILogLevelDictionary The ILogLevelDictionary . | Improve this doc View source SetLogLevel(EventId, LogLevel) Configure the log level that should be applied to the specified event. Declaration ILogLevelConfigurator SetLogLevel(EventId eventId, LogLevel logLevel) Parameters Type Name Description Microsoft.Extensions.Logging.EventId eventId The event id. Microsoft.Extensions.Logging.LogLevel logLevel The log level to apply. Returns Type Description ILogLevelConfigurator The ILogLevelConfigurator so that additional calls can be chained. | Improve this doc View source SetLogLevel(EventId, Func<Exception, LogLevel, LogLevel>) Configure a delegate that determines the log level that should be applied to the specified event. Declaration ILogLevelConfigurator SetLogLevel(EventId eventId, Func<Exception, LogLevel, LogLevel> logLevelFunc) Parameters Type Name Description Microsoft.Extensions.Logging.EventId eventId The event id. System.Func < System.Exception , Microsoft.Extensions.Logging.LogLevel , Microsoft.Extensions.Logging.LogLevel > logLevelFunc The function that returns the log level. It takes the logged exception and the default log level as parameters. Returns Type Description ILogLevelConfigurator The ILogLevelConfigurator so that additional calls can be chained. | Improve this doc View source SetLogLevel(EventId, Func<Exception, LogLevel, Lazy<String>, LogLevel>) Configure a delegate that determines the log level that should be applied to the specified event. Declaration ILogLevelConfigurator SetLogLevel(EventId eventId, Func<Exception, LogLevel, Lazy<string>, LogLevel> logLevelFunc) Parameters Type Name Description Microsoft.Extensions.Logging.EventId eventId The event id. System.Func < System.Exception , Microsoft.Extensions.Logging.LogLevel , System.Lazy < System.String >, Microsoft.Extensions.Logging.LogLevel > logLevelFunc The function that returns the log level. It takes the logged exception, the message and the default log level as parameters. Returns Type Description ILogLevelConfigurator The ILogLevelConfigurator so that additional calls can be chained."
  },
  "api/Silverback.Messaging.Configuration.INewtonsoftJsonMessageSerializerBuilder.html": {
    "href": "api/Silverback.Messaging.Configuration.INewtonsoftJsonMessageSerializerBuilder.html",
    "title": "Interface INewtonsoftJsonMessageSerializerBuilder | Silverback",
    "keywords": "Interface INewtonsoftJsonMessageSerializerBuilder Builds the NewtonsoftJsonMessageSerializer or NewtonsoftJsonMessageSerializer<TMessage> . Namespace : Silverback.Messaging.Configuration Assembly : Silverback.Integration.Newtonsoft.dll Syntax public interface INewtonsoftJsonMessageSerializerBuilder Methods | Improve this doc View source Configure(Action<JsonSerializerSettings>) Configures the Newtonsoft.Json.JsonSerializerSettings . Declaration INewtonsoftJsonMessageSerializerBuilder Configure(Action<JsonSerializerSettings> configureAction) Parameters Type Name Description System.Action < Newtonsoft.Json.JsonSerializerSettings > configureAction An System.Action<T> that takes the Newtonsoft.Json.JsonSerializerSettings and configures it. Returns Type Description INewtonsoftJsonMessageSerializerBuilder The Silverback.Messaging.Configuration.JsonMessageSerializerBuilder so that additional calls can be chained. | Improve this doc View source UseFixedType(Type) Specifies a fixed message type. This will prevent the message type header to be written when serializing and the header will be ignored when deserializing. Declaration INewtonsoftJsonMessageSerializerBuilder UseFixedType(Type messageType) Parameters Type Name Description System.Type messageType The type of the message to serialize or deserialize. Returns Type Description INewtonsoftJsonMessageSerializerBuilder The Silverback.Messaging.Configuration.JsonMessageSerializerBuilder so that additional calls can be chained. | Improve this doc View source UseFixedType<TMessage>() Specifies a fixed message type. This will prevent the message type header to be written when serializing and the header will be ignored when deserializing. Declaration INewtonsoftJsonMessageSerializerBuilder UseFixedType<TMessage>() Returns Type Description INewtonsoftJsonMessageSerializerBuilder The Silverback.Messaging.Configuration.JsonMessageSerializerBuilder so that additional calls can be chained. Type Parameters Name Description TMessage The type of the message to serialize or deserialize. | Improve this doc View source WithEncoding(MessageEncoding) Specifies the encoding to be used. Declaration INewtonsoftJsonMessageSerializerBuilder WithEncoding(MessageEncoding encoding) Parameters Type Name Description Silverback.Messaging.Serialization.MessageEncoding encoding The Silverback.Messaging.Serialization.MessageEncoding . Returns Type Description INewtonsoftJsonMessageSerializerBuilder The Silverback.Messaging.Configuration.JsonMessageSerializerBuilder so that additional calls can be chained."
  },
  "api/Silverback.Messaging.Configuration.ISilverbackBuilder.html": {
    "href": "api/Silverback.Messaging.Configuration.ISilverbackBuilder.html",
    "title": "Interface ISilverbackBuilder | Silverback",
    "keywords": "Interface ISilverbackBuilder Exposes the methods to configure Silverback and enable its optional features adding the needed services to the Microsoft.Extensions.DependencyInjection.IServiceCollection . Namespace : Silverback.Messaging.Configuration Assembly : Silverback.Core.dll Syntax public interface ISilverbackBuilder Properties | Improve this doc View source BusOptions Gets the IBusOptions that is being modified by this ISilverbackBuilder . Declaration IBusOptions BusOptions { get; } Property Value Type Description IBusOptions | Improve this doc View source Services Gets the Microsoft.Extensions.DependencyInjection.IServiceCollection that is being modified by this ISilverbackBuilder . Declaration IServiceCollection Services { get; } Property Value Type Description Microsoft.Extensions.DependencyInjection.IServiceCollection Extension Methods Microsoft.Extensions.DependencyInjection.SilverbackBuilderAsObservableExtensions.AsObservable(Silverback.Messaging.Configuration.ISilverbackBuilder) SilverbackBuilderUseModelExtensions.UseModel(ISilverbackBuilder) SilverbackBuilderAddDbDistributedLockManagerExtensions.AddDbDistributedLockManager(ISilverbackBuilder) SilverbackBuilderAddBehaviorExtensions.AddTransientBehavior(ISilverbackBuilder, Type) SilverbackBuilderAddBehaviorExtensions.AddTransientBehavior<TBehavior>(ISilverbackBuilder) SilverbackBuilderAddBehaviorExtensions.AddTransientBehavior(ISilverbackBuilder, Func<IServiceProvider, IBehavior>) SilverbackBuilderAddBehaviorExtensions.AddScopedBehavior(ISilverbackBuilder, Type) SilverbackBuilderAddBehaviorExtensions.AddScopedBehavior<TBehavior>(ISilverbackBuilder) SilverbackBuilderAddBehaviorExtensions.AddScopedBehavior(ISilverbackBuilder, Func<IServiceProvider, IBehavior>) SilverbackBuilderAddBehaviorExtensions.AddSingletonBehavior(ISilverbackBuilder, Type) SilverbackBuilderAddBehaviorExtensions.AddSingletonBehavior<TBehavior>(ISilverbackBuilder) SilverbackBuilderAddBehaviorExtensions.AddSingletonBehavior(ISilverbackBuilder, Func<IServiceProvider, IBehavior>) SilverbackBuilderAddBehaviorExtensions.AddSingletonBehavior(ISilverbackBuilder, IBehavior) SilverbackBuilderAddDelegateSubscriberExtensions.AddDelegateSubscriber(ISilverbackBuilder, Delegate, SubscriptionOptions) SilverbackBuilderAddDelegateSubscriberExtensions.AddDelegateSubscriber<TMessage>(ISilverbackBuilder, Action<TMessage>, SubscriptionOptions) SilverbackBuilderAddDelegateSubscriberExtensions.AddDelegateSubscriber<TMessage>(ISilverbackBuilder, Func<TMessage, Task>, SubscriptionOptions) SilverbackBuilderAddDelegateSubscriberExtensions.AddDelegateSubscriber<TMessage>(ISilverbackBuilder, Func<TMessage, Object>, SubscriptionOptions) SilverbackBuilderAddDelegateSubscriberExtensions.AddDelegateSubscriber<TMessage>(ISilverbackBuilder, Func<TMessage, Task<Object>>, SubscriptionOptions) SilverbackBuilderAddDelegateSubscriberExtensions.AddDelegateSubscriber<TMessage>(ISilverbackBuilder, Action<IEnumerable<TMessage>>, SubscriptionOptions) SilverbackBuilderAddDelegateSubscriberExtensions.AddDelegateSubscriber<TMessage>(ISilverbackBuilder, Func<IEnumerable<TMessage>, Task>, SubscriptionOptions) SilverbackBuilderAddDelegateSubscriberExtensions.AddDelegateSubscriber<TMessage>(ISilverbackBuilder, Func<IEnumerable<TMessage>, Object>, SubscriptionOptions) SilverbackBuilderAddDelegateSubscriberExtensions.AddDelegateSubscriber<TMessage>(ISilverbackBuilder, Func<IEnumerable<TMessage>, Task<Object>>, SubscriptionOptions) SilverbackBuilderAddDelegateSubscriberExtensions.AddDelegateSubscriber<TMessage>(ISilverbackBuilder, Action<TMessage, IServiceProvider>, SubscriptionOptions) SilverbackBuilderAddDelegateSubscriberExtensions.AddDelegateSubscriber<TMessage>(ISilverbackBuilder, Func<TMessage, IServiceProvider, Task>, SubscriptionOptions) SilverbackBuilderAddDelegateSubscriberExtensions.AddDelegateSubscriber<TMessage>(ISilverbackBuilder, Func<TMessage, IServiceProvider, Object>, SubscriptionOptions) SilverbackBuilderAddDelegateSubscriberExtensions.AddDelegateSubscriber<TMessage>(ISilverbackBuilder, Action<IEnumerable<TMessage>, IServiceProvider>, SubscriptionOptions) SilverbackBuilderAddDelegateSubscriberExtensions.AddDelegateSubscriber<TMessage>(ISilverbackBuilder, Func<IEnumerable<TMessage>, IServiceProvider, Object>, SubscriptionOptions) SilverbackBuilderAddSubscriberExtensions.AddTransientSubscriber(ISilverbackBuilder, Type, Boolean) SilverbackBuilderAddSubscriberExtensions.AddTransientSubscriber(ISilverbackBuilder, Type, TypeSubscriptionOptions) SilverbackBuilderAddSubscriberExtensions.AddTransientSubscriber<TSubscriber>(ISilverbackBuilder, Boolean) SilverbackBuilderAddSubscriberExtensions.AddTransientSubscriber<TSubscriber>(ISilverbackBuilder, TypeSubscriptionOptions) SilverbackBuilderAddSubscriberExtensions.AddTransientSubscriber(ISilverbackBuilder, Type, Func<IServiceProvider, Object>, Boolean) SilverbackBuilderAddSubscriberExtensions.AddTransientSubscriber(ISilverbackBuilder, Type, Func<IServiceProvider, Object>, TypeSubscriptionOptions) SilverbackBuilderAddSubscriberExtensions.AddTransientSubscriber<TSubscriber>(ISilverbackBuilder, Func<IServiceProvider, TSubscriber>, Boolean) SilverbackBuilderAddSubscriberExtensions.AddTransientSubscriber<TSubscriber>(ISilverbackBuilder, Func<IServiceProvider, TSubscriber>, TypeSubscriptionOptions) SilverbackBuilderAddSubscriberExtensions.AddScopedSubscriber(ISilverbackBuilder, Type, Boolean) SilverbackBuilderAddSubscriberExtensions.AddScopedSubscriber(ISilverbackBuilder, Type, TypeSubscriptionOptions) SilverbackBuilderAddSubscriberExtensions.AddScopedSubscriber<TSubscriber>(ISilverbackBuilder, Boolean) SilverbackBuilderAddSubscriberExtensions.AddScopedSubscriber<TSubscriber>(ISilverbackBuilder, TypeSubscriptionOptions) SilverbackBuilderAddSubscriberExtensions.AddScopedSubscriber(ISilverbackBuilder, Type, Func<IServiceProvider, Object>, Boolean) SilverbackBuilderAddSubscriberExtensions.AddScopedSubscriber(ISilverbackBuilder, Type, Func<IServiceProvider, Object>, TypeSubscriptionOptions) SilverbackBuilderAddSubscriberExtensions.AddScopedSubscriber<TSubscriber>(ISilverbackBuilder, Func<IServiceProvider, TSubscriber>, Boolean) SilverbackBuilderAddSubscriberExtensions.AddScopedSubscriber<TSubscriber>(ISilverbackBuilder, Func<IServiceProvider, TSubscriber>, TypeSubscriptionOptions) SilverbackBuilderAddSubscriberExtensions.AddSingletonSubscriber(ISilverbackBuilder, Type, Boolean) SilverbackBuilderAddSubscriberExtensions.AddSingletonSubscriber(ISilverbackBuilder, Type, TypeSubscriptionOptions) SilverbackBuilderAddSubscriberExtensions.AddSingletonSubscriber<TSubscriber>(ISilverbackBuilder, Boolean) SilverbackBuilderAddSubscriberExtensions.AddSingletonSubscriber<TSubscriber>(ISilverbackBuilder, TypeSubscriptionOptions) SilverbackBuilderAddSubscriberExtensions.AddSingletonSubscriber(ISilverbackBuilder, Type, Func<IServiceProvider, Object>, Boolean) SilverbackBuilderAddSubscriberExtensions.AddSingletonSubscriber(ISilverbackBuilder, Type, Func<IServiceProvider, Object>, TypeSubscriptionOptions) SilverbackBuilderAddSubscriberExtensions.AddSingletonSubscriber<TSubscriber>(ISilverbackBuilder, Func<IServiceProvider, TSubscriber>, Boolean) SilverbackBuilderAddSubscriberExtensions.AddSingletonSubscriber<TSubscriber>(ISilverbackBuilder, Func<IServiceProvider, TSubscriber>, TypeSubscriptionOptions) SilverbackBuilderAddSubscriberExtensions.AddSingletonSubscriber(ISilverbackBuilder, Type, Object, Boolean) SilverbackBuilderAddSubscriberExtensions.AddSingletonSubscriber(ISilverbackBuilder, Type, Object, TypeSubscriptionOptions) SilverbackBuilderAddSubscriberExtensions.AddSingletonSubscriber<TSubscriber>(ISilverbackBuilder, TSubscriber, Boolean) SilverbackBuilderAddSubscriberExtensions.AddSingletonSubscriber<TSubscriber>(ISilverbackBuilder, TSubscriber, TypeSubscriptionOptions) SilverbackBuilderAddSubscriberExtensions.AddSubscribers<TSubscriber>(ISilverbackBuilder, Boolean) SilverbackBuilderAddSubscriberExtensions.AddSubscribers<TSubscriber>(ISilverbackBuilder, TypeSubscriptionOptions) SilverbackBuilderWithLogLevelsExtensions.WithLogLevels(ISilverbackBuilder, Action<ILogLevelConfigurator>) SilverbackBuilderHandleMessageOfTypeExtensions.HandleMessagesOfType<TMessage>(ISilverbackBuilder) SilverbackBuilderHandleMessageOfTypeExtensions.HandleMessagesOfType(ISilverbackBuilder, Type) SilverbackBuilderUseDbContextExtensions.UseDbContext<TDbContext>(ISilverbackBuilder) Silverback.Messaging.Configuration.SilverbackBuilderPublishOutboundMessagesToInternalBusExtensions.PublishOutboundMessagesToInternalBus(Silverback.Messaging.Configuration.ISilverbackBuilder) Silverback.Messaging.Configuration.SilverbackBuilderWithCustomHeaderNameExtensions.WithCustomHeaderName(Silverback.Messaging.Configuration.ISilverbackBuilder, System.String, System.String) Microsoft.Extensions.DependencyInjection.SilverbackBuilderAddBrokerBehaviorExtensions.AddTransientBrokerBehavior(Silverback.Messaging.Configuration.ISilverbackBuilder, System.Type) Microsoft.Extensions.DependencyInjection.SilverbackBuilderAddBrokerBehaviorExtensions.AddTransientBrokerBehavior<TBehavior>(Silverback.Messaging.Configuration.ISilverbackBuilder) Microsoft.Extensions.DependencyInjection.SilverbackBuilderAddBrokerBehaviorExtensions.AddTransientBrokerBehavior(Silverback.Messaging.Configuration.ISilverbackBuilder, System.Func<System.IServiceProvider, Silverback.Messaging.Broker.Behaviors.IBrokerBehavior>) Microsoft.Extensions.DependencyInjection.SilverbackBuilderAddBrokerBehaviorExtensions.AddSingletonBrokerBehavior(Silverback.Messaging.Configuration.ISilverbackBuilder, System.Type) Microsoft.Extensions.DependencyInjection.SilverbackBuilderAddBrokerBehaviorExtensions.AddSingletonBrokerBehavior<TBehavior>(Silverback.Messaging.Configuration.ISilverbackBuilder) Microsoft.Extensions.DependencyInjection.SilverbackBuilderAddBrokerBehaviorExtensions.AddSingletonBrokerBehavior(Silverback.Messaging.Configuration.ISilverbackBuilder, System.Func<System.IServiceProvider, Silverback.Messaging.Broker.Behaviors.IBrokerBehavior>) Microsoft.Extensions.DependencyInjection.SilverbackBuilderAddBrokerBehaviorExtensions.AddSingletonBrokerBehavior(Silverback.Messaging.Configuration.ISilverbackBuilder, Silverback.Messaging.Broker.Behaviors.IBrokerBehavior) Microsoft.Extensions.DependencyInjection.SilverbackBuilderAddBrokerCallbackHandlerExtensions.AddTransientBrokerCallbackHandler(Silverback.Messaging.Configuration.ISilverbackBuilder, System.Type) Microsoft.Extensions.DependencyInjection.SilverbackBuilderAddBrokerCallbackHandlerExtensions.AddTransientBrokerCallbackHandler<THandler>(Silverback.Messaging.Configuration.ISilverbackBuilder) Microsoft.Extensions.DependencyInjection.SilverbackBuilderAddBrokerCallbackHandlerExtensions.AddTransientBrokerCallbackHandler(Silverback.Messaging.Configuration.ISilverbackBuilder, System.Func<System.IServiceProvider, Silverback.Messaging.Broker.Callbacks.IBrokerCallback>) Microsoft.Extensions.DependencyInjection.SilverbackBuilderAddBrokerCallbackHandlerExtensions.AddScopedBrokerCallbackHandler(Silverback.Messaging.Configuration.ISilverbackBuilder, System.Type) Microsoft.Extensions.DependencyInjection.SilverbackBuilderAddBrokerCallbackHandlerExtensions.AddScopedBrokerCallbackHandler<THandler>(Silverback.Messaging.Configuration.ISilverbackBuilder) Microsoft.Extensions.DependencyInjection.SilverbackBuilderAddBrokerCallbackHandlerExtensions.AddScopedBrokerCallbackHandler(Silverback.Messaging.Configuration.ISilverbackBuilder, System.Func<System.IServiceProvider, Silverback.Messaging.Broker.Callbacks.IBrokerCallback>) Microsoft.Extensions.DependencyInjection.SilverbackBuilderAddBrokerCallbackHandlerExtensions.AddSingletonBrokerCallbackHandler(Silverback.Messaging.Configuration.ISilverbackBuilder, System.Type) Microsoft.Extensions.DependencyInjection.SilverbackBuilderAddBrokerCallbackHandlerExtensions.AddSingletonBrokerCallbackHandler<THandler>(Silverback.Messaging.Configuration.ISilverbackBuilder) Microsoft.Extensions.DependencyInjection.SilverbackBuilderAddBrokerCallbackHandlerExtensions.AddSingletonBrokerCallbackHandler(Silverback.Messaging.Configuration.ISilverbackBuilder, System.Func<System.IServiceProvider, Silverback.Messaging.Broker.Callbacks.IBrokerCallback>) Microsoft.Extensions.DependencyInjection.SilverbackBuilderAddBrokerCallbackHandlerExtensions.AddSingletonBrokerCallbackHandler(Silverback.Messaging.Configuration.ISilverbackBuilder, Silverback.Messaging.Broker.Callbacks.IBrokerCallback) Microsoft.Extensions.DependencyInjection.SilverbackBuilderAddEndpointsConfiguratorExtensions.AddEndpointsConfigurator<TConfigurator>(Silverback.Messaging.Configuration.ISilverbackBuilder) Microsoft.Extensions.DependencyInjection.SilverbackBuilderAddEndpointsConfiguratorExtensions.AddEndpointsConfigurator(Silverback.Messaging.Configuration.ISilverbackBuilder, System.Type) Microsoft.Extensions.DependencyInjection.SilverbackBuilderAddEndpointsConfiguratorExtensions.AddEndpointsConfigurator(Silverback.Messaging.Configuration.ISilverbackBuilder, System.Func<System.IServiceProvider, Silverback.Messaging.Configuration.IEndpointsConfigurator>) Microsoft.Extensions.DependencyInjection.SilverbackBuilderAddEndpointsExtensions.AddEndpoints(Silverback.Messaging.Configuration.ISilverbackBuilder, System.Action<Silverback.Messaging.Configuration.IEndpointsConfigurationBuilder>) Microsoft.Extensions.DependencyInjection.SilverbackBuilderAddOutboundRouterExtensions.AddTransientOutboundRouter(Silverback.Messaging.Configuration.ISilverbackBuilder, System.Type) Microsoft.Extensions.DependencyInjection.SilverbackBuilderAddOutboundRouterExtensions.AddTransientOutboundRouter<TRouter>(Silverback.Messaging.Configuration.ISilverbackBuilder) Microsoft.Extensions.DependencyInjection.SilverbackBuilderAddOutboundRouterExtensions.AddTransientOutboundRouter(Silverback.Messaging.Configuration.ISilverbackBuilder, System.Func<System.IServiceProvider, Silverback.Messaging.Outbound.Routing.IOutboundRouter>) Microsoft.Extensions.DependencyInjection.SilverbackBuilderAddOutboundRouterExtensions.AddScopedOutboundRouter(Silverback.Messaging.Configuration.ISilverbackBuilder, System.Type) Microsoft.Extensions.DependencyInjection.SilverbackBuilderAddOutboundRouterExtensions.AddScopedOutboundRouter<TRouter>(Silverback.Messaging.Configuration.ISilverbackBuilder) Microsoft.Extensions.DependencyInjection.SilverbackBuilderAddOutboundRouterExtensions.AddScopedOutboundRouter(Silverback.Messaging.Configuration.ISilverbackBuilder, System.Func<System.IServiceProvider, Silverback.Messaging.Outbound.Routing.IOutboundRouter>) Microsoft.Extensions.DependencyInjection.SilverbackBuilderAddOutboundRouterExtensions.AddSingletonOutboundRouter(Silverback.Messaging.Configuration.ISilverbackBuilder, System.Type) Microsoft.Extensions.DependencyInjection.SilverbackBuilderAddOutboundRouterExtensions.AddSingletonOutboundRouter<TRouter>(Silverback.Messaging.Configuration.ISilverbackBuilder) Microsoft.Extensions.DependencyInjection.SilverbackBuilderAddOutboundRouterExtensions.AddSingletonOutboundRouter(Silverback.Messaging.Configuration.ISilverbackBuilder, System.Func<System.IServiceProvider, Silverback.Messaging.Outbound.Routing.IOutboundRouter>) Microsoft.Extensions.DependencyInjection.SilverbackBuilderAddOutboundRouterExtensions.AddSingletonOutboundRouter(Silverback.Messaging.Configuration.ISilverbackBuilder, Silverback.Messaging.Outbound.Routing.IOutboundRouter) Microsoft.Extensions.DependencyInjection.SilverbackBuilderAddSequenceReaderExtensions.AddTransientSequenceReader(Silverback.Messaging.Configuration.ISilverbackBuilder, System.Type) Microsoft.Extensions.DependencyInjection.SilverbackBuilderAddSequenceReaderExtensions.AddTransientSequenceReader<TReader>(Silverback.Messaging.Configuration.ISilverbackBuilder) Microsoft.Extensions.DependencyInjection.SilverbackBuilderAddSequenceReaderExtensions.AddTransientSequenceReader(Silverback.Messaging.Configuration.ISilverbackBuilder, System.Func<System.IServiceProvider, Silverback.Messaging.Sequences.ISequenceReader>) Microsoft.Extensions.DependencyInjection.SilverbackBuilderAddSequenceReaderExtensions.AddSingletonSequenceReader(Silverback.Messaging.Configuration.ISilverbackBuilder, System.Type) Microsoft.Extensions.DependencyInjection.SilverbackBuilderAddSequenceReaderExtensions.AddSingletonSequenceReader<TReader>(Silverback.Messaging.Configuration.ISilverbackBuilder) Microsoft.Extensions.DependencyInjection.SilverbackBuilderAddSequenceReaderExtensions.AddSingletonSequenceReader(Silverback.Messaging.Configuration.ISilverbackBuilder, System.Func<System.IServiceProvider, Silverback.Messaging.Sequences.ISequenceReader>) Microsoft.Extensions.DependencyInjection.SilverbackBuilderAddSequenceReaderExtensions.AddSingletonSequenceReader(Silverback.Messaging.Configuration.ISilverbackBuilder, Silverback.Messaging.Sequences.ISequenceReader) Microsoft.Extensions.DependencyInjection.SilverbackBuilderAddSequenceWriterExtensions.AddTransientSequenceWriter(Silverback.Messaging.Configuration.ISilverbackBuilder, System.Type) Microsoft.Extensions.DependencyInjection.SilverbackBuilderAddSequenceWriterExtensions.AddTransientSequenceWriter<TWriter>(Silverback.Messaging.Configuration.ISilverbackBuilder) Microsoft.Extensions.DependencyInjection.SilverbackBuilderAddSequenceWriterExtensions.AddTransientSequenceWriter(Silverback.Messaging.Configuration.ISilverbackBuilder, System.Func<System.IServiceProvider, Silverback.Messaging.Sequences.ISequenceWriter>) Microsoft.Extensions.DependencyInjection.SilverbackBuilderAddSequenceWriterExtensions.AddSingletonSequenceWriter(Silverback.Messaging.Configuration.ISilverbackBuilder, System.Type) Microsoft.Extensions.DependencyInjection.SilverbackBuilderAddSequenceWriterExtensions.AddSingletonSequenceWriter<TWriter>(Silverback.Messaging.Configuration.ISilverbackBuilder) Microsoft.Extensions.DependencyInjection.SilverbackBuilderAddSequenceWriterExtensions.AddSingletonSequenceWriter(Silverback.Messaging.Configuration.ISilverbackBuilder, System.Func<System.IServiceProvider, Silverback.Messaging.Sequences.ISequenceWriter>) Microsoft.Extensions.DependencyInjection.SilverbackBuilderAddSequenceWriterExtensions.AddSingletonSequenceWriter(Silverback.Messaging.Configuration.ISilverbackBuilder, Silverback.Messaging.Sequences.ISequenceWriter) Microsoft.Extensions.DependencyInjection.SilverbackBuilderWithConnectionToExtensions.WithConnectionToMessageBroker(Silverback.Messaging.Configuration.ISilverbackBuilder, System.Action<Microsoft.Extensions.DependencyInjection.IBrokerOptionsBuilder>)"
  },
  "api/Silverback.Messaging.Configuration.Kafka.html": {
    "href": "api/Silverback.Messaging.Configuration.Kafka.html",
    "title": "Namespace Silverback.Messaging.Configuration.Kafka | Silverback",
    "keywords": "Namespace Silverback.Messaging.Configuration.Kafka Interfaces IMockedKafkaOptions Stores the mocked Kafka configuration. IMockedKafkaOptionsBuilder Exposes the methods to configure the mocked Kafka."
  },
  "api/Silverback.Messaging.Configuration.Kafka.IMockedKafkaOptions.html": {
    "href": "api/Silverback.Messaging.Configuration.Kafka.IMockedKafkaOptions.html",
    "title": "Interface IMockedKafkaOptions | Silverback",
    "keywords": "Interface IMockedKafkaOptions Stores the mocked Kafka configuration. Namespace : Silverback.Messaging.Configuration.Kafka Assembly : Silverback.Integration.Kafka.Testing.dll Syntax public interface IMockedKafkaOptions Properties | Improve this doc View source DefaultPartitionsCount Gets or sets the default number of partitions to be created per each topic. The default is 5. Declaration int DefaultPartitionsCount { get; set; } Property Value Type Description System.Int32 | Improve this doc View source OverriddenAutoCommitIntervalMs Gets or sets the value to be used instead of the default 5 seconds or the configured\"ConfluentConsumerConfigProxy.AutoCommitIntervalMs\" /> for the inbound topics. Set it to null to disable the feature. The default is 50 milliseconds. Declaration int? OverriddenAutoCommitIntervalMs { get; set; } Property Value Type Description System.Nullable < System.Int32 > | Improve this doc View source PartitionsAssignmentDelay Gets or sets the delay to be applied before and assigning the partitions. Declaration TimeSpan PartitionsAssignmentDelay { get; set; } Property Value Type Description System.TimeSpan"
  },
  "api/Silverback.Messaging.Configuration.Kafka.IMockedKafkaOptionsBuilder.html": {
    "href": "api/Silverback.Messaging.Configuration.Kafka.IMockedKafkaOptionsBuilder.html",
    "title": "Interface IMockedKafkaOptionsBuilder | Silverback",
    "keywords": "Interface IMockedKafkaOptionsBuilder Exposes the methods to configure the mocked Kafka. Namespace : Silverback.Messaging.Configuration.Kafka Assembly : Silverback.Integration.Kafka.Testing.dll Syntax public interface IMockedKafkaOptionsBuilder Methods | Improve this doc View source DelayPartitionsAssignment(TimeSpan) Specifies the delay to be applied before assigning the partitions. Declaration IMockedKafkaOptionsBuilder DelayPartitionsAssignment(TimeSpan delay) Parameters Type Name Description System.TimeSpan delay The delay to be applied before assigning the partitions. Returns Type Description IMockedKafkaOptionsBuilder The IMockedKafkaOptionsBuilder so that additional calls can be chained. | Improve this doc View source OverrideAutoCommitIntervalMs(Nullable<Int32>) Specifies the value to be used instead of the default 5 seconds or the configured Silverback.Messaging.Configuration.Kafka.ConfluentConsumerConfigProxy.AutoCommitIntervalMs for the inbound topics. Set it to null to disable the feature. The default is 10 milliseconds. Declaration IMockedKafkaOptionsBuilder OverrideAutoCommitIntervalMs(int? intervalMs) Parameters Type Name Description System.Nullable < System.Int32 > intervalMs The desired auto commit interval in milliseconds. Returns Type Description IMockedKafkaOptionsBuilder The IMockedKafkaOptionsBuilder so that additional calls can be chained. Remarks This is necessary to speed up the tests, since the WaitUntilAllMessagesAreConsumedAsync(Nullable<TimeSpan>) method waits until the offsets are committed. | Improve this doc View source WithDefaultPartitionsCount(Int32) Specifies the default number of partitions to be created per each topic. The default is 5. Declaration IMockedKafkaOptionsBuilder WithDefaultPartitionsCount(int partitionsCount) Parameters Type Name Description System.Int32 partitionsCount The number of partitions. Returns Type Description IMockedKafkaOptionsBuilder The IMockedKafkaOptionsBuilder so that additional calls can be chained."
  },
  "api/Silverback.Messaging.Configuration.Mqtt.html": {
    "href": "api/Silverback.Messaging.Configuration.Mqtt.html",
    "title": "Namespace Silverback.Messaging.Configuration.Mqtt | Silverback",
    "keywords": "Namespace Silverback.Messaging.Configuration.Mqtt Interfaces IMockedMqttOptions Stores the mocked MQTT configuration. IMockedMqttOptionsBuilder Exposes the methods to configure the mocked MQTT."
  },
  "api/Silverback.Messaging.Configuration.Mqtt.IMockedMqttOptions.html": {
    "href": "api/Silverback.Messaging.Configuration.Mqtt.IMockedMqttOptions.html",
    "title": "Interface IMockedMqttOptions | Silverback",
    "keywords": "Interface IMockedMqttOptions Stores the mocked MQTT configuration. Namespace : Silverback.Messaging.Configuration.Mqtt Assembly : Silverback.Integration.MQTT.Testing.dll Syntax public interface IMockedMqttOptions Properties | Improve this doc View source ConnectionDelay Gets or sets the delay to be applied before establishing a connection. Declaration TimeSpan ConnectionDelay { get; set; } Property Value Type Description System.TimeSpan"
  },
  "api/Silverback.Messaging.Configuration.Mqtt.IMockedMqttOptionsBuilder.html": {
    "href": "api/Silverback.Messaging.Configuration.Mqtt.IMockedMqttOptionsBuilder.html",
    "title": "Interface IMockedMqttOptionsBuilder | Silverback",
    "keywords": "Interface IMockedMqttOptionsBuilder Exposes the methods to configure the mocked MQTT. Namespace : Silverback.Messaging.Configuration.Mqtt Assembly : Silverback.Integration.MQTT.Testing.dll Syntax public interface IMockedMqttOptionsBuilder Methods | Improve this doc View source DelayConnection(TimeSpan) Specifies the delay to be applied before establishing a connection. Declaration IMockedMqttOptionsBuilder DelayConnection(TimeSpan delay) Parameters Type Name Description System.TimeSpan delay The delay to be applied before establishing a connection. Returns Type Description IMockedMqttOptionsBuilder The IMockedMqttOptionsBuilder so that additional calls can be chained."
  },
  "api/Silverback.Messaging.Configuration.NewtonsoftJsonMessageSerializerBuilder.html": {
    "href": "api/Silverback.Messaging.Configuration.NewtonsoftJsonMessageSerializerBuilder.html",
    "title": "Class NewtonsoftJsonMessageSerializerBuilder | Silverback",
    "keywords": "Class NewtonsoftJsonMessageSerializerBuilder Inheritance System.Object NewtonsoftJsonMessageSerializerBuilder Implements INewtonsoftJsonMessageSerializerBuilder Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Silverback.Messaging.Configuration Assembly : Silverback.Integration.Newtonsoft.dll Syntax public class NewtonsoftJsonMessageSerializerBuilder : INewtonsoftJsonMessageSerializerBuilder Methods | Improve this doc View source Build() Builds the Silverback.Messaging.Serialization.IMessageSerializer instance. Declaration public IMessageSerializer Build() Returns Type Description Silverback.Messaging.Serialization.IMessageSerializer The Silverback.Messaging.Serialization.IMessageSerializer . | Improve this doc View source Configure(Action<JsonSerializerSettings>) Declaration public INewtonsoftJsonMessageSerializerBuilder Configure(Action<JsonSerializerSettings> configureAction) Parameters Type Name Description System.Action < Newtonsoft.Json.JsonSerializerSettings > configureAction Returns Type Description INewtonsoftJsonMessageSerializerBuilder | Improve this doc View source UseFixedType(Type) Declaration public INewtonsoftJsonMessageSerializerBuilder UseFixedType(Type messageType) Parameters Type Name Description System.Type messageType Returns Type Description INewtonsoftJsonMessageSerializerBuilder | Improve this doc View source UseFixedType<TMessage>() Declaration public INewtonsoftJsonMessageSerializerBuilder UseFixedType<TMessage>() Returns Type Description INewtonsoftJsonMessageSerializerBuilder Type Parameters Name Description TMessage | Improve this doc View source WithEncoding(MessageEncoding) Declaration public INewtonsoftJsonMessageSerializerBuilder WithEncoding(MessageEncoding encoding) Parameters Type Name Description Silverback.Messaging.Serialization.MessageEncoding encoding Returns Type Description INewtonsoftJsonMessageSerializerBuilder Implements INewtonsoftJsonMessageSerializerBuilder"
  },
  "api/Silverback.Messaging.Configuration.ProducerEndpointBuilderSerializeAsJsonUsingNewtonsoftExtensions.html": {
    "href": "api/Silverback.Messaging.Configuration.ProducerEndpointBuilderSerializeAsJsonUsingNewtonsoftExtensions.html",
    "title": "Class ProducerEndpointBuilderSerializeAsJsonUsingNewtonsoftExtensions | Silverback",
    "keywords": "Class ProducerEndpointBuilderSerializeAsJsonUsingNewtonsoftExtensions Adds the SerializeAsJsonUsingNewtonsoft method to the Silverback.Messaging.ProducerEndpoint . Inheritance System.Object ProducerEndpointBuilderSerializeAsJsonUsingNewtonsoftExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Silverback.Messaging.Configuration Assembly : Silverback.Integration.Newtonsoft.dll Syntax public static class ProducerEndpointBuilderSerializeAsJsonUsingNewtonsoftExtensions Methods | Improve this doc View source SerializeAsJsonUsingNewtonsoft<TBuilder>(IProducerEndpointBuilder<TBuilder>, Action<INewtonsoftJsonMessageSerializerBuilder>) Sets the serializer to an instance of NewtonsoftJsonMessageSerializer (or NewtonsoftJsonMessageSerializer<TMessage> ) to serialize the produced messages as JSON. By default this serializer forwards the message type in an header to let the consumer know which type has to be deserialized. This approach allows to mix messages of different types in the same endpoint and it's ideal when both the producer and the consumer are using Silverback but might not be optimal for interoperability. This behavior can be changed using the builder action and specifying a fixed message type. Declaration public static TBuilder SerializeAsJsonUsingNewtonsoft<TBuilder>(this IProducerEndpointBuilder<TBuilder> endpointBuilder, Action<INewtonsoftJsonMessageSerializerBuilder> serializerBuilderAction = null) where TBuilder : IProducerEndpointBuilder<TBuilder> Parameters Type Name Description Silverback.Messaging.Configuration.IProducerEndpointBuilder <TBuilder> endpointBuilder The endpoint builder. System.Action < INewtonsoftJsonMessageSerializerBuilder > serializerBuilderAction An optional System.Action<T> that takes the INewtonsoftJsonMessageSerializerBuilder and configures it. Returns Type Description TBuilder The endpoint builder so that additional calls can be chained. Type Parameters Name Description TBuilder The actual builder type."
  },
  "api/Silverback.Messaging.Configuration.Rabbit.html": {
    "href": "api/Silverback.Messaging.Configuration.Rabbit.html",
    "title": "Namespace Silverback.Messaging.Configuration.Rabbit | Silverback",
    "keywords": "Namespace Silverback.Messaging.Configuration.Rabbit Classes RabbitConnectionConfig The configuration used to connect with the RabbitMQ broker. RabbitEndpointConfig The base class for the RabbitExchangeConfig and RabbitQueueConfig . RabbitExchangeConfig The RabbitMQ exchange configuration. RabbitQueueConfig The RabbitMQ queue configuration. RabbitSslOption The RabbitMQ SSL options configuration."
  },
  "api/Silverback.Messaging.Configuration.Rabbit.RabbitConnectionConfig.html": {
    "href": "api/Silverback.Messaging.Configuration.Rabbit.RabbitConnectionConfig.html",
    "title": "Class RabbitConnectionConfig | Silverback",
    "keywords": "Class RabbitConnectionConfig The configuration used to connect with the RabbitMQ broker. Inheritance System.Object RabbitConnectionConfig Implements System.IEquatable < RabbitConnectionConfig > Silverback.Messaging.Configuration.IValidatableEndpointSettings Inherited Members System.Object.Equals(System.Object, System.Object) System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Silverback.Messaging.Configuration.Rabbit Assembly : Silverback.Integration.RabbitMQ.dll Syntax public sealed class RabbitConnectionConfig : IEquatable<RabbitConnectionConfig>, IValidatableEndpointSettings Properties | Improve this doc View source AmqpUriSslProtocols Gets or sets the AMQP URI SSL protocols. Declaration public SslProtocols? AmqpUriSslProtocols { get; set; } Property Value Type Description System.Nullable < System.Security.Authentication.SslProtocols > | Improve this doc View source AutomaticRecoveryEnabled Gets or sets a value indicating whether the automatic connection recovery is enabled. The default is true . Declaration public bool? AutomaticRecoveryEnabled { get; set; } Property Value Type Description System.Nullable < System.Boolean > | Improve this doc View source ClientProperties Gets or sets the dictionary of client properties to be sent to the server. Declaration public IDictionary<string, object> ClientProperties { get; set; } Property Value Type Description System.Collections.Generic.IDictionary < System.String , System.Object > | Improve this doc View source ClientProvidedName Gets or sets the default client provided name to be used for connections. Declaration public string ClientProvidedName { get; set; } Property Value Type Description System.String | Improve this doc View source ContinuationTimeout Gets or sets the amount of time the protocol operations (e.g. queue.declare ) are allowed to take before timing out. Declaration public TimeSpan? ContinuationTimeout { get; set; } Property Value Type Description System.Nullable < System.TimeSpan > | Improve this doc View source HandshakeContinuationTimeout Gets or sets the amount of time protocol handshake operations are allowed to take before timing out. Declaration public TimeSpan? HandshakeContinuationTimeout { get; set; } Property Value Type Description System.Nullable < System.TimeSpan > | Improve this doc View source HostName Gets or sets the name of th e host to connect to. Declaration public string HostName { get; set; } Property Value Type Description System.String | Improve this doc View source NetworkRecoveryInterval Gets or sets the amount of time the client will wait for before re-trying to recover the connection. Declaration public TimeSpan? NetworkRecoveryInterval { get; set; } Property Value Type Description System.Nullable < System.TimeSpan > | Improve this doc View source Password Gets or sets the password to use when authenticating to the server. Declaration public string Password { get; set; } Property Value Type Description System.String | Improve this doc View source Port Gets or sets the port to connect on. Declaration public int? Port { get; set; } Property Value Type Description System.Nullable < System.Int32 > | Improve this doc View source RequestedChannelMax Gets or sets the maximum channel number to ask for. Declaration public ushort? RequestedChannelMax { get; set; } Property Value Type Description System.Nullable < System.UInt16 > | Improve this doc View source RequestedConnectionTimeout Gets or sets the timeout setting for the connection attempts. Declaration public TimeSpan? RequestedConnectionTimeout { get; set; } Property Value Type Description System.Nullable < System.TimeSpan > | Improve this doc View source RequestedFrameMax Gets or sets the frame-max parameter to ask for (in bytes). Declaration public uint? RequestedFrameMax { get; set; } Property Value Type Description System.Nullable < System.UInt32 > | Improve this doc View source RequestedHeartbeat Gets or sets the heartbeat timeout to use when negotiating with the server. Declaration public TimeSpan? RequestedHeartbeat { get; set; } Property Value Type Description System.Nullable < System.TimeSpan > | Improve this doc View source SocketReadTimeout Gets or sets the timeout setting for the socket read operations. Declaration public TimeSpan? SocketReadTimeout { get; set; } Property Value Type Description System.Nullable < System.TimeSpan > | Improve this doc View source SocketWriteTimeout Gets or sets the timeout setting for the socket write operations. Declaration public TimeSpan? SocketWriteTimeout { get; set; } Property Value Type Description System.Nullable < System.TimeSpan > | Improve this doc View source Ssl Gets or sets the SSL options setting. Declaration public RabbitSslOption Ssl { get; set; } Property Value Type Description RabbitSslOption | Improve this doc View source TopologyRecoveryEnabled Gets or sets a value indicating whether the automatic connection recovery must recover recover also topology (exchanges, queues, bindings, etc). Defaults to true. Declaration public bool? TopologyRecoveryEnabled { get; set; } Property Value Type Description System.Nullable < System.Boolean > | Improve this doc View source UseBackgroundThreadsForIO Gets or sets a value indicating whether a background thread will be used for the I/O loop. Declaration public bool? UseBackgroundThreadsForIO { get; set; } Property Value Type Description System.Nullable < System.Boolean > | Improve this doc View source UserName Gets or sets the username to use when authenticating to the server. Declaration public string UserName { get; set; } Property Value Type Description System.String | Improve this doc View source VirtualHost Gets or sets the virtual host to access during this connection. Declaration public string VirtualHost { get; set; } Property Value Type Description System.String Methods | Improve this doc View source Equals(RabbitConnectionConfig) Declaration public bool Equals(RabbitConnectionConfig other) Parameters Type Name Description RabbitConnectionConfig other Returns Type Description System.Boolean | Improve this doc View source Equals(Object) Declaration public override bool Equals(object obj) Parameters Type Name Description System.Object obj Returns Type Description System.Boolean Overrides System.Object.Equals(System.Object) | Improve this doc View source GetHashCode() Declaration public override int GetHashCode() Returns Type Description System.Int32 Overrides System.Object.GetHashCode() | Improve this doc View source Validate() Declaration public void Validate() Implements System.IEquatable<T> Silverback.Messaging.Configuration.IValidatableEndpointSettings"
  },
  "api/Silverback.Messaging.Configuration.Rabbit.RabbitEndpointConfig.html": {
    "href": "api/Silverback.Messaging.Configuration.Rabbit.RabbitEndpointConfig.html",
    "title": "Class RabbitEndpointConfig | Silverback",
    "keywords": "Class RabbitEndpointConfig The base class for the RabbitExchangeConfig and RabbitQueueConfig . Inheritance System.Object RabbitEndpointConfig RabbitExchangeConfig RabbitQueueConfig Implements Silverback.Messaging.Configuration.IValidatableEndpointSettings Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Silverback.Messaging.Configuration.Rabbit Assembly : Silverback.Integration.RabbitMQ.dll Syntax public abstract class RabbitEndpointConfig : IValidatableEndpointSettings Properties | Improve this doc View source Arguments Gets or sets the optional arguments dictionary. The arguments are used by plugins and broker-specific features to configure values such as message TTL, queue length limit, etc. Declaration public Dictionary<string, object> Arguments { get; set; } Property Value Type Description System.Collections.Generic.Dictionary < System.String , System.Object > | Improve this doc View source IsAutoDeleteEnabled Gets or sets a value indicating whether the queue or the exchange will be automatically deleted when the last consumer unsubscribes. Declaration public bool IsAutoDeleteEnabled { get; set; } Property Value Type Description System.Boolean | Improve this doc View source IsDurable Gets or sets a value indicating whether the queue or the exchange will survive a broker restart. Declaration public bool IsDurable { get; set; } Property Value Type Description System.Boolean Methods | Improve this doc View source BaseEquals(RabbitEndpointConfig) Determines whether the specified RabbitEndpointConfig is equal to the current RabbitEndpointConfig . Declaration protected virtual bool BaseEquals(RabbitEndpointConfig other) Parameters Type Name Description RabbitEndpointConfig other The object to compare with the current object. Returns Type Description System.Boolean Returns a value indicating whether the other object is equal to the current object. | Improve this doc View source Validate() Declaration public virtual void Validate() Implements Silverback.Messaging.Configuration.IValidatableEndpointSettings"
  },
  "api/Silverback.Messaging.Configuration.Rabbit.RabbitExchangeConfig.html": {
    "href": "api/Silverback.Messaging.Configuration.Rabbit.RabbitExchangeConfig.html",
    "title": "Class RabbitExchangeConfig | Silverback",
    "keywords": "Class RabbitExchangeConfig The RabbitMQ exchange configuration. Inheritance System.Object RabbitEndpointConfig RabbitExchangeConfig Implements Silverback.Messaging.Configuration.IValidatableEndpointSettings System.IEquatable < RabbitExchangeConfig > Inherited Members RabbitEndpointConfig.IsDurable RabbitEndpointConfig.IsAutoDeleteEnabled RabbitEndpointConfig.Arguments RabbitEndpointConfig.BaseEquals(RabbitEndpointConfig) System.Object.Equals(System.Object, System.Object) System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Silverback.Messaging.Configuration.Rabbit Assembly : Silverback.Integration.RabbitMQ.dll Syntax public sealed class RabbitExchangeConfig : RabbitEndpointConfig, IValidatableEndpointSettings, IEquatable<RabbitExchangeConfig> Properties | Improve this doc View source ExchangeType Gets or sets the exchange type. It should match with one of the constants declared in the RabbitMQ.Client.ExchangeType static class. Declaration public string ExchangeType { get; set; } Property Value Type Description System.String Methods | Improve this doc View source Equals(RabbitExchangeConfig) Declaration public bool Equals(RabbitExchangeConfig other) Parameters Type Name Description RabbitExchangeConfig other Returns Type Description System.Boolean | Improve this doc View source Equals(Object) Declaration public override bool Equals(object obj) Parameters Type Name Description System.Object obj Returns Type Description System.Boolean Overrides System.Object.Equals(System.Object) | Improve this doc View source GetHashCode() Declaration public override int GetHashCode() Returns Type Description System.Int32 Overrides System.Object.GetHashCode() | Improve this doc View source Validate() Declaration public override void Validate() Overrides RabbitEndpointConfig.Validate() Implements Silverback.Messaging.Configuration.IValidatableEndpointSettings System.IEquatable<T>"
  },
  "api/Silverback.Messaging.Configuration.Rabbit.RabbitQueueConfig.html": {
    "href": "api/Silverback.Messaging.Configuration.Rabbit.RabbitQueueConfig.html",
    "title": "Class RabbitQueueConfig | Silverback",
    "keywords": "Class RabbitQueueConfig The RabbitMQ queue configuration. Inheritance System.Object RabbitEndpointConfig RabbitQueueConfig Implements Silverback.Messaging.Configuration.IValidatableEndpointSettings System.IEquatable < RabbitQueueConfig > Inherited Members RabbitEndpointConfig.IsDurable RabbitEndpointConfig.IsAutoDeleteEnabled RabbitEndpointConfig.Arguments RabbitEndpointConfig.Validate() RabbitEndpointConfig.BaseEquals(RabbitEndpointConfig) System.Object.Equals(System.Object, System.Object) System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Silverback.Messaging.Configuration.Rabbit Assembly : Silverback.Integration.RabbitMQ.dll Syntax public sealed class RabbitQueueConfig : RabbitEndpointConfig, IValidatableEndpointSettings, IEquatable<RabbitQueueConfig> Properties | Improve this doc View source IsExclusive Gets or sets a value indicating whether the queue is used by only one connection and will be deleted when that connection closes. Declaration public bool IsExclusive { get; set; } Property Value Type Description System.Boolean Methods | Improve this doc View source Equals(RabbitQueueConfig) Declaration public bool Equals(RabbitQueueConfig other) Parameters Type Name Description RabbitQueueConfig other Returns Type Description System.Boolean | Improve this doc View source Equals(Object) Declaration public override bool Equals(object obj) Parameters Type Name Description System.Object obj Returns Type Description System.Boolean Overrides System.Object.Equals(System.Object) | Improve this doc View source GetHashCode() Declaration public override int GetHashCode() Returns Type Description System.Int32 Overrides System.Object.GetHashCode() Implements Silverback.Messaging.Configuration.IValidatableEndpointSettings System.IEquatable<T>"
  },
  "api/Silverback.Messaging.Configuration.Rabbit.RabbitSslOption.html": {
    "href": "api/Silverback.Messaging.Configuration.Rabbit.RabbitSslOption.html",
    "title": "Class RabbitSslOption | Silverback",
    "keywords": "Class RabbitSslOption The RabbitMQ SSL options configuration. Inheritance System.Object RabbitSslOption Implements System.IEquatable < RabbitSslOption > Inherited Members System.Object.Equals(System.Object, System.Object) System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Silverback.Messaging.Configuration.Rabbit Assembly : Silverback.Integration.RabbitMQ.dll Syntax public sealed class RabbitSslOption : IEquatable<RabbitSslOption> Properties | Improve this doc View source AcceptablePolicyErrors Gets or sets the SSL policy errors that are deemed acceptable. Declaration public SslPolicyErrors? AcceptablePolicyErrors { get; set; } Property Value Type Description System.Nullable < System.Net.Security.SslPolicyErrors > | Improve this doc View source CertPassphrase Gets or sets the path to client certificate. Declaration public string CertPassphrase { get; set; } Property Value Type Description System.String | Improve this doc View source CertPath Gets or sets the path to client certificate. Declaration public string CertPath { get; set; } Property Value Type Description System.String | Improve this doc View source CheckCertificateRevocation Gets or sets a value indicating whether the peer certificate should be checked for revocation. The default is false . Declaration public bool? CheckCertificateRevocation { get; set; } Property Value Type Description System.Nullable < System.Boolean > Remarks Uses the built-in .NET mechanics for checking a certificate against CRLs. | Improve this doc View source Enabled Gets or sets a value indicating whether SSL should indeed be used. Declaration public bool Enabled { get; set; } Property Value Type Description System.Boolean | Improve this doc View source ServerName Gets or sets the Canonical Name of the server. This MUST match the CN on the certificate otherwise the SSL connection will fail. Declaration public string ServerName { get; set; } Property Value Type Description System.String | Improve this doc View source Version Gets or sets the SSL protocol version. Declaration public SslProtocols Version { get; set; } Property Value Type Description System.Security.Authentication.SslProtocols Methods | Improve this doc View source Equals(RabbitSslOption) Declaration public bool Equals(RabbitSslOption other) Parameters Type Name Description RabbitSslOption other Returns Type Description System.Boolean | Improve this doc View source Equals(Object) Declaration public override bool Equals(object obj) Parameters Type Name Description System.Object obj Returns Type Description System.Boolean Overrides System.Object.Equals(System.Object) | Improve this doc View source GetHashCode() Declaration public override int GetHashCode() Returns Type Description System.Int32 Overrides System.Object.GetHashCode() Implements System.IEquatable<T>"
  },
  "api/Silverback.Messaging.Configuration.RabbitBrokerOptionsConfigurator.html": {
    "href": "api/Silverback.Messaging.Configuration.RabbitBrokerOptionsConfigurator.html",
    "title": "Class RabbitBrokerOptionsConfigurator | Silverback",
    "keywords": "Class RabbitBrokerOptionsConfigurator This class will be located via assembly scanning and invoked when a RabbitBroker is added to the Microsoft.Extensions.DependencyInjection.IServiceCollection . Inheritance System.Object RabbitBrokerOptionsConfigurator Implements Microsoft.Extensions.DependencyInjection.IBrokerOptionsConfigurator < RabbitBroker > Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Silverback.Messaging.Configuration Assembly : Silverback.Integration.RabbitMQ.dll Syntax public class RabbitBrokerOptionsConfigurator : IBrokerOptionsConfigurator<RabbitBroker> Methods | Improve this doc View source Configure(IBrokerOptionsBuilder) Declaration public void Configure(IBrokerOptionsBuilder brokerOptionsBuilder) Parameters Type Name Description Microsoft.Extensions.DependencyInjection.IBrokerOptionsBuilder brokerOptionsBuilder Implements Microsoft.Extensions.DependencyInjection.IBrokerOptionsConfigurator<TBroker>"
  },
  "api/Silverback.Messaging.Configuration.SilverbackBuilderHandleMessageOfTypeExtensions.html": {
    "href": "api/Silverback.Messaging.Configuration.SilverbackBuilderHandleMessageOfTypeExtensions.html",
    "title": "Class SilverbackBuilderHandleMessageOfTypeExtensions | Silverback",
    "keywords": "Class SilverbackBuilderHandleMessageOfTypeExtensions Adds the HandleMessageOfType methods to the ISilverbackBuilder . Inheritance System.Object SilverbackBuilderHandleMessageOfTypeExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Silverback.Messaging.Configuration Assembly : Silverback.Core.dll Syntax public static class SilverbackBuilderHandleMessageOfTypeExtensions Methods | Improve this doc View source HandleMessagesOfType(ISilverbackBuilder, Type) Configures the specified type to be recognized as a message to enable features like automatic republishing. Declaration public static ISilverbackBuilder HandleMessagesOfType(this ISilverbackBuilder silverbackBuilder, Type messageType) Parameters Type Name Description ISilverbackBuilder silverbackBuilder The ISilverbackBuilder that references the IBusOptions to be configured. System.Type messageType The (base) message type. Returns Type Description ISilverbackBuilder The ISilverbackBuilder so that additional calls can be chained. | Improve this doc View source HandleMessagesOfType<TMessage>(ISilverbackBuilder) Configures the type TMessage to be recognized as a message to enable features like automatic republishing. Declaration public static ISilverbackBuilder HandleMessagesOfType<TMessage>(this ISilverbackBuilder silverbackBuilder) Parameters Type Name Description ISilverbackBuilder silverbackBuilder The ISilverbackBuilder that references the IBusOptions to be configured. Returns Type Description ISilverbackBuilder The ISilverbackBuilder so that additional calls can be chained. Type Parameters Name Description TMessage The (base) message type."
  },
  "api/Silverback.Messaging.HealthChecks.ConsumersHealthCheck.html": {
    "href": "api/Silverback.Messaging.HealthChecks.ConsumersHealthCheck.html",
    "title": "Class ConsumersHealthCheck | Silverback",
    "keywords": "Class ConsumersHealthCheck Verifies whether all consumers are connected. Inheritance System.Object ConsumersHealthCheck Implements Microsoft.Extensions.Diagnostics.HealthChecks.IHealthCheck Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Silverback.Messaging.HealthChecks Assembly : Silverback.Integration.HealthChecks.dll Syntax public class ConsumersHealthCheck : IHealthCheck Constructors | Improve this doc View source ConsumersHealthCheck(IConsumersHealthCheckService, ConsumerStatus, TimeSpan, Func<IConsumerEndpoint, Boolean>) Initializes a new instance of the ConsumersHealthCheck class. Declaration public ConsumersHealthCheck(IConsumersHealthCheckService service, ConsumerStatus minHealthyStatus, TimeSpan gracePeriod, Func<IConsumerEndpoint, bool> endpointsFilter) Parameters Type Name Description Silverback.Messaging.HealthChecks.IConsumersHealthCheckService service The Silverback.Messaging.HealthChecks.IConsumersHealthCheckService implementation to be used to check the consumers. Silverback.Messaging.Broker.ConsumerStatus minHealthyStatus The minimum Silverback.Messaging.Broker.ConsumerStatus a consumer must have to be considered healthy. System.TimeSpan gracePeriod The grace period to observe after each status change before a consumer is considered unhealthy. System.Func < Silverback.Messaging.IConsumerEndpoint , System.Boolean > endpointsFilter An optional filter to be applied to the endpoints to be tested. Methods | Improve this doc View source CheckHealthAsync(HealthCheckContext, CancellationToken) Declaration public async Task<HealthCheckResult> CheckHealthAsync(HealthCheckContext context, CancellationToken cancellationToken = default(CancellationToken)) Parameters Type Name Description Microsoft.Extensions.Diagnostics.HealthChecks.HealthCheckContext context System.Threading.CancellationToken cancellationToken Returns Type Description System.Threading.Tasks.Task < Microsoft.Extensions.Diagnostics.HealthChecks.HealthCheckResult > Implements Microsoft.Extensions.Diagnostics.HealthChecks.IHealthCheck"
  },
  "api/Silverback.Messaging.HealthChecks.html": {
    "href": "api/Silverback.Messaging.HealthChecks.html",
    "title": "Namespace Silverback.Messaging.HealthChecks | Silverback",
    "keywords": "Namespace Silverback.Messaging.HealthChecks Classes ConsumersHealthCheck Verifies whether all consumers are connected. OutboundEndpointsHealthCheck Sends a ping message to all the outbound endpoints to verify that they can all be produced to. OutboxQueueHealthCheck Monitors the outbox, verifying that the messages are being processed."
  },
  "api/Silverback.Messaging.HealthChecks.OutboundEndpointsHealthCheck.html": {
    "href": "api/Silverback.Messaging.HealthChecks.OutboundEndpointsHealthCheck.html",
    "title": "Class OutboundEndpointsHealthCheck | Silverback",
    "keywords": "Class OutboundEndpointsHealthCheck Sends a ping message to all the outbound endpoints to verify that they can all be produced to. Inheritance System.Object OutboundEndpointsHealthCheck Implements Microsoft.Extensions.Diagnostics.HealthChecks.IHealthCheck Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Silverback.Messaging.HealthChecks Assembly : Silverback.Integration.HealthChecks.dll Syntax public class OutboundEndpointsHealthCheck : IHealthCheck Constructors | Improve this doc View source OutboundEndpointsHealthCheck(IOutboundEndpointsHealthCheckService) Initializes a new instance of the OutboundEndpointsHealthCheck class. Declaration public OutboundEndpointsHealthCheck(IOutboundEndpointsHealthCheckService service) Parameters Type Name Description Silverback.Messaging.HealthChecks.IOutboundEndpointsHealthCheckService service The Silverback.Messaging.HealthChecks.IOutboundEndpointsHealthCheckService implementation to be used to ping the services. Methods | Improve this doc View source CheckHealthAsync(HealthCheckContext, CancellationToken) Declaration public async Task<HealthCheckResult> CheckHealthAsync(HealthCheckContext context, CancellationToken cancellationToken = default(CancellationToken)) Parameters Type Name Description Microsoft.Extensions.Diagnostics.HealthChecks.HealthCheckContext context System.Threading.CancellationToken cancellationToken Returns Type Description System.Threading.Tasks.Task < Microsoft.Extensions.Diagnostics.HealthChecks.HealthCheckResult > Implements Microsoft.Extensions.Diagnostics.HealthChecks.IHealthCheck"
  },
  "api/Silverback.Messaging.HealthChecks.OutboxQueueHealthCheck.html": {
    "href": "api/Silverback.Messaging.HealthChecks.OutboxQueueHealthCheck.html",
    "title": "Class OutboxQueueHealthCheck | Silverback",
    "keywords": "Class OutboxQueueHealthCheck Monitors the outbox, verifying that the messages are being processed. Inheritance System.Object OutboxQueueHealthCheck Implements Microsoft.Extensions.Diagnostics.HealthChecks.IHealthCheck Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Silverback.Messaging.HealthChecks Assembly : Silverback.Integration.HealthChecks.dll Syntax public class OutboxQueueHealthCheck : IHealthCheck Constructors | Improve this doc View source OutboxQueueHealthCheck(IOutboundQueueHealthCheckService) Initializes a new instance of the OutboxQueueHealthCheck class. Declaration public OutboxQueueHealthCheck(IOutboundQueueHealthCheckService service) Parameters Type Name Description Silverback.Messaging.HealthChecks.IOutboundQueueHealthCheckService service The Silverback.Messaging.HealthChecks.IOutboundQueueHealthCheckService implementation to be used to monitor the outbound queue. Properties | Improve this doc View source MaxMessageAge Gets or sets the maximum message age, the check will fail when a message exceeds this age (default is 30 seconds). Declaration public static TimeSpan MaxMessageAge { get; set; } Property Value Type Description System.TimeSpan | Improve this doc View source MaxQueueLength Gets or sets the maximum amount of messages in the queue. The default is null , meaning unrestricted. Declaration public static int? MaxQueueLength { get; set; } Property Value Type Description System.Nullable < System.Int32 > Methods | Improve this doc View source CheckHealthAsync(HealthCheckContext, CancellationToken) Declaration public async Task<HealthCheckResult> CheckHealthAsync(HealthCheckContext context, CancellationToken cancellationToken = default(CancellationToken)) Parameters Type Name Description Microsoft.Extensions.Diagnostics.HealthChecks.HealthCheckContext context System.Threading.CancellationToken cancellationToken Returns Type Description System.Threading.Tasks.Task < Microsoft.Extensions.Diagnostics.HealthChecks.HealthCheckResult > Implements Microsoft.Extensions.Diagnostics.HealthChecks.IHealthCheck"
  },
  "api/Silverback.Messaging.html": {
    "href": "api/Silverback.Messaging.html",
    "title": "Namespace Silverback.Messaging | Silverback",
    "keywords": "Namespace Silverback.Messaging Classes RabbitConsumerEndpoint Represents a queue or exchange to consume from. RabbitExchangeConsumerEndpoint Represents an exchange to consume from. RabbitExchangeProducerEndpoint Represents an exchange to produce to. RabbitProducerEndpoint Represents a queue or exchange to produce to. RabbitQueueConsumerEndpoint Represents a queue to consume from. RabbitQueueProducerEndpoint Represents a queue to produce to."
  },
  "api/Silverback.Messaging.Messages.html": {
    "href": "api/Silverback.Messaging.Messages.html",
    "title": "Namespace Silverback.Messaging.Messages | Silverback",
    "keywords": "Namespace Silverback.Messaging.Messages Classes MessagesSource<TBaseEvent> The default generic implementation of IMessagesSource . It contains some protected methods to add the internal events to a temporary collection exposed via the IMessagesSource implementation. RabbitMessageHeaders Contains the constants with the names of the RabbitMQ specific message headers used by Silverback. RabbitRoutingKeyAttribute The value of the property decorated with this attribute will be used as routing key. The routing key can be used by RabbitMQ to route the messages to the proper queue. TransactionAbortedEvent The event published when an exception occurs during the processing of a (database) transaction. It is fired by the data access while saving changes (see Silverback.Core.EntityFrameworkCore) and it is internally used (in Silverback.Integration) to trigger additional tasks related to the publishing of the domain events. TransactionCompletedEvent The event published when a (database) transaction is completed and committed. It is fired by the data access after saving changes (see Silverback.Core.EntityFrameworkCore) and it is internally used (in Silverback.Integration) to trigger additional tasks related to the publishing of the domain events. TransactionStartedEvent The event published when a (database) transaction is being started. It is fired by the data access before saving changes (see Silverback.Core.EntityFrameworkCore) and it is internally used (in Silverback.Integration) to trigger additional tasks related to the publishing of the domain events. Interfaces ICommand Represents a message that triggers an action. ICommand<TResult> Represents a message that triggers an action with a result TResult . IEnvelope Wraps a message when it's being transferred over a message broker. IEvent Represents a message that notifies an event. IIntegrationCommand Represents a message that is sent over the message broker to trigger an action. IIntegrationEvent Represents a message that is sent over the message broker to notify an event. IIntegrationMessage Represents a message that is sent over the message broker. It is further specialized as IIntegrationEvent and IIntegrationCommand . ILazyMessageStreamEnumerable<TMessage> Represent a future IMessageStreamEnumerable<TMessage> , that will created as soon as the first message is pushed. IMessage This marker interface is used to tell Silverback that the type is actually a message and enable features like automatic republishing. It is a good practice for all messages to implement this interface but it's not mandatory. IMessagesSource Exposes the methods to retrieve a list of messages associated with the object implementing this interface. IMessageStreamEnumerable<TMessage> Represent a stream of messages being published through the internal bus. It is an enumerable that is asynchronously pushed with messages. IMessageStreamProvider Relays the streamed messages to all the linked Silverback.Messaging.Messages.MessageStreamEnumerable`1 . IMessageWithSource Exposes a Source property referencing the object that generated the message. IQuery<TResult> Represents a message that queries a result of type TResult . ISilverbackEvent An event that is triggered internally by Silverback."
  },
  "api/Silverback.Messaging.Messages.ICommand.html": {
    "href": "api/Silverback.Messaging.Messages.ICommand.html",
    "title": "Interface ICommand | Silverback",
    "keywords": "Interface ICommand Represents a message that triggers an action. Namespace : Silverback.Messaging.Messages Assembly : Silverback.Core.Model.dll Syntax public interface ICommand : IMessage"
  },
  "api/Silverback.Messaging.Messages.ICommand-1.html": {
    "href": "api/Silverback.Messaging.Messages.ICommand-1.html",
    "title": "Interface ICommand<TResult> | Silverback",
    "keywords": "Interface ICommand<TResult> Represents a message that triggers an action with a result TResult . Namespace : Silverback.Messaging.Messages Assembly : Silverback.Core.Model.dll Syntax public interface ICommand<out TResult> : ICommand, IMessage Type Parameters Name Description TResult The type of the result being returned."
  },
  "api/Silverback.Messaging.Messages.IEnvelope.html": {
    "href": "api/Silverback.Messaging.Messages.IEnvelope.html",
    "title": "Interface IEnvelope | Silverback",
    "keywords": "Interface IEnvelope Wraps a message when it's being transferred over a message broker. Namespace : Silverback.Messaging.Messages Assembly : Silverback.Core.dll Syntax public interface IEnvelope Properties | Improve this doc View source AutoUnwrap Gets a value indicating whether this envelope can be automatically unwrapped and the contained message can be forwarded to the matching subscribers in its pure form. Declaration bool AutoUnwrap { get; } Property Value Type Description System.Boolean Remarks This is internally used to avoid mortal loops. | Improve this doc View source Message Gets or sets the message body. Declaration object Message { get; set; } Property Value Type Description System.Object"
  },
  "api/Silverback.Messaging.Messages.IEvent.html": {
    "href": "api/Silverback.Messaging.Messages.IEvent.html",
    "title": "Interface IEvent | Silverback",
    "keywords": "Interface IEvent Represents a message that notifies an event. Namespace : Silverback.Messaging.Messages Assembly : Silverback.Core.Model.dll Syntax public interface IEvent : IMessage"
  },
  "api/Silverback.Messaging.Messages.IIntegrationCommand.html": {
    "href": "api/Silverback.Messaging.Messages.IIntegrationCommand.html",
    "title": "Interface IIntegrationCommand | Silverback",
    "keywords": "Interface IIntegrationCommand Represents a message that is sent over the message broker to trigger an action. Namespace : Silverback.Messaging.Messages Assembly : Silverback.Core.Model.dll Syntax public interface IIntegrationCommand : ICommand, IIntegrationMessage, IMessage"
  },
  "api/Silverback.Messaging.Messages.IIntegrationEvent.html": {
    "href": "api/Silverback.Messaging.Messages.IIntegrationEvent.html",
    "title": "Interface IIntegrationEvent | Silverback",
    "keywords": "Interface IIntegrationEvent Represents a message that is sent over the message broker to notify an event. Namespace : Silverback.Messaging.Messages Assembly : Silverback.Core.Model.dll Syntax public interface IIntegrationEvent : IEvent, IIntegrationMessage, IMessage"
  },
  "api/Silverback.Messaging.Messages.IIntegrationMessage.html": {
    "href": "api/Silverback.Messaging.Messages.IIntegrationMessage.html",
    "title": "Interface IIntegrationMessage | Silverback",
    "keywords": "Interface IIntegrationMessage Represents a message that is sent over the message broker. It is further specialized as IIntegrationEvent and IIntegrationCommand . Namespace : Silverback.Messaging.Messages Assembly : Silverback.Core.Model.dll Syntax public interface IIntegrationMessage : IMessage"
  },
  "api/Silverback.Messaging.Messages.ILazyMessageStreamEnumerable-1.html": {
    "href": "api/Silverback.Messaging.Messages.ILazyMessageStreamEnumerable-1.html",
    "title": "Interface ILazyMessageStreamEnumerable<TMessage> | Silverback",
    "keywords": "Interface ILazyMessageStreamEnumerable<TMessage> Represent a future IMessageStreamEnumerable<TMessage> , that will created as soon as the first message is pushed. Namespace : Silverback.Messaging.Messages Assembly : Silverback.Core.dll Syntax public interface ILazyMessageStreamEnumerable<out TMessage> Type Parameters Name Description TMessage The type of the messages being streamed. Properties | Improve this doc View source Stream Gets the IMessageStreamEnumerable<TMessage> , as soon as it is created. Declaration IMessageStreamEnumerable<TMessage> Stream { get; } Property Value Type Description IMessageStreamEnumerable <TMessage> Methods | Improve this doc View source WaitUntilCreatedAsync() Gets an awaitable System.Threading.Tasks.Task that completes when the first message is pushed and the IMessageStreamEnumerable<TMessage> is created. The created stream can be retrieved via the Stream property. Declaration Task WaitUntilCreatedAsync() Returns Type Description System.Threading.Tasks.Task A System.Threading.Tasks.Task representing the asynchronous operation."
  },
  "api/Silverback.Messaging.Messages.IMessage.html": {
    "href": "api/Silverback.Messaging.Messages.IMessage.html",
    "title": "Interface IMessage | Silverback",
    "keywords": "Interface IMessage This marker interface is used to tell Silverback that the type is actually a message and enable features like automatic republishing. It is a good practice for all messages to implement this interface but it's not mandatory. Namespace : Silverback.Messaging.Messages Assembly : Silverback.Core.dll Syntax public interface IMessage"
  },
  "api/Silverback.Messaging.Messages.IMessagesSource.html": {
    "href": "api/Silverback.Messaging.Messages.IMessagesSource.html",
    "title": "Interface IMessagesSource | Silverback",
    "keywords": "Interface IMessagesSource Exposes the methods to retrieve a list of messages associated with the object implementing this interface. Namespace : Silverback.Messaging.Messages Assembly : Silverback.Core.dll Syntax public interface IMessagesSource Remarks Used to implement the domain entities and automatically publish their events when the entity is saved to the underlying database. Methods | Improve this doc View source ClearMessages() Called after the messages have been successfully published (and processed) to clear the messages collection. Declaration void ClearMessages() | Improve this doc View source GetMessages() Gets the messages to be published. Declaration IEnumerable<object> GetMessages() Returns Type Description System.Collections.Generic.IEnumerable < System.Object > The message objects."
  },
  "api/Silverback.Messaging.Messages.IMessageStreamEnumerable-1.html": {
    "href": "api/Silverback.Messaging.Messages.IMessageStreamEnumerable-1.html",
    "title": "Interface IMessageStreamEnumerable<TMessage> | Silverback",
    "keywords": "Interface IMessageStreamEnumerable<TMessage> Represent a stream of messages being published through the internal bus. It is an enumerable that is asynchronously pushed with messages. Inherited Members System.Collections.Generic.IEnumerable<TMessage>.GetEnumerator() System.Collections.Generic.IAsyncEnumerable<TMessage>.GetAsyncEnumerator(System.Threading.CancellationToken) Namespace : Silverback.Messaging.Messages Assembly : Silverback.Core.dll Syntax public interface IMessageStreamEnumerable<out TMessage> : IEnumerable<TMessage>, IEnumerable, IAsyncEnumerable<TMessage> Type Parameters Name Description TMessage The type of the messages being streamed."
  },
  "api/Silverback.Messaging.Messages.IMessageStreamProvider.html": {
    "href": "api/Silverback.Messaging.Messages.IMessageStreamProvider.html",
    "title": "Interface IMessageStreamProvider | Silverback",
    "keywords": "Interface IMessageStreamProvider Relays the streamed messages to all the linked Silverback.Messaging.Messages.MessageStreamEnumerable`1 . Namespace : Silverback.Messaging.Messages Assembly : Silverback.Core.dll Syntax public interface IMessageStreamProvider Properties | Improve this doc View source MessageType Gets the type of the messages being streamed. Declaration Type MessageType { get; } Property Value Type Description System.Type | Improve this doc View source StreamsCount Gets the number of IMessageStreamEnumerable<TMessage> that have been created via CreateStream(Type, IReadOnlyCollection<IMessageFilter>) or CreateStream<TMessage>(IReadOnlyCollection<IMessageFilter>) . Declaration int StreamsCount { get; } Property Value Type Description System.Int32 Methods | Improve this doc View source CreateLazyStream(Type, IReadOnlyCollection<IMessageFilter>) Creates a new ILazyMessageStreamEnumerable<TMessage> that will be linked with this provider and will create the IMessageStreamEnumerable<TMessage> as soon as a message matching the type messageType is pushed. Declaration ILazyMessageStreamEnumerable<object> CreateLazyStream(Type messageType, IReadOnlyCollection<IMessageFilter> filters = null) Parameters Type Name Description System.Type messageType The type of the messages to be streamed to the linked stream. System.Collections.Generic.IReadOnlyCollection < IMessageFilter > filters The filters to be applied. Returns Type Description ILazyMessageStreamEnumerable < System.Object > The linked ILazyMessageStreamEnumerable<TMessage> . | Improve this doc View source CreateLazyStream<TMessage>(IReadOnlyCollection<IMessageFilter>) Creates a new ILazyMessageStreamEnumerable<TMessage> that will be linked with this provider and will create the IMessageStreamEnumerable<TMessage> as soon as a message matching the type TMessage is pushed. Declaration ILazyMessageStreamEnumerable<TMessage> CreateLazyStream<TMessage>(IReadOnlyCollection<IMessageFilter> filters = null) Parameters Type Name Description System.Collections.Generic.IReadOnlyCollection < IMessageFilter > filters The filters to be applied. Returns Type Description ILazyMessageStreamEnumerable <TMessage> The linked ILazyMessageStreamEnumerable<TMessage> . Type Parameters Name Description TMessage The type of the messages to be streamed to the linked stream. | Improve this doc View source CreateStream(Type, IReadOnlyCollection<IMessageFilter>) Creates a new IMessageStreamEnumerable<TMessage> that will be linked with this provider and will be pushed with the messages matching the type messageType . Declaration IMessageStreamEnumerable<object> CreateStream(Type messageType, IReadOnlyCollection<IMessageFilter> filters = null) Parameters Type Name Description System.Type messageType The type of the messages to be streamed to the linked stream. System.Collections.Generic.IReadOnlyCollection < IMessageFilter > filters The filters to be applied. Returns Type Description IMessageStreamEnumerable < System.Object > The linked IMessageStreamEnumerable<TMessage> . | Improve this doc View source CreateStream<TMessage>(IReadOnlyCollection<IMessageFilter>) Creates a new IMessageStreamEnumerable<TMessage> that will be linked with this provider and will be pushed with the messages matching the type TMessage . Declaration IMessageStreamEnumerable<TMessage> CreateStream<TMessage>(IReadOnlyCollection<IMessageFilter> filters = null) Parameters Type Name Description System.Collections.Generic.IReadOnlyCollection < IMessageFilter > filters The filters to be applied. Returns Type Description IMessageStreamEnumerable <TMessage> The linked IMessageStreamEnumerable<TMessage> . Type Parameters Name Description TMessage The type of the messages to be streamed to the linked stream."
  },
  "api/Silverback.Messaging.Messages.IMessageWithSource.html": {
    "href": "api/Silverback.Messaging.Messages.IMessageWithSource.html",
    "title": "Interface IMessageWithSource | Silverback",
    "keywords": "Interface IMessageWithSource Exposes a Source property referencing the object that generated the message. Namespace : Silverback.Messaging.Messages Assembly : Silverback.Core.dll Syntax public interface IMessageWithSource Properties | Improve this doc View source Source Gets or sets the reference to the object that generated the message. Declaration object Source { get; set; } Property Value Type Description System.Object"
  },
  "api/Silverback.Messaging.Messages.IQuery-1.html": {
    "href": "api/Silverback.Messaging.Messages.IQuery-1.html",
    "title": "Interface IQuery<TResult> | Silverback",
    "keywords": "Interface IQuery<TResult> Represents a message that queries a result of type TResult . Namespace : Silverback.Messaging.Messages Assembly : Silverback.Core.Model.dll Syntax public interface IQuery<out TResult> : IMessage Type Parameters Name Description TResult The type of the result being returned."
  },
  "api/Silverback.Messaging.Messages.ISilverbackEvent.html": {
    "href": "api/Silverback.Messaging.Messages.ISilverbackEvent.html",
    "title": "Interface ISilverbackEvent | Silverback",
    "keywords": "Interface ISilverbackEvent An event that is triggered internally by Silverback. Namespace : Silverback.Messaging.Messages Assembly : Silverback.Core.dll Syntax public interface ISilverbackEvent : IMessage"
  },
  "api/Silverback.Messaging.Messages.MessagesSource-1.html": {
    "href": "api/Silverback.Messaging.Messages.MessagesSource-1.html",
    "title": "Class MessagesSource<TBaseEvent> | Silverback",
    "keywords": "Class MessagesSource<TBaseEvent> The default generic implementation of IMessagesSource . It contains some protected methods to add the internal events to a temporary collection exposed via the IMessagesSource implementation. Inheritance System.Object MessagesSource<TBaseEvent> DomainEntity EventSourcingDomainEntity<TKey, TDomainEvent> EventStoreEntity<TEventEntity> Implements IMessagesSource Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Silverback.Messaging.Messages Assembly : Silverback.Core.dll Syntax public abstract class MessagesSource<TBaseEvent> : IMessagesSource Type Parameters Name Description TBaseEvent The base type of the events being published. Remarks This is the base class of the DomainEntity defined in Silverback.Core.Model. Methods | Improve this doc View source AddEvent(TBaseEvent) Adds the specified event to the collection of events related to this object. In the case of an entity model the event will be published when the entity is saved to the underlying database. Declaration protected virtual void AddEvent(TBaseEvent event) Parameters Type Name Description TBaseEvent event The instance of TBaseEvent to be added. | Improve this doc View source AddEvent<TEvent>(Boolean) Adds a new instance of TEvent to the collection of events related to this object. In the case of an entity model the event will be published when the entity is saved to the underlying database. Declaration protected TEvent AddEvent<TEvent>(bool allowMultiple = true) where TEvent : TBaseEvent, new() Parameters Type Name Description System.Boolean allowMultiple if set to false only one instance of the specified type TEvent will be added. Returns Type Description TEvent The TEvent instance that was added. Type Parameters Name Description TEvent The type of the event. | Improve this doc View source ClearMessages() Declaration public void ClearMessages() | Improve this doc View source GetMessages() Declaration public IEnumerable<object> GetMessages() Returns Type Description System.Collections.Generic.IEnumerable < System.Object > | Improve this doc View source RemoveEvent(TBaseEvent) Removes the specified event from the collection of events related to this object. Declaration protected void RemoveEvent(TBaseEvent event) Parameters Type Name Description TBaseEvent event The TBaseEvent to be removed. Remarks This is used only to withdraw an event that wasn't published yet. Implements IMessagesSource"
  },
  "api/Silverback.Messaging.Messages.RabbitMessageHeaders.html": {
    "href": "api/Silverback.Messaging.Messages.RabbitMessageHeaders.html",
    "title": "Class RabbitMessageHeaders | Silverback",
    "keywords": "Class RabbitMessageHeaders Contains the constants with the names of the RabbitMQ specific message headers used by Silverback. Inheritance System.Object RabbitMessageHeaders Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Silverback.Messaging.Messages Assembly : Silverback.Integration.RabbitMQ.dll Syntax public static class RabbitMessageHeaders Fields | Improve this doc View source RoutingKey The header that will be filled with the routing key (if defined via RabbitRoutingKeyAttribute for the message being produced). Declaration public const string RoutingKey = \"x-rabbit-routing-key\" Field Value Type Description System.String"
  },
  "api/Silverback.Messaging.Messages.RabbitRoutingKeyAttribute.html": {
    "href": "api/Silverback.Messaging.Messages.RabbitRoutingKeyAttribute.html",
    "title": "Class RabbitRoutingKeyAttribute | Silverback",
    "keywords": "Class RabbitRoutingKeyAttribute The value of the property decorated with this attribute will be used as routing key. The routing key can be used by RabbitMQ to route the messages to the proper queue. Inheritance System.Object System.Attribute RabbitRoutingKeyAttribute Inherited Members System.Attribute.Equals(System.Object) System.Attribute.GetCustomAttribute(System.Reflection.Assembly, System.Type) System.Attribute.GetCustomAttribute(System.Reflection.Assembly, System.Type, System.Boolean) System.Attribute.GetCustomAttribute(System.Reflection.MemberInfo, System.Type) System.Attribute.GetCustomAttribute(System.Reflection.MemberInfo, System.Type, System.Boolean) System.Attribute.GetCustomAttribute(System.Reflection.Module, System.Type) System.Attribute.GetCustomAttribute(System.Reflection.Module, System.Type, System.Boolean) System.Attribute.GetCustomAttribute(System.Reflection.ParameterInfo, System.Type) System.Attribute.GetCustomAttribute(System.Reflection.ParameterInfo, System.Type, System.Boolean) System.Attribute.GetCustomAttributes(System.Reflection.Assembly) System.Attribute.GetCustomAttributes(System.Reflection.Assembly, System.Boolean) System.Attribute.GetCustomAttributes(System.Reflection.Assembly, System.Type) System.Attribute.GetCustomAttributes(System.Reflection.Assembly, System.Type, System.Boolean) System.Attribute.GetCustomAttributes(System.Reflection.MemberInfo) System.Attribute.GetCustomAttributes(System.Reflection.MemberInfo, System.Boolean) System.Attribute.GetCustomAttributes(System.Reflection.MemberInfo, System.Type) System.Attribute.GetCustomAttributes(System.Reflection.MemberInfo, System.Type, System.Boolean) System.Attribute.GetCustomAttributes(System.Reflection.Module) System.Attribute.GetCustomAttributes(System.Reflection.Module, System.Boolean) System.Attribute.GetCustomAttributes(System.Reflection.Module, System.Type) System.Attribute.GetCustomAttributes(System.Reflection.Module, System.Type, System.Boolean) System.Attribute.GetCustomAttributes(System.Reflection.ParameterInfo) System.Attribute.GetCustomAttributes(System.Reflection.ParameterInfo, System.Boolean) System.Attribute.GetCustomAttributes(System.Reflection.ParameterInfo, System.Type) System.Attribute.GetCustomAttributes(System.Reflection.ParameterInfo, System.Type, System.Boolean) System.Attribute.GetHashCode() System.Attribute.IsDefaultAttribute() System.Attribute.IsDefined(System.Reflection.Assembly, System.Type) System.Attribute.IsDefined(System.Reflection.Assembly, System.Type, System.Boolean) System.Attribute.IsDefined(System.Reflection.MemberInfo, System.Type) System.Attribute.IsDefined(System.Reflection.MemberInfo, System.Type, System.Boolean) System.Attribute.IsDefined(System.Reflection.Module, System.Type) System.Attribute.IsDefined(System.Reflection.Module, System.Type, System.Boolean) System.Attribute.IsDefined(System.Reflection.ParameterInfo, System.Type) System.Attribute.IsDefined(System.Reflection.ParameterInfo, System.Type, System.Boolean) System.Attribute.Match(System.Object) System.Attribute.TypeId System.Object.Equals(System.Object, System.Object) System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Silverback.Messaging.Messages Assembly : Silverback.Integration.RabbitMQ.dll Syntax [AttributeUsage(AttributeTargets.Property)] public sealed class RabbitRoutingKeyAttribute : Attribute"
  },
  "api/Silverback.Messaging.Messages.TransactionAbortedEvent.html": {
    "href": "api/Silverback.Messaging.Messages.TransactionAbortedEvent.html",
    "title": "Class TransactionAbortedEvent | Silverback",
    "keywords": "Class TransactionAbortedEvent The event published when an exception occurs during the processing of a (database) transaction. It is fired by the data access while saving changes (see Silverback.Core.EntityFrameworkCore) and it is internally used (in Silverback.Integration) to trigger additional tasks related to the publishing of the domain events. Inheritance System.Object TransactionAbortedEvent Implements ISilverbackEvent IMessage Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Silverback.Messaging.Messages Assembly : Silverback.Core.dll Syntax public class TransactionAbortedEvent : ISilverbackEvent, IMessage Implements ISilverbackEvent IMessage"
  },
  "api/Silverback.Messaging.Messages.TransactionCompletedEvent.html": {
    "href": "api/Silverback.Messaging.Messages.TransactionCompletedEvent.html",
    "title": "Class TransactionCompletedEvent | Silverback",
    "keywords": "Class TransactionCompletedEvent The event published when a (database) transaction is completed and committed. It is fired by the data access after saving changes (see Silverback.Core.EntityFrameworkCore) and it is internally used (in Silverback.Integration) to trigger additional tasks related to the publishing of the domain events. Inheritance System.Object TransactionCompletedEvent Implements ISilverbackEvent IMessage Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Silverback.Messaging.Messages Assembly : Silverback.Core.dll Syntax public class TransactionCompletedEvent : ISilverbackEvent, IMessage Implements ISilverbackEvent IMessage"
  },
  "api/Silverback.Messaging.Messages.TransactionStartedEvent.html": {
    "href": "api/Silverback.Messaging.Messages.TransactionStartedEvent.html",
    "title": "Class TransactionStartedEvent | Silverback",
    "keywords": "Class TransactionStartedEvent The event published when a (database) transaction is being started. It is fired by the data access before saving changes (see Silverback.Core.EntityFrameworkCore) and it is internally used (in Silverback.Integration) to trigger additional tasks related to the publishing of the domain events. Inheritance System.Object TransactionStartedEvent Implements ISilverbackEvent IMessage Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Silverback.Messaging.Messages Assembly : Silverback.Core.dll Syntax public class TransactionStartedEvent : ISilverbackEvent, IMessage Implements ISilverbackEvent IMessage"
  },
  "api/Silverback.Messaging.Outbound.Enrichers.html": {
    "href": "api/Silverback.Messaging.Outbound.Enrichers.html",
    "title": "Namespace Silverback.Messaging.Outbound.Enrichers | Silverback",
    "keywords": "Namespace Silverback.Messaging.Outbound.Enrichers Classes OutboundMessageRabbitRoutingKeyEnricher<TMessage> A generic enricher that sets the routing key according to a value provider function."
  },
  "api/Silverback.Messaging.Outbound.Enrichers.OutboundMessageRabbitRoutingKeyEnricher-1.html": {
    "href": "api/Silverback.Messaging.Outbound.Enrichers.OutboundMessageRabbitRoutingKeyEnricher-1.html",
    "title": "Class OutboundMessageRabbitRoutingKeyEnricher<TMessage> | Silverback",
    "keywords": "Class OutboundMessageRabbitRoutingKeyEnricher<TMessage> A generic enricher that sets the routing key according to a value provider function. Inheritance System.Object Silverback.Messaging.Outbound.Enrichers.GenericOutboundHeadersEnricher <TMessage> OutboundMessageRabbitRoutingKeyEnricher<TMessage> Implements Silverback.Messaging.Outbound.Enrichers.IOutboundMessageEnricher Inherited Members Silverback.Messaging.Outbound.Enrichers.GenericOutboundHeadersEnricher<TMessage>.Enrich(Silverback.Messaging.Messages.IOutboundEnvelope) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Silverback.Messaging.Outbound.Enrichers Assembly : Silverback.Integration.RabbitMQ.dll Syntax public class OutboundMessageRabbitRoutingKeyEnricher<TMessage> : GenericOutboundHeadersEnricher<TMessage>, IOutboundMessageEnricher where TMessage : class Type Parameters Name Description TMessage The type of the messages to be enriched. Constructors | Improve this doc View source OutboundMessageRabbitRoutingKeyEnricher(Func<IOutboundEnvelope<TMessage>, Object>) Initializes a new instance of the OutboundMessageRabbitRoutingKeyEnricher<TMessage> class. Declaration public OutboundMessageRabbitRoutingKeyEnricher(Func<IOutboundEnvelope<TMessage>, object> valueProvider) Parameters Type Name Description System.Func < Silverback.Messaging.Messages.IOutboundEnvelope <TMessage>, System.Object > valueProvider The kafka key value provider function. Implements Silverback.Messaging.Outbound.Enrichers.IOutboundMessageEnricher"
  },
  "api/Silverback.Messaging.Outbound.html": {
    "href": "api/Silverback.Messaging.Outbound.html",
    "title": "Namespace Silverback.Messaging.Outbound | Silverback",
    "keywords": "Namespace Silverback.Messaging.Outbound Classes RabbitRoutingKeyInitializerProducerBehavior Sets the routing key header with the value from the property decorated with the RabbitRoutingKeyAttribute . The header will be used by the RabbitProducer to set the actual routing key."
  },
  "api/Silverback.Messaging.Outbound.RabbitRoutingKeyInitializerProducerBehavior.html": {
    "href": "api/Silverback.Messaging.Outbound.RabbitRoutingKeyInitializerProducerBehavior.html",
    "title": "Class RabbitRoutingKeyInitializerProducerBehavior | Silverback",
    "keywords": "Class RabbitRoutingKeyInitializerProducerBehavior Sets the routing key header with the value from the property decorated with the RabbitRoutingKeyAttribute . The header will be used by the RabbitProducer to set the actual routing key. Inheritance System.Object RabbitRoutingKeyInitializerProducerBehavior Implements Silverback.Messaging.Broker.Behaviors.IProducerBehavior Silverback.Messaging.Broker.Behaviors.IBrokerBehavior ISorted Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Silverback.Messaging.Outbound Assembly : Silverback.Integration.RabbitMQ.dll Syntax public class RabbitRoutingKeyInitializerProducerBehavior : IProducerBehavior, IBrokerBehavior, ISorted Properties | Improve this doc View source SortIndex Declaration public int SortIndex { get; } Property Value Type Description System.Int32 Methods | Improve this doc View source HandleAsync(ProducerPipelineContext, ProducerBehaviorHandler) Declaration public async Task HandleAsync(ProducerPipelineContext context, ProducerBehaviorHandler next) Parameters Type Name Description Silverback.Messaging.Broker.Behaviors.ProducerPipelineContext context Silverback.Messaging.Broker.Behaviors.ProducerBehaviorHandler next Returns Type Description System.Threading.Tasks.Task Implements Silverback.Messaging.Broker.Behaviors.IProducerBehavior Silverback.Messaging.Broker.Behaviors.IBrokerBehavior ISorted"
  },
  "api/Silverback.Messaging.Publishing.BehaviorsProvider.html": {
    "href": "api/Silverback.Messaging.Publishing.BehaviorsProvider.html",
    "title": "Class BehaviorsProvider | Silverback",
    "keywords": "Class BehaviorsProvider Inheritance System.Object BehaviorsProvider Implements IBehaviorsProvider Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Silverback.Messaging.Publishing Assembly : Silverback.Core.dll Syntax public class BehaviorsProvider : IBehaviorsProvider Constructors | Improve this doc View source BehaviorsProvider(IServiceProvider) Initializes a new instance of the BehaviorsProvider class. Declaration public BehaviorsProvider(IServiceProvider serviceProvider) Parameters Type Name Description System.IServiceProvider serviceProvider The System.IServiceProvider to be used to resolve the required services. Methods | Improve this doc View source CreateStack() Declaration public Stack<IBehavior> CreateStack() Returns Type Description System.Collections.Generic.Stack < IBehavior > Implements IBehaviorsProvider"
  },
  "api/Silverback.Messaging.Publishing.CommandPublisher.html": {
    "href": "api/Silverback.Messaging.Publishing.CommandPublisher.html",
    "title": "Class CommandPublisher | Silverback",
    "keywords": "Class CommandPublisher Inheritance System.Object CommandPublisher Implements ICommandPublisher Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Silverback.Messaging.Publishing Assembly : Silverback.Core.Model.dll Syntax public class CommandPublisher : ICommandPublisher Constructors | Improve this doc View source CommandPublisher(IPublisher) Initializes a new instance of the CommandPublisher class. Declaration public CommandPublisher(IPublisher publisher) Parameters Type Name Description IPublisher publisher The IPublisher to be wrapped. Methods | Improve this doc View source Execute(ICommand) Declaration public void Execute(ICommand commandMessage) Parameters Type Name Description ICommand commandMessage | Improve this doc View source Execute(ICommand, Boolean) Declaration public void Execute(ICommand commandMessage, bool throwIfUnhandled) Parameters Type Name Description ICommand commandMessage System.Boolean throwIfUnhandled | Improve this doc View source Execute<TResult>(ICommand<TResult>) Declaration public TResult Execute<TResult>(ICommand<TResult> commandMessage) Parameters Type Name Description ICommand <TResult> commandMessage Returns Type Description TResult Type Parameters Name Description TResult | Improve this doc View source Execute<TResult>(ICommand<TResult>, Boolean) Declaration public TResult Execute<TResult>(ICommand<TResult> commandMessage, bool throwIfUnhandled) Parameters Type Name Description ICommand <TResult> commandMessage System.Boolean throwIfUnhandled Returns Type Description TResult Type Parameters Name Description TResult | Improve this doc View source ExecuteAsync(ICommand) Declaration public Task ExecuteAsync(ICommand commandMessage) Parameters Type Name Description ICommand commandMessage Returns Type Description System.Threading.Tasks.Task | Improve this doc View source ExecuteAsync(ICommand, Boolean) Declaration public Task ExecuteAsync(ICommand commandMessage, bool throwIfUnhandled) Parameters Type Name Description ICommand commandMessage System.Boolean throwIfUnhandled Returns Type Description System.Threading.Tasks.Task | Improve this doc View source ExecuteAsync<TResult>(ICommand<TResult>) Declaration public async Task<TResult> ExecuteAsync<TResult>(ICommand<TResult> commandMessage) Parameters Type Name Description ICommand <TResult> commandMessage Returns Type Description System.Threading.Tasks.Task <TResult> Type Parameters Name Description TResult | Improve this doc View source ExecuteAsync<TResult>(ICommand<TResult>, Boolean) Declaration public async Task<TResult> ExecuteAsync<TResult>(ICommand<TResult> commandMessage, bool throwIfUnhandled) Parameters Type Name Description ICommand <TResult> commandMessage System.Boolean throwIfUnhandled Returns Type Description System.Threading.Tasks.Task <TResult> Type Parameters Name Description TResult Implements ICommandPublisher"
  },
  "api/Silverback.Messaging.Publishing.EventPublisher.html": {
    "href": "api/Silverback.Messaging.Publishing.EventPublisher.html",
    "title": "Class EventPublisher | Silverback",
    "keywords": "Class EventPublisher Inheritance System.Object EventPublisher Implements IEventPublisher Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Silverback.Messaging.Publishing Assembly : Silverback.Core.Model.dll Syntax public class EventPublisher : IEventPublisher Constructors | Improve this doc View source EventPublisher(IPublisher) Initializes a new instance of the EventPublisher class. Declaration public EventPublisher(IPublisher publisher) Parameters Type Name Description IPublisher publisher The IPublisher to be wrapped. Methods | Improve this doc View source Publish(IEvent) Declaration public void Publish(IEvent eventMessage) Parameters Type Name Description IEvent eventMessage | Improve this doc View source Publish(IEvent, Boolean) Declaration public void Publish(IEvent eventMessage, bool throwIfUnhandled) Parameters Type Name Description IEvent eventMessage System.Boolean throwIfUnhandled | Improve this doc View source PublishAsync(IEvent) Declaration public Task PublishAsync(IEvent eventMessage) Parameters Type Name Description IEvent eventMessage Returns Type Description System.Threading.Tasks.Task | Improve this doc View source PublishAsync(IEvent, Boolean) Declaration public Task PublishAsync(IEvent eventMessage, bool throwIfUnhandled) Parameters Type Name Description IEvent eventMessage System.Boolean throwIfUnhandled Returns Type Description System.Threading.Tasks.Task Implements IEventPublisher"
  },
  "api/Silverback.Messaging.Publishing.html": {
    "href": "api/Silverback.Messaging.Publishing.html",
    "title": "Namespace Silverback.Messaging.Publishing | Silverback",
    "keywords": "Namespace Silverback.Messaging.Publishing Classes BehaviorsProvider CommandPublisher EventPublisher Publisher QueryPublisher UnhandledMessageException The exception that is thrown when some published messages aren't handled by any registered subscriber. Interfaces IBehavior Can be used to build a custom pipeline, plugging some functionality into the IPublisher . IBehaviorsProvider Provides the System.Collections.Generic.Stack<T> of IBehavior to be used in the IPublisher pipeline. ICommandPublisher Publishes the messages implementing ICommand or ICommand<TResult> . IEventPublisher Publishes the messages implementing IEvent . IPublisher Publishes the messages to the internal bus. This is the actual mediator that forwards the messages being published to their subscribers. IQueryPublisher Publishes the messages implementing IQuery<TResult> . Delegates MessageHandler The delegate representing the Handle method of the IBehavior ."
  },
  "api/Silverback.Messaging.Publishing.IBehavior.html": {
    "href": "api/Silverback.Messaging.Publishing.IBehavior.html",
    "title": "Interface IBehavior | Silverback",
    "keywords": "Interface IBehavior Can be used to build a custom pipeline, plugging some functionality into the IPublisher . Namespace : Silverback.Messaging.Publishing Assembly : Silverback.Core.dll Syntax public interface IBehavior Methods | Improve this doc View source HandleAsync(Object, MessageHandler) Process, handles or transforms the messages being published to the internal bus. Declaration Task<IReadOnlyCollection<object>> HandleAsync(object message, MessageHandler next) Parameters Type Name Description System.Object message The message being published. MessageHandler next The next behavior in the pipeline. Returns Type Description System.Threading.Tasks.Task < System.Collections.Generic.IReadOnlyCollection < System.Object >> A System.Threading.Tasks.Task<TResult> representing the asynchronous operation. The task result contains the result values (if any)."
  },
  "api/Silverback.Messaging.Publishing.IBehaviorsProvider.html": {
    "href": "api/Silverback.Messaging.Publishing.IBehaviorsProvider.html",
    "title": "Interface IBehaviorsProvider | Silverback",
    "keywords": "Interface IBehaviorsProvider Provides the System.Collections.Generic.Stack<T> of IBehavior to be used in the IPublisher pipeline. Namespace : Silverback.Messaging.Publishing Assembly : Silverback.Core.dll Syntax public interface IBehaviorsProvider Methods | Improve this doc View source CreateStack() Creates a new System.Collections.Generic.Stack<T> of IBehavior to be used in the IPublisher pipeline. Declaration Stack<IBehavior> CreateStack() Returns Type Description System.Collections.Generic.Stack < IBehavior > The ready-to-use System.Collections.Generic.Stack<T> of IBehavior ."
  },
  "api/Silverback.Messaging.Publishing.ICommandPublisher.html": {
    "href": "api/Silverback.Messaging.Publishing.ICommandPublisher.html",
    "title": "Interface ICommandPublisher | Silverback",
    "keywords": "Interface ICommandPublisher Publishes the messages implementing ICommand or ICommand<TResult> . Namespace : Silverback.Messaging.Publishing Assembly : Silverback.Core.Model.dll Syntax public interface ICommandPublisher Methods | Improve this doc View source Execute(ICommand) Executes the specified command publishing it to the internal bus. The message will be forwarded to its subscribers and the method will not complete until all subscribers have processed it (unless using Silverback.Integration to produce and consume the message through a message broker). Declaration void Execute(ICommand commandMessage) Parameters Type Name Description ICommand commandMessage The command to be executed. | Improve this doc View source Execute(ICommand, Boolean) Executes the specified command publishing it to the internal bus. The message will be forwarded to its subscribers and the method will not complete until all subscribers have processed it (unless using Silverback.Integration to produce and consume the message through a message broker). Declaration void Execute(ICommand commandMessage, bool throwIfUnhandled) Parameters Type Name Description ICommand commandMessage The command to be executed. System.Boolean throwIfUnhandled A boolean value indicating whether an exception must be thrown if no subscriber is handling the message. | Improve this doc View source Execute<TResult>(ICommand<TResult>) Executes the specified command publishing it to the internal bus. The message will be forwarded to its subscribers and the method will not complete until all subscribers have processed it (unless using Silverback.Integration to produce and consume the message through a message broker). Declaration TResult Execute<TResult>(ICommand<TResult> commandMessage) Parameters Type Name Description ICommand <TResult> commandMessage The command to be executed. Returns Type Description TResult The command result. Type Parameters Name Description TResult The type of the result that is expected to be returned by the subscribers. | Improve this doc View source Execute<TResult>(ICommand<TResult>, Boolean) Executes the specified command publishing it to the internal bus. The message will be forwarded to its subscribers and the method will not complete until all subscribers have processed it (unless using Silverback.Integration to produce and consume the message through a message broker). Declaration TResult Execute<TResult>(ICommand<TResult> commandMessage, bool throwIfUnhandled) Parameters Type Name Description ICommand <TResult> commandMessage The command to be executed. System.Boolean throwIfUnhandled A boolean value indicating whether an exception must be thrown if no subscriber is handling the message. Returns Type Description TResult The command result. Type Parameters Name Description TResult The type of the result that is expected to be returned by the subscribers. | Improve this doc View source ExecuteAsync(ICommand) Executes the specified command publishing it to the internal bus. The message will be forwarded to its subscribers and the System.Threading.Tasks.Task will not complete until all subscribers have processed it (unless using Silverback.Integration to produce and consume the message through a message broker). Declaration Task ExecuteAsync(ICommand commandMessage) Parameters Type Name Description ICommand commandMessage The command to be executed. Returns Type Description System.Threading.Tasks.Task A System.Threading.Tasks.Task representing the asynchronous operation. | Improve this doc View source ExecuteAsync(ICommand, Boolean) Executes the specified command publishing it to the internal bus. The message will be forwarded to its subscribers and the System.Threading.Tasks.Task will not complete until all subscribers have processed it (unless using Silverback.Integration to produce and consume the message through a message broker). Declaration Task ExecuteAsync(ICommand commandMessage, bool throwIfUnhandled) Parameters Type Name Description ICommand commandMessage The command to be executed. System.Boolean throwIfUnhandled A boolean value indicating whether an exception must be thrown if no subscriber is handling the message. Returns Type Description System.Threading.Tasks.Task A System.Threading.Tasks.Task representing the asynchronous operation. | Improve this doc View source ExecuteAsync<TResult>(ICommand<TResult>) Executes the specified command publishing it to the internal bus. The message will be forwarded to its subscribers and the System.Threading.Tasks.Task will not complete until all subscribers have processed it (unless using Silverback.Integration to produce and consume the message through a message broker). Declaration Task<TResult> ExecuteAsync<TResult>(ICommand<TResult> commandMessage) Parameters Type Name Description ICommand <TResult> commandMessage The command to be executed. Returns Type Description System.Threading.Tasks.Task <TResult> A System.Threading.Tasks.Task<TResult> representing the asynchronous operation. The task result contains the command result. Type Parameters Name Description TResult The type of the result that is expected to be returned by the subscribers. | Improve this doc View source ExecuteAsync<TResult>(ICommand<TResult>, Boolean) Executes the specified command publishing it to the internal bus. The message will be forwarded to its subscribers and the System.Threading.Tasks.Task will not complete until all subscribers have processed it (unless using Silverback.Integration to produce and consume the message through a message broker). Declaration Task<TResult> ExecuteAsync<TResult>(ICommand<TResult> commandMessage, bool throwIfUnhandled) Parameters Type Name Description ICommand <TResult> commandMessage The command to be executed. System.Boolean throwIfUnhandled A boolean value indicating whether an exception must be thrown if no subscriber is handling the message. Returns Type Description System.Threading.Tasks.Task <TResult> A System.Threading.Tasks.Task<TResult> representing the asynchronous operation. The task result contains the command result. Type Parameters Name Description TResult The type of the result that is expected to be returned by the subscribers."
  },
  "api/Silverback.Messaging.Publishing.IEventPublisher.html": {
    "href": "api/Silverback.Messaging.Publishing.IEventPublisher.html",
    "title": "Interface IEventPublisher | Silverback",
    "keywords": "Interface IEventPublisher Publishes the messages implementing IEvent . Namespace : Silverback.Messaging.Publishing Assembly : Silverback.Core.Model.dll Syntax public interface IEventPublisher Methods | Improve this doc View source Publish(IEvent) Publishes the specified event to the internal bus. The message will be forwarded to its subscribers and the method will not complete until all subscribers have processed it (unless using Silverback.Integration to produce and consume the message through a message broker). Declaration void Publish(IEvent eventMessage) Parameters Type Name Description IEvent eventMessage The event to be published. | Improve this doc View source Publish(IEvent, Boolean) Publishes the specified event to the internal bus. The message will be forwarded to its subscribers and the method will not complete until all subscribers have processed it (unless using Silverback.Integration to produce and consume the message through a message broker). Declaration void Publish(IEvent eventMessage, bool throwIfUnhandled) Parameters Type Name Description IEvent eventMessage The event to be published. System.Boolean throwIfUnhandled A boolean value indicating whether an exception must be thrown if no subscriber is handling the message. | Improve this doc View source PublishAsync(IEvent) Publishes the specified event to the internal bus. The message will be forwarded to its subscribers and the System.Threading.Tasks.Task will not complete until all subscribers have processed it (unless using Silverback.Integration to produce and consume the message through a message broker). Declaration Task PublishAsync(IEvent eventMessage) Parameters Type Name Description IEvent eventMessage The event to be executed. Returns Type Description System.Threading.Tasks.Task A System.Threading.Tasks.Task representing the asynchronous operation. | Improve this doc View source PublishAsync(IEvent, Boolean) Publishes the specified event to the internal bus. The message will be forwarded to its subscribers and the System.Threading.Tasks.Task will not complete until all subscribers have processed it (unless using Silverback.Integration to produce and consume the message through a message broker). Declaration Task PublishAsync(IEvent eventMessage, bool throwIfUnhandled) Parameters Type Name Description IEvent eventMessage The event to be executed. System.Boolean throwIfUnhandled A boolean value indicating whether an exception must be thrown if no subscriber is handling the message. Returns Type Description System.Threading.Tasks.Task A System.Threading.Tasks.Task representing the asynchronous operation."
  },
  "api/Silverback.Messaging.Publishing.IPublisher.html": {
    "href": "api/Silverback.Messaging.Publishing.IPublisher.html",
    "title": "Interface IPublisher | Silverback",
    "keywords": "Interface IPublisher Publishes the messages to the internal bus. This is the actual mediator that forwards the messages being published to their subscribers. Namespace : Silverback.Messaging.Publishing Assembly : Silverback.Core.dll Syntax public interface IPublisher Methods | Improve this doc View source Publish(Object) Publishes the specified message to the internal bus. The message will be forwarded to its subscribers and the method will not complete until all subscribers have processed it (unless using Silverback.Integration to produce and consume the message through a message broker). Declaration void Publish(object message) Parameters Type Name Description System.Object message The message to be published. | Improve this doc View source Publish(Object, Boolean) Publishes the specified message to the internal bus. The message will be forwarded to its subscribers and the method will not complete until all subscribers have processed it (unless using Silverback.Integration to produce and consume the message through a message broker). Declaration void Publish(object message, bool throwIfUnhandled) Parameters Type Name Description System.Object message The message to be published. System.Boolean throwIfUnhandled A boolean value indicating whether an exception must be thrown if no subscriber is handling the message. | Improve this doc View source Publish<TResult>(Object) Publishes the specified message to the internal bus. The message will be forwarded to its subscribers and the method will not complete until all subscribers have processed it (unless using Silverback.Integration to produce and consume the message through a message broker). Declaration IReadOnlyCollection<TResult> Publish<TResult>(object message) Parameters Type Name Description System.Object message The message to be published. Returns Type Description System.Collections.Generic.IReadOnlyCollection <TResult> A collection of TResult , since multiple subscribers could handle the message and return a value. Type Parameters Name Description TResult The type of the result that is expected to be returned by the subscribers. | Improve this doc View source Publish<TResult>(Object, Boolean) Publishes the specified message to the internal bus. The message will be forwarded to its subscribers and the method will not complete until all subscribers have processed it (unless using Silverback.Integration to produce and consume the message through a message broker). Declaration IReadOnlyCollection<TResult> Publish<TResult>(object message, bool throwIfUnhandled) Parameters Type Name Description System.Object message The message to be published. System.Boolean throwIfUnhandled A boolean value indicating whether an exception must be thrown if no subscriber is handling the message. Returns Type Description System.Collections.Generic.IReadOnlyCollection <TResult> A collection of TResult , since multiple subscribers could handle the message and return a value. Type Parameters Name Description TResult The type of the result that is expected to be returned by the subscribers. | Improve this doc View source PublishAsync(Object) Publishes the specified message to the internal bus. The message will be forwarded to its subscribers and the System.Threading.Tasks.Task will not complete until all subscribers have processed it (unless using Silverback.Integration to produce and consume the message through a message broker). Declaration Task PublishAsync(object message) Parameters Type Name Description System.Object message The message to be published. Returns Type Description System.Threading.Tasks.Task A System.Threading.Tasks.Task representing the asynchronous operation. | Improve this doc View source PublishAsync(Object, Boolean) Publishes the specified message to the internal bus. The message will be forwarded to its subscribers and the System.Threading.Tasks.Task will not complete until all subscribers have processed it (unless using Silverback.Integration to produce and consume the message through a message broker). Declaration Task PublishAsync(object message, bool throwIfUnhandled) Parameters Type Name Description System.Object message The message to be published. System.Boolean throwIfUnhandled A boolean value indicating whether an exception must be thrown if no subscriber is handling the message. Returns Type Description System.Threading.Tasks.Task A System.Threading.Tasks.Task representing the asynchronous operation. | Improve this doc View source PublishAsync<TResult>(Object) Publishes the specified message to the internal bus. The message will be forwarded to its subscribers and the System.Threading.Tasks.Task will not complete until all subscribers have processed it (unless using Silverback.Integration to produce and consume the message through a message broker). Declaration Task<IReadOnlyCollection<TResult>> PublishAsync<TResult>(object message) Parameters Type Name Description System.Object message The message to be published. Returns Type Description System.Threading.Tasks.Task < System.Collections.Generic.IReadOnlyCollection <TResult>> A System.Threading.Tasks.Task<TResult> representing the asynchronous operation. The task result contains a collection of TResult , since multiple subscribers could handle the message and return a value. Type Parameters Name Description TResult The type of the result that is expected to be returned by the subscribers. | Improve this doc View source PublishAsync<TResult>(Object, Boolean) Publishes the specified message to the internal bus. The message will be forwarded to its subscribers and the System.Threading.Tasks.Task will not complete until all subscribers have processed it (unless using Silverback.Integration to produce and consume the message through a message broker). Declaration Task<IReadOnlyCollection<TResult>> PublishAsync<TResult>(object message, bool throwIfUnhandled) Parameters Type Name Description System.Object message The message to be published. System.Boolean throwIfUnhandled A boolean value indicating whether an exception must be thrown if no subscriber is handling the message. Returns Type Description System.Threading.Tasks.Task < System.Collections.Generic.IReadOnlyCollection <TResult>> A System.Threading.Tasks.Task<TResult> representing the asynchronous operation. The task result contains a collection of TResult , since multiple subscribers could handle the message and return a value. Type Parameters Name Description TResult The type of the result that is expected to be returned by the subscribers."
  },
  "api/Silverback.Messaging.Publishing.IQueryPublisher.html": {
    "href": "api/Silverback.Messaging.Publishing.IQueryPublisher.html",
    "title": "Interface IQueryPublisher | Silverback",
    "keywords": "Interface IQueryPublisher Publishes the messages implementing IQuery<TResult> . Namespace : Silverback.Messaging.Publishing Assembly : Silverback.Core.Model.dll Syntax public interface IQueryPublisher Methods | Improve this doc View source Execute<TResult>(IQuery<TResult>) Executes the specified query publishing it to the internal bus. The message will be forwarded to its subscribers and the method will not complete until all subscribers have processed it (unless using Silverback.Integration to produce and consume the message through a message broker). Declaration TResult Execute<TResult>(IQuery<TResult> queryMessage) Parameters Type Name Description IQuery <TResult> queryMessage The query to be executed. Returns Type Description TResult The query result. Type Parameters Name Description TResult The type of the expected query result. | Improve this doc View source Execute<TResult>(IQuery<TResult>, Boolean) Executes the specified query publishing it to the internal bus. The message will be forwarded to its subscribers and the method will not complete until all subscribers have processed it (unless using Silverback.Integration to produce and consume the message through a message broker). Declaration TResult Execute<TResult>(IQuery<TResult> queryMessage, bool throwIfUnhandled) Parameters Type Name Description IQuery <TResult> queryMessage The query to be executed. System.Boolean throwIfUnhandled A boolean value indicating whether an exception must be thrown if no subscriber is handling the message. Returns Type Description TResult The query result. Type Parameters Name Description TResult The type of the expected query result. | Improve this doc View source ExecuteAsync<TResult>(IQuery<TResult>) Executes the specified query publishing it to the internal bus. The message will be forwarded to its subscribers and the System.Threading.Tasks.Task will not complete until all subscribers have processed it (unless using Silverback.Integration to produce and consume the message through a message broker). Declaration Task<TResult> ExecuteAsync<TResult>(IQuery<TResult> queryMessage) Parameters Type Name Description IQuery <TResult> queryMessage The query to be executed. Returns Type Description System.Threading.Tasks.Task <TResult> A System.Threading.Tasks.Task<TResult> representing the asynchronous operation. The task result contains the query result. Type Parameters Name Description TResult The type of the expected query result. | Improve this doc View source ExecuteAsync<TResult>(IQuery<TResult>, Boolean) Executes the specified query publishing it to the internal bus. The message will be forwarded to its subscribers and the System.Threading.Tasks.Task will not complete until all subscribers have processed it (unless using Silverback.Integration to produce and consume the message through a message broker). Declaration Task<TResult> ExecuteAsync<TResult>(IQuery<TResult> queryMessage, bool throwIfUnhandled) Parameters Type Name Description IQuery <TResult> queryMessage The query to be executed. System.Boolean throwIfUnhandled A boolean value indicating whether an exception must be thrown if no subscriber is handling the message. Returns Type Description System.Threading.Tasks.Task <TResult> A System.Threading.Tasks.Task<TResult> representing the asynchronous operation. The task result contains the query result. Type Parameters Name Description TResult The type of the expected query result."
  },
  "api/Silverback.Messaging.Publishing.MessageHandler.html": {
    "href": "api/Silverback.Messaging.Publishing.MessageHandler.html",
    "title": "Delegate MessageHandler | Silverback",
    "keywords": "Delegate MessageHandler The delegate representing the Handle method of the IBehavior . Namespace : Silverback.Messaging.Publishing Assembly : Silverback.Core.dll Syntax public delegate Task<IReadOnlyCollection<object>> MessageHandler(object message); Parameters Type Name Description System.Object message The message being published. Returns Type Description System.Threading.Tasks.Task < System.Collections.Generic.IReadOnlyCollection < System.Object >> A System.Threading.Tasks.Task<TResult> representing the asynchronous operation. The task result contains the actual messages to be published."
  },
  "api/Silverback.Messaging.Publishing.Publisher.html": {
    "href": "api/Silverback.Messaging.Publishing.Publisher.html",
    "title": "Class Publisher | Silverback",
    "keywords": "Class Publisher Inheritance System.Object Publisher Implements IPublisher Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Silverback.Messaging.Publishing Assembly : Silverback.Core.dll Syntax public class Publisher : IPublisher Constructors | Improve this doc View source Publisher(IBehaviorsProvider, IServiceProvider, ISilverbackLogger<Publisher>) Initializes a new instance of the Publisher class. Declaration public Publisher(IBehaviorsProvider behaviorsProvider, IServiceProvider serviceProvider, ISilverbackLogger<Publisher> logger) Parameters Type Name Description IBehaviorsProvider behaviorsProvider The IBehaviorsProvider . System.IServiceProvider serviceProvider The System.IServiceProvider instance to be used to resolve the subscribers. ISilverbackLogger < Publisher > logger The ISilverbackLogger . Methods | Improve this doc View source Publish(Object) Declaration public void Publish(object message) Parameters Type Name Description System.Object message | Improve this doc View source Publish(Object, Boolean) Declaration public void Publish(object message, bool throwIfUnhandled) Parameters Type Name Description System.Object message System.Boolean throwIfUnhandled | Improve this doc View source Publish<TResult>(Object) Declaration public IReadOnlyCollection<TResult> Publish<TResult>(object message) Parameters Type Name Description System.Object message Returns Type Description System.Collections.Generic.IReadOnlyCollection <TResult> Type Parameters Name Description TResult | Improve this doc View source Publish<TResult>(Object, Boolean) Declaration public IReadOnlyCollection<TResult> Publish<TResult>(object message, bool throwIfUnhandled) Parameters Type Name Description System.Object message System.Boolean throwIfUnhandled Returns Type Description System.Collections.Generic.IReadOnlyCollection <TResult> Type Parameters Name Description TResult | Improve this doc View source PublishAsync(Object) Declaration public Task PublishAsync(object message) Parameters Type Name Description System.Object message Returns Type Description System.Threading.Tasks.Task | Improve this doc View source PublishAsync(Object, Boolean) Declaration public Task PublishAsync(object message, bool throwIfUnhandled) Parameters Type Name Description System.Object message System.Boolean throwIfUnhandled Returns Type Description System.Threading.Tasks.Task | Improve this doc View source PublishAsync<TResult>(Object) Declaration public Task<IReadOnlyCollection<TResult>> PublishAsync<TResult>(object message) Parameters Type Name Description System.Object message Returns Type Description System.Threading.Tasks.Task < System.Collections.Generic.IReadOnlyCollection <TResult>> Type Parameters Name Description TResult | Improve this doc View source PublishAsync<TResult>(Object, Boolean) Declaration public async Task<IReadOnlyCollection<TResult>> PublishAsync<TResult>(object message, bool throwIfUnhandled) Parameters Type Name Description System.Object message System.Boolean throwIfUnhandled Returns Type Description System.Threading.Tasks.Task < System.Collections.Generic.IReadOnlyCollection <TResult>> Type Parameters Name Description TResult Implements IPublisher"
  },
  "api/Silverback.Messaging.Publishing.QueryPublisher.html": {
    "href": "api/Silverback.Messaging.Publishing.QueryPublisher.html",
    "title": "Class QueryPublisher | Silverback",
    "keywords": "Class QueryPublisher Inheritance System.Object QueryPublisher Implements IQueryPublisher Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Silverback.Messaging.Publishing Assembly : Silverback.Core.Model.dll Syntax public class QueryPublisher : IQueryPublisher Constructors | Improve this doc View source QueryPublisher(IPublisher) Initializes a new instance of the QueryPublisher class. Declaration public QueryPublisher(IPublisher publisher) Parameters Type Name Description IPublisher publisher The IPublisher to be wrapped. Methods | Improve this doc View source Execute<TResult>(IQuery<TResult>) Declaration public TResult Execute<TResult>(IQuery<TResult> queryMessage) Parameters Type Name Description IQuery <TResult> queryMessage Returns Type Description TResult Type Parameters Name Description TResult | Improve this doc View source Execute<TResult>(IQuery<TResult>, Boolean) Declaration public TResult Execute<TResult>(IQuery<TResult> queryMessage, bool throwIfUnhandled) Parameters Type Name Description IQuery <TResult> queryMessage System.Boolean throwIfUnhandled Returns Type Description TResult Type Parameters Name Description TResult | Improve this doc View source ExecuteAsync<TResult>(IQuery<TResult>) Declaration public async Task<TResult> ExecuteAsync<TResult>(IQuery<TResult> queryMessage) Parameters Type Name Description IQuery <TResult> queryMessage Returns Type Description System.Threading.Tasks.Task <TResult> Type Parameters Name Description TResult | Improve this doc View source ExecuteAsync<TResult>(IQuery<TResult>, Boolean) Declaration public async Task<TResult> ExecuteAsync<TResult>(IQuery<TResult> queryMessage, bool throwIfUnhandled) Parameters Type Name Description IQuery <TResult> queryMessage System.Boolean throwIfUnhandled Returns Type Description System.Threading.Tasks.Task <TResult> Type Parameters Name Description TResult Implements IQueryPublisher"
  },
  "api/Silverback.Messaging.Publishing.UnhandledMessageException.html": {
    "href": "api/Silverback.Messaging.Publishing.UnhandledMessageException.html",
    "title": "Class UnhandledMessageException | Silverback",
    "keywords": "Class UnhandledMessageException The exception that is thrown when some published messages aren't handled by any registered subscriber. Inheritance System.Object System.Exception SilverbackException UnhandledMessageException Implements System.Runtime.Serialization.ISerializable Inherited Members System.Exception.GetBaseException() System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo, System.Runtime.Serialization.StreamingContext) System.Exception.GetType() System.Exception.ToString() System.Exception.Data System.Exception.HelpLink System.Exception.HResult System.Exception.InnerException System.Exception.Message System.Exception.Source System.Exception.StackTrace System.Exception.TargetSite System.Exception.SerializeObjectState System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Silverback.Messaging.Publishing Assembly : Silverback.Core.dll Syntax [Serializable] public class UnhandledMessageException : SilverbackException, ISerializable Constructors | Improve this doc View source UnhandledMessageException() Initializes a new instance of the UnhandledMessageException class. Declaration public UnhandledMessageException() | Improve this doc View source UnhandledMessageException(Object) Initializes a new instance of the UnhandledMessageException class with the specified message. Declaration public UnhandledMessageException(object unhandledMessage) Parameters Type Name Description System.Object unhandledMessage The message that wasn't handled. | Improve this doc View source UnhandledMessageException(SerializationInfo, StreamingContext) Initializes a new instance of the UnhandledMessageException class with the serialized data. Declaration protected UnhandledMessageException(SerializationInfo info, StreamingContext context) Parameters Type Name Description System.Runtime.Serialization.SerializationInfo info The System.Runtime.Serialization.SerializationInfo that holds the serialized object data about the exception being thrown. System.Runtime.Serialization.StreamingContext context The System.Runtime.Serialization.StreamingContext that contains contextual information about the source or destination. | Improve this doc View source UnhandledMessageException(String) Initializes a new instance of the UnhandledMessageException class with the specified message. Declaration public UnhandledMessageException(string message) Parameters Type Name Description System.String message The exception message. | Improve this doc View source UnhandledMessageException(String, Exception) Initializes a new instance of the UnhandledMessageException class with the specified message and inner exception. Declaration public UnhandledMessageException(string message, Exception innerException) Parameters Type Name Description System.String message The exception message. System.Exception innerException The inner exception. Properties | Improve this doc View source UnhandledMessage Gets the message that wasn't handled. Declaration public object UnhandledMessage { get; } Property Value Type Description System.Object Implements System.Runtime.Serialization.ISerializable"
  },
  "api/Silverback.Messaging.RabbitConsumerEndpoint.html": {
    "href": "api/Silverback.Messaging.RabbitConsumerEndpoint.html",
    "title": "Class RabbitConsumerEndpoint | Silverback",
    "keywords": "Class RabbitConsumerEndpoint Represents a queue or exchange to consume from. Inheritance System.Object Silverback.Messaging.Endpoint Silverback.Messaging.ConsumerEndpoint RabbitConsumerEndpoint RabbitExchangeConsumerEndpoint RabbitQueueConsumerEndpoint Implements Silverback.Messaging.IConsumerEndpoint Silverback.Messaging.IEndpoint Inherited Members Silverback.Messaging.ConsumerEndpoint.ErrorPolicy Silverback.Messaging.ConsumerEndpoint.ExactlyOnceStrategy Silverback.Messaging.ConsumerEndpoint.Batch Silverback.Messaging.ConsumerEndpoint.Sequence Silverback.Messaging.ConsumerEndpoint.NullMessageHandlingStrategy Silverback.Messaging.ConsumerEndpoint.ThrowIfUnhandled Silverback.Messaging.ConsumerEndpoint.GetUniqueConsumerGroupName() Silverback.Messaging.Endpoint.DefaultSerializer Silverback.Messaging.Endpoint.DisplayName Silverback.Messaging.Endpoint.Name Silverback.Messaging.Endpoint.FriendlyName Silverback.Messaging.Endpoint.Serializer Silverback.Messaging.Endpoint.Encryption Silverback.Messaging.Endpoint.MessageValidationMode System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Silverback.Messaging Assembly : Silverback.Integration.RabbitMQ.dll Syntax public abstract class RabbitConsumerEndpoint : ConsumerEndpoint, IConsumerEndpoint, IEndpoint Constructors | Improve this doc View source RabbitConsumerEndpoint(String) Initializes a new instance of the RabbitConsumerEndpoint class. Declaration protected RabbitConsumerEndpoint(string name) Parameters Type Name Description System.String name The name of the queue or exchange. Properties | Improve this doc View source AcknowledgeEach Gets or sets the number of message to be processed before sending the acknowledgment to the server. The most reliable level is 1 but it reduces throughput. Declaration public int AcknowledgeEach { get; set; } Property Value Type Description System.Int32 | Improve this doc View source Connection Gets or sets the RabbitMQ connection settings. Declaration public RabbitConnectionConfig Connection { get; set; } Property Value Type Description RabbitConnectionConfig | Improve this doc View source PrefetchCount Gets or sets the QoS prefetch count parameter for the consumer. Declaration public ushort PrefetchCount { get; set; } Property Value Type Description System.UInt16 | Improve this doc View source PrefetchSize Gets or sets the QoS prefetch size parameter for the consumer. Declaration public uint PrefetchSize { get; set; } Property Value Type Description System.UInt32 | Improve this doc View source Queue Gets or sets the queue configuration. Declaration public RabbitQueueConfig Queue { get; set; } Property Value Type Description RabbitQueueConfig Methods | Improve this doc View source BaseEquals(Endpoint) Declaration protected override bool BaseEquals(Endpoint other) Parameters Type Name Description Silverback.Messaging.Endpoint other Returns Type Description System.Boolean Overrides Silverback.Messaging.Endpoint.BaseEquals(Silverback.Messaging.Endpoint) | Improve this doc View source Validate() Declaration public override void Validate() Overrides Silverback.Messaging.ConsumerEndpoint.Validate() Implements Silverback.Messaging.IConsumerEndpoint Silverback.Messaging.IEndpoint"
  },
  "api/Silverback.Messaging.RabbitExchangeConsumerEndpoint.html": {
    "href": "api/Silverback.Messaging.RabbitExchangeConsumerEndpoint.html",
    "title": "Class RabbitExchangeConsumerEndpoint | Silverback",
    "keywords": "Class RabbitExchangeConsumerEndpoint Represents an exchange to consume from. Inheritance System.Object Silverback.Messaging.Endpoint Silverback.Messaging.ConsumerEndpoint RabbitConsumerEndpoint RabbitExchangeConsumerEndpoint Implements Silverback.Messaging.IConsumerEndpoint Silverback.Messaging.IEndpoint System.IEquatable < RabbitExchangeConsumerEndpoint > Inherited Members RabbitConsumerEndpoint.Connection RabbitConsumerEndpoint.Queue RabbitConsumerEndpoint.AcknowledgeEach RabbitConsumerEndpoint.PrefetchSize RabbitConsumerEndpoint.PrefetchCount RabbitConsumerEndpoint.BaseEquals(Endpoint) Silverback.Messaging.ConsumerEndpoint.ErrorPolicy Silverback.Messaging.ConsumerEndpoint.ExactlyOnceStrategy Silverback.Messaging.ConsumerEndpoint.Batch Silverback.Messaging.ConsumerEndpoint.Sequence Silverback.Messaging.ConsumerEndpoint.NullMessageHandlingStrategy Silverback.Messaging.ConsumerEndpoint.ThrowIfUnhandled Silverback.Messaging.Endpoint.DefaultSerializer Silverback.Messaging.Endpoint.DisplayName Silverback.Messaging.Endpoint.Name Silverback.Messaging.Endpoint.FriendlyName Silverback.Messaging.Endpoint.Serializer Silverback.Messaging.Endpoint.Encryption Silverback.Messaging.Endpoint.MessageValidationMode System.Object.Equals(System.Object, System.Object) System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Silverback.Messaging Assembly : Silverback.Integration.RabbitMQ.dll Syntax public sealed class RabbitExchangeConsumerEndpoint : RabbitConsumerEndpoint, IConsumerEndpoint, IEndpoint, IEquatable<RabbitExchangeConsumerEndpoint> Constructors | Improve this doc View source RabbitExchangeConsumerEndpoint(String) Initializes a new instance of the RabbitExchangeConsumerEndpoint class. Declaration public RabbitExchangeConsumerEndpoint(string name) Parameters Type Name Description System.String name The name of the exchange. Properties | Improve this doc View source Exchange Gets or sets the exchange configuration. Declaration public RabbitExchangeConfig Exchange { get; set; } Property Value Type Description RabbitExchangeConfig | Improve this doc View source QueueName Gets or sets the desired queue name. If null or empty a random name will be generated by RabbitMQ. Declaration public string QueueName { get; set; } Property Value Type Description System.String | Improve this doc View source RoutingKey Gets or sets the routing key (aka binding key) to be used to bind with the exchange. Declaration public string RoutingKey { get; set; } Property Value Type Description System.String Methods | Improve this doc View source Equals(RabbitExchangeConsumerEndpoint) Declaration public bool Equals(RabbitExchangeConsumerEndpoint other) Parameters Type Name Description RabbitExchangeConsumerEndpoint other Returns Type Description System.Boolean | Improve this doc View source Equals(Object) Declaration public override bool Equals(object obj) Parameters Type Name Description System.Object obj Returns Type Description System.Boolean Overrides System.Object.Equals(System.Object) | Improve this doc View source GetHashCode() Declaration public override int GetHashCode() Returns Type Description System.Int32 Overrides System.Object.GetHashCode() | Improve this doc View source GetUniqueConsumerGroupName() Declaration public override string GetUniqueConsumerGroupName() Returns Type Description System.String Overrides Silverback.Messaging.ConsumerEndpoint.GetUniqueConsumerGroupName() | Improve this doc View source Validate() Declaration public override void Validate() Overrides RabbitConsumerEndpoint.Validate() Implements Silverback.Messaging.IConsumerEndpoint Silverback.Messaging.IEndpoint System.IEquatable<T>"
  },
  "api/Silverback.Messaging.RabbitExchangeProducerEndpoint.html": {
    "href": "api/Silverback.Messaging.RabbitExchangeProducerEndpoint.html",
    "title": "Class RabbitExchangeProducerEndpoint | Silverback",
    "keywords": "Class RabbitExchangeProducerEndpoint Represents an exchange to produce to. Inheritance System.Object Silverback.Messaging.Endpoint Silverback.Messaging.ProducerEndpoint RabbitProducerEndpoint RabbitExchangeProducerEndpoint Implements Silverback.Messaging.IProducerEndpoint Silverback.Messaging.IEndpoint System.IEquatable < RabbitExchangeProducerEndpoint > Inherited Members RabbitProducerEndpoint.Connection RabbitProducerEndpoint.ConfirmationTimeout RabbitProducerEndpoint.BaseEquals(Endpoint) Silverback.Messaging.ProducerEndpoint.Chunk Silverback.Messaging.ProducerEndpoint.Strategy Silverback.Messaging.ProducerEndpoint.MessageEnrichers Silverback.Messaging.ProducerEndpoint.Silverback.Messaging.IProducerEndpoint.MessageEnrichers Silverback.Messaging.ProducerEndpoint.GetActualName(Silverback.Messaging.Messages.IOutboundEnvelope, System.IServiceProvider) Silverback.Messaging.Endpoint.DefaultSerializer Silverback.Messaging.Endpoint.DisplayName Silverback.Messaging.Endpoint.Name Silverback.Messaging.Endpoint.FriendlyName Silverback.Messaging.Endpoint.Serializer Silverback.Messaging.Endpoint.Encryption Silverback.Messaging.Endpoint.MessageValidationMode System.Object.Equals(System.Object, System.Object) System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Silverback.Messaging Assembly : Silverback.Integration.RabbitMQ.dll Syntax public sealed class RabbitExchangeProducerEndpoint : RabbitProducerEndpoint, IProducerEndpoint, IEndpoint, IEquatable<RabbitExchangeProducerEndpoint> Constructors | Improve this doc View source RabbitExchangeProducerEndpoint(String) Initializes a new instance of the RabbitExchangeProducerEndpoint class. Declaration public RabbitExchangeProducerEndpoint(string name) Parameters Type Name Description System.String name The name of the exchange. Properties | Improve this doc View source Exchange Gets or sets the exchange configuration. Declaration public RabbitExchangeConfig Exchange { get; set; } Property Value Type Description RabbitExchangeConfig Methods | Improve this doc View source Equals(RabbitExchangeProducerEndpoint) Declaration public bool Equals(RabbitExchangeProducerEndpoint other) Parameters Type Name Description RabbitExchangeProducerEndpoint other Returns Type Description System.Boolean | Improve this doc View source Equals(Object) Declaration public override bool Equals(object obj) Parameters Type Name Description System.Object obj Returns Type Description System.Boolean Overrides System.Object.Equals(System.Object) | Improve this doc View source GetHashCode() Declaration public override int GetHashCode() Returns Type Description System.Int32 Overrides System.Object.GetHashCode() | Improve this doc View source Validate() Declaration public override void Validate() Overrides RabbitProducerEndpoint.Validate() Implements Silverback.Messaging.IProducerEndpoint Silverback.Messaging.IEndpoint System.IEquatable<T>"
  },
  "api/Silverback.Messaging.RabbitProducerEndpoint.html": {
    "href": "api/Silverback.Messaging.RabbitProducerEndpoint.html",
    "title": "Class RabbitProducerEndpoint | Silverback",
    "keywords": "Class RabbitProducerEndpoint Represents a queue or exchange to produce to. Inheritance System.Object Silverback.Messaging.Endpoint Silverback.Messaging.ProducerEndpoint RabbitProducerEndpoint RabbitExchangeProducerEndpoint RabbitQueueProducerEndpoint Implements Silverback.Messaging.IProducerEndpoint Silverback.Messaging.IEndpoint Inherited Members Silverback.Messaging.ProducerEndpoint.Chunk Silverback.Messaging.ProducerEndpoint.Strategy Silverback.Messaging.ProducerEndpoint.MessageEnrichers Silverback.Messaging.ProducerEndpoint.Silverback.Messaging.IProducerEndpoint.MessageEnrichers Silverback.Messaging.ProducerEndpoint.GetActualName(Silverback.Messaging.Messages.IOutboundEnvelope, System.IServiceProvider) Silverback.Messaging.Endpoint.DefaultSerializer Silverback.Messaging.Endpoint.DisplayName Silverback.Messaging.Endpoint.Name Silverback.Messaging.Endpoint.FriendlyName Silverback.Messaging.Endpoint.Serializer Silverback.Messaging.Endpoint.Encryption Silverback.Messaging.Endpoint.MessageValidationMode System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Silverback.Messaging Assembly : Silverback.Integration.RabbitMQ.dll Syntax public abstract class RabbitProducerEndpoint : ProducerEndpoint, IProducerEndpoint, IEndpoint Constructors | Improve this doc View source RabbitProducerEndpoint(String) Initializes a new instance of the RabbitProducerEndpoint class. Declaration protected RabbitProducerEndpoint(string name) Parameters Type Name Description System.String name The name of the queue or exchange. Properties | Improve this doc View source ConfirmationTimeout Gets or sets the maximum amount of time to wait for the message produce to be acknowledge before considering it failed. Set it to null to proceed without waiting for a positive or negative acknowledgment. The default is a quite conservative 5 seconds. Declaration public TimeSpan? ConfirmationTimeout { get; set; } Property Value Type Description System.Nullable < System.TimeSpan > | Improve this doc View source Connection Gets or sets the RabbitMQ connection settings. Declaration public RabbitConnectionConfig Connection { get; set; } Property Value Type Description RabbitConnectionConfig Methods | Improve this doc View source BaseEquals(Endpoint) Declaration protected override bool BaseEquals(Endpoint other) Parameters Type Name Description Silverback.Messaging.Endpoint other Returns Type Description System.Boolean Overrides Silverback.Messaging.ProducerEndpoint.BaseEquals(Silverback.Messaging.Endpoint) | Improve this doc View source Validate() Declaration public override void Validate() Overrides Silverback.Messaging.ProducerEndpoint.Validate() Implements Silverback.Messaging.IProducerEndpoint Silverback.Messaging.IEndpoint"
  },
  "api/Silverback.Messaging.RabbitQueueConsumerEndpoint.html": {
    "href": "api/Silverback.Messaging.RabbitQueueConsumerEndpoint.html",
    "title": "Class RabbitQueueConsumerEndpoint | Silverback",
    "keywords": "Class RabbitQueueConsumerEndpoint Represents a queue to consume from. Inheritance System.Object Silverback.Messaging.Endpoint Silverback.Messaging.ConsumerEndpoint RabbitConsumerEndpoint RabbitQueueConsumerEndpoint Implements Silverback.Messaging.IConsumerEndpoint Silverback.Messaging.IEndpoint System.IEquatable < RabbitQueueConsumerEndpoint > Inherited Members RabbitConsumerEndpoint.Connection RabbitConsumerEndpoint.Queue RabbitConsumerEndpoint.AcknowledgeEach RabbitConsumerEndpoint.PrefetchSize RabbitConsumerEndpoint.PrefetchCount RabbitConsumerEndpoint.Validate() RabbitConsumerEndpoint.BaseEquals(Endpoint) Silverback.Messaging.ConsumerEndpoint.ErrorPolicy Silverback.Messaging.ConsumerEndpoint.ExactlyOnceStrategy Silverback.Messaging.ConsumerEndpoint.Batch Silverback.Messaging.ConsumerEndpoint.Sequence Silverback.Messaging.ConsumerEndpoint.NullMessageHandlingStrategy Silverback.Messaging.ConsumerEndpoint.ThrowIfUnhandled Silverback.Messaging.Endpoint.DefaultSerializer Silverback.Messaging.Endpoint.DisplayName Silverback.Messaging.Endpoint.Name Silverback.Messaging.Endpoint.FriendlyName Silverback.Messaging.Endpoint.Serializer Silverback.Messaging.Endpoint.Encryption Silverback.Messaging.Endpoint.MessageValidationMode System.Object.Equals(System.Object, System.Object) System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Silverback.Messaging Assembly : Silverback.Integration.RabbitMQ.dll Syntax public sealed class RabbitQueueConsumerEndpoint : RabbitConsumerEndpoint, IConsumerEndpoint, IEndpoint, IEquatable<RabbitQueueConsumerEndpoint> Constructors | Improve this doc View source RabbitQueueConsumerEndpoint(String) Initializes a new instance of the RabbitQueueConsumerEndpoint class. Declaration public RabbitQueueConsumerEndpoint(string name) Parameters Type Name Description System.String name The name of the queue. Methods | Improve this doc View source Equals(RabbitQueueConsumerEndpoint) Declaration public bool Equals(RabbitQueueConsumerEndpoint other) Parameters Type Name Description RabbitQueueConsumerEndpoint other Returns Type Description System.Boolean | Improve this doc View source Equals(Object) Declaration public override bool Equals(object obj) Parameters Type Name Description System.Object obj Returns Type Description System.Boolean Overrides System.Object.Equals(System.Object) | Improve this doc View source GetHashCode() Declaration public override int GetHashCode() Returns Type Description System.Int32 Overrides System.Object.GetHashCode() | Improve this doc View source GetUniqueConsumerGroupName() Declaration public override string GetUniqueConsumerGroupName() Returns Type Description System.String Overrides Silverback.Messaging.ConsumerEndpoint.GetUniqueConsumerGroupName() Implements Silverback.Messaging.IConsumerEndpoint Silverback.Messaging.IEndpoint System.IEquatable<T>"
  },
  "api/Silverback.Messaging.RabbitQueueProducerEndpoint.html": {
    "href": "api/Silverback.Messaging.RabbitQueueProducerEndpoint.html",
    "title": "Class RabbitQueueProducerEndpoint | Silverback",
    "keywords": "Class RabbitQueueProducerEndpoint Represents a queue to produce to. Inheritance System.Object Silverback.Messaging.Endpoint Silverback.Messaging.ProducerEndpoint RabbitProducerEndpoint RabbitQueueProducerEndpoint Implements Silverback.Messaging.IProducerEndpoint Silverback.Messaging.IEndpoint System.IEquatable < RabbitQueueProducerEndpoint > Inherited Members RabbitProducerEndpoint.Connection RabbitProducerEndpoint.ConfirmationTimeout RabbitProducerEndpoint.BaseEquals(Endpoint) Silverback.Messaging.ProducerEndpoint.Chunk Silverback.Messaging.ProducerEndpoint.Strategy Silverback.Messaging.ProducerEndpoint.MessageEnrichers Silverback.Messaging.ProducerEndpoint.Silverback.Messaging.IProducerEndpoint.MessageEnrichers Silverback.Messaging.ProducerEndpoint.GetActualName(Silverback.Messaging.Messages.IOutboundEnvelope, System.IServiceProvider) Silverback.Messaging.Endpoint.DefaultSerializer Silverback.Messaging.Endpoint.DisplayName Silverback.Messaging.Endpoint.Name Silverback.Messaging.Endpoint.FriendlyName Silverback.Messaging.Endpoint.Serializer Silverback.Messaging.Endpoint.Encryption Silverback.Messaging.Endpoint.MessageValidationMode System.Object.Equals(System.Object, System.Object) System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Silverback.Messaging Assembly : Silverback.Integration.RabbitMQ.dll Syntax public sealed class RabbitQueueProducerEndpoint : RabbitProducerEndpoint, IProducerEndpoint, IEndpoint, IEquatable<RabbitQueueProducerEndpoint> Constructors | Improve this doc View source RabbitQueueProducerEndpoint(String) Initializes a new instance of the RabbitQueueProducerEndpoint class. Declaration public RabbitQueueProducerEndpoint(string name) Parameters Type Name Description System.String name The name of the queue. Properties | Improve this doc View source Queue Gets or sets the queue configuration. Declaration public RabbitQueueConfig Queue { get; set; } Property Value Type Description RabbitQueueConfig Methods | Improve this doc View source Equals(RabbitQueueProducerEndpoint) Declaration public bool Equals(RabbitQueueProducerEndpoint other) Parameters Type Name Description RabbitQueueProducerEndpoint other Returns Type Description System.Boolean | Improve this doc View source Equals(Object) Declaration public override bool Equals(object obj) Parameters Type Name Description System.Object obj Returns Type Description System.Boolean Overrides System.Object.Equals(System.Object) | Improve this doc View source GetHashCode() Declaration public override int GetHashCode() Returns Type Description System.Int32 Overrides System.Object.GetHashCode() | Improve this doc View source Validate() Declaration public override void Validate() Overrides RabbitProducerEndpoint.Validate() Implements Silverback.Messaging.IProducerEndpoint Silverback.Messaging.IEndpoint System.IEquatable<T>"
  },
  "api/Silverback.Messaging.Serialization.html": {
    "href": "api/Silverback.Messaging.Serialization.html",
    "title": "Namespace Silverback.Messaging.Serialization | Silverback",
    "keywords": "Namespace Silverback.Messaging.Serialization Classes NewtonsoftJsonMessageSerializer Serializes the messages in JSON format and relies on some added headers to determine the message type upon deserialization. This default serializer is ideal when the producer and the consumer are both using Silverback. NewtonsoftJsonMessageSerializer<TMessage> Serializes and deserializes the messages of type TMessage in JSON format. NewtonsoftJsonMessageSerializerBase The base class for NewtonsoftJsonMessageSerializer and NewtonsoftJsonMessageSerializer<TMessage> ."
  },
  "api/Silverback.Messaging.Serialization.NewtonsoftJsonMessageSerializer.html": {
    "href": "api/Silverback.Messaging.Serialization.NewtonsoftJsonMessageSerializer.html",
    "title": "Class NewtonsoftJsonMessageSerializer | Silverback",
    "keywords": "Class NewtonsoftJsonMessageSerializer Serializes the messages in JSON format and relies on some added headers to determine the message type upon deserialization. This default serializer is ideal when the producer and the consumer are both using Silverback. Inheritance System.Object NewtonsoftJsonMessageSerializerBase NewtonsoftJsonMessageSerializer Implements Silverback.Messaging.Serialization.IMessageSerializer System.IEquatable < NewtonsoftJsonMessageSerializer > Inherited Members NewtonsoftJsonMessageSerializerBase.Encoding NewtonsoftJsonMessageSerializerBase.Settings NewtonsoftJsonMessageSerializerBase.SystemEncoding System.Object.Equals(System.Object, System.Object) System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Silverback.Messaging.Serialization Assembly : Silverback.Integration.Newtonsoft.dll Syntax public sealed class NewtonsoftJsonMessageSerializer : NewtonsoftJsonMessageSerializerBase, IMessageSerializer, IEquatable<NewtonsoftJsonMessageSerializer> Properties | Improve this doc View source Default Gets the default static instance of NewtonsoftJsonMessageSerializer . Declaration public static NewtonsoftJsonMessageSerializer Default { get; } Property Value Type Description NewtonsoftJsonMessageSerializer | Improve this doc View source RequireHeaders Declaration public override bool RequireHeaders { get; } Property Value Type Description System.Boolean Overrides NewtonsoftJsonMessageSerializerBase.RequireHeaders Methods | Improve this doc View source DeserializeAsync(Stream, MessageHeaderCollection, MessageSerializationContext) Declaration public override async ValueTask<(object Message, Type MessageType)> DeserializeAsync(Stream messageStream, MessageHeaderCollection messageHeaders, MessageSerializationContext context) Parameters Type Name Description System.IO.Stream messageStream Silverback.Messaging.Messages.MessageHeaderCollection messageHeaders Silverback.Messaging.Serialization.MessageSerializationContext context Returns Type Description System.Threading.Tasks.ValueTask < System.ValueTuple < System.Object , System.Type >> Overrides NewtonsoftJsonMessageSerializerBase.DeserializeAsync(Stream, MessageHeaderCollection, MessageSerializationContext) | Improve this doc View source Equals(NewtonsoftJsonMessageSerializer) Declaration public bool Equals(NewtonsoftJsonMessageSerializer other) Parameters Type Name Description NewtonsoftJsonMessageSerializer other Returns Type Description System.Boolean | Improve this doc View source Equals(Object) Declaration public override bool Equals(object obj) Parameters Type Name Description System.Object obj Returns Type Description System.Boolean Overrides System.Object.Equals(System.Object) | Improve this doc View source GetHashCode() Declaration public override int GetHashCode() Returns Type Description System.Int32 Overrides System.Object.GetHashCode() | Improve this doc View source SerializeAsync(Object, MessageHeaderCollection, MessageSerializationContext) Declaration public override ValueTask<Stream> SerializeAsync(object message, MessageHeaderCollection messageHeaders, MessageSerializationContext context) Parameters Type Name Description System.Object message Silverback.Messaging.Messages.MessageHeaderCollection messageHeaders Silverback.Messaging.Serialization.MessageSerializationContext context Returns Type Description System.Threading.Tasks.ValueTask < System.IO.Stream > Overrides NewtonsoftJsonMessageSerializerBase.SerializeAsync(Object, MessageHeaderCollection, MessageSerializationContext) Implements Silverback.Messaging.Serialization.IMessageSerializer System.IEquatable<T>"
  },
  "api/Silverback.Messaging.Serialization.NewtonsoftJsonMessageSerializer-1.html": {
    "href": "api/Silverback.Messaging.Serialization.NewtonsoftJsonMessageSerializer-1.html",
    "title": "Class NewtonsoftJsonMessageSerializer<TMessage> | Silverback",
    "keywords": "Class NewtonsoftJsonMessageSerializer<TMessage> Serializes and deserializes the messages of type TMessage in JSON format. Inheritance System.Object NewtonsoftJsonMessageSerializerBase NewtonsoftJsonMessageSerializer<TMessage> Implements Silverback.Messaging.Serialization.IMessageSerializer System.IEquatable < NewtonsoftJsonMessageSerializer <TMessage>> Inherited Members NewtonsoftJsonMessageSerializerBase.Encoding NewtonsoftJsonMessageSerializerBase.Settings NewtonsoftJsonMessageSerializerBase.SystemEncoding System.Object.Equals(System.Object, System.Object) System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Silverback.Messaging.Serialization Assembly : Silverback.Integration.Newtonsoft.dll Syntax public sealed class NewtonsoftJsonMessageSerializer<TMessage> : NewtonsoftJsonMessageSerializerBase, IMessageSerializer, IEquatable<NewtonsoftJsonMessageSerializer<TMessage>> Type Parameters Name Description TMessage The type of the messages to be serialized and/or deserialized. Properties | Improve this doc View source RequireHeaders Declaration public override bool RequireHeaders { get; } Property Value Type Description System.Boolean Overrides NewtonsoftJsonMessageSerializerBase.RequireHeaders Methods | Improve this doc View source DeserializeAsync(Stream, MessageHeaderCollection, MessageSerializationContext) Declaration public override async ValueTask<(object Message, Type MessageType)> DeserializeAsync(Stream messageStream, MessageHeaderCollection messageHeaders, MessageSerializationContext context) Parameters Type Name Description System.IO.Stream messageStream Silverback.Messaging.Messages.MessageHeaderCollection messageHeaders Silverback.Messaging.Serialization.MessageSerializationContext context Returns Type Description System.Threading.Tasks.ValueTask < System.ValueTuple < System.Object , System.Type >> Overrides NewtonsoftJsonMessageSerializerBase.DeserializeAsync(Stream, MessageHeaderCollection, MessageSerializationContext) | Improve this doc View source Equals(NewtonsoftJsonMessageSerializer<TMessage>) Declaration public bool Equals(NewtonsoftJsonMessageSerializer<TMessage> other) Parameters Type Name Description NewtonsoftJsonMessageSerializer <TMessage> other Returns Type Description System.Boolean | Improve this doc View source Equals(Object) Declaration public override bool Equals(object obj) Parameters Type Name Description System.Object obj Returns Type Description System.Boolean Overrides System.Object.Equals(System.Object) | Improve this doc View source GetHashCode() Declaration public override int GetHashCode() Returns Type Description System.Int32 Overrides System.Object.GetHashCode() | Improve this doc View source SerializeAsync(Object, MessageHeaderCollection, MessageSerializationContext) Declaration public override ValueTask<Stream> SerializeAsync(object message, MessageHeaderCollection messageHeaders, MessageSerializationContext context) Parameters Type Name Description System.Object message Silverback.Messaging.Messages.MessageHeaderCollection messageHeaders Silverback.Messaging.Serialization.MessageSerializationContext context Returns Type Description System.Threading.Tasks.ValueTask < System.IO.Stream > Overrides NewtonsoftJsonMessageSerializerBase.SerializeAsync(Object, MessageHeaderCollection, MessageSerializationContext) Implements Silverback.Messaging.Serialization.IMessageSerializer System.IEquatable<T>"
  },
  "api/Silverback.Messaging.Serialization.NewtonsoftJsonMessageSerializerBase.html": {
    "href": "api/Silverback.Messaging.Serialization.NewtonsoftJsonMessageSerializerBase.html",
    "title": "Class NewtonsoftJsonMessageSerializerBase | Silverback",
    "keywords": "Class NewtonsoftJsonMessageSerializerBase The base class for NewtonsoftJsonMessageSerializer and NewtonsoftJsonMessageSerializer<TMessage> . Inheritance System.Object NewtonsoftJsonMessageSerializerBase NewtonsoftJsonMessageSerializer NewtonsoftJsonMessageSerializer <TMessage> Implements Silverback.Messaging.Serialization.IMessageSerializer Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Silverback.Messaging.Serialization Assembly : Silverback.Integration.Newtonsoft.dll Syntax public abstract class NewtonsoftJsonMessageSerializerBase : IMessageSerializer Properties | Improve this doc View source Encoding Gets or sets the message encoding. The default is UTF8. Declaration public MessageEncoding Encoding { get; set; } Property Value Type Description Silverback.Messaging.Serialization.MessageEncoding | Improve this doc View source RequireHeaders Declaration public abstract bool RequireHeaders { get; } Property Value Type Description System.Boolean | Improve this doc View source Settings Gets or sets the settings to be applied to the Json.NET serializer. Declaration public JsonSerializerSettings Settings { get; set; } Property Value Type Description Newtonsoft.Json.JsonSerializerSettings | Improve this doc View source SystemEncoding Gets the System.Text.Encoding corresponding to the Silverback.Messaging.Serialization.MessageEncoding . Declaration protected Encoding SystemEncoding { get; } Property Value Type Description System.Text.Encoding A System.Text.Encoding that matches the current Silverback.Messaging.Serialization.MessageEncoding . Methods | Improve this doc View source DeserializeAsync(Stream, MessageHeaderCollection, MessageSerializationContext) Declaration public abstract ValueTask<(object Message, Type MessageType)> DeserializeAsync(Stream messageStream, MessageHeaderCollection messageHeaders, MessageSerializationContext context) Parameters Type Name Description System.IO.Stream messageStream Silverback.Messaging.Messages.MessageHeaderCollection messageHeaders Silverback.Messaging.Serialization.MessageSerializationContext context Returns Type Description System.Threading.Tasks.ValueTask < System.ValueTuple < System.Object , System.Type >> | Improve this doc View source SerializeAsync(Object, MessageHeaderCollection, MessageSerializationContext) Declaration public abstract ValueTask<Stream> SerializeAsync(object message, MessageHeaderCollection messageHeaders, MessageSerializationContext context) Parameters Type Name Description System.Object message Silverback.Messaging.Messages.MessageHeaderCollection messageHeaders Silverback.Messaging.Serialization.MessageSerializationContext context Returns Type Description System.Threading.Tasks.ValueTask < System.IO.Stream > Implements Silverback.Messaging.Serialization.IMessageSerializer"
  },
  "api/Silverback.Messaging.Subscribers.ArgumentResolvers.DefaultAdditionalArgumentResolver.html": {
    "href": "api/Silverback.Messaging.Subscribers.ArgumentResolvers.DefaultAdditionalArgumentResolver.html",
    "title": "Class DefaultAdditionalArgumentResolver | Silverback",
    "keywords": "Class DefaultAdditionalArgumentResolver Simply tries to resolve the additional parameters of the subscribed methods using the System.IServiceProvider . Inheritance System.Object DefaultAdditionalArgumentResolver Implements IAdditionalArgumentResolver IArgumentResolver Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Silverback.Messaging.Subscribers.ArgumentResolvers Assembly : Silverback.Core.dll Syntax public class DefaultAdditionalArgumentResolver : IAdditionalArgumentResolver, IArgumentResolver Methods | Improve this doc View source CanResolve(Type) Declaration public bool CanResolve(Type parameterType) Parameters Type Name Description System.Type parameterType Returns Type Description System.Boolean | Improve this doc View source GetValue(Type, IServiceProvider) Declaration public object GetValue(Type parameterType, IServiceProvider serviceProvider) Parameters Type Name Description System.Type parameterType System.IServiceProvider serviceProvider Returns Type Description System.Object Implements IAdditionalArgumentResolver IArgumentResolver"
  },
  "api/Silverback.Messaging.Subscribers.ArgumentResolvers.html": {
    "href": "api/Silverback.Messaging.Subscribers.ArgumentResolvers.html",
    "title": "Namespace Silverback.Messaging.Subscribers.ArgumentResolvers | Silverback",
    "keywords": "Namespace Silverback.Messaging.Subscribers.ArgumentResolvers Classes DefaultAdditionalArgumentResolver Simply tries to resolve the additional parameters of the subscribed methods using the System.IServiceProvider . SingleMessageArgumentResolver Resolves the parameters declared with a type that is compatible with the type of the message being published. StreamEnumerableMessageArgumentResolver Resolves the parameters declared as IMessageStreamEnumerable<TMessage> where TMessage is compatible with the type of the message being published. Interfaces IAdditionalArgumentResolver These resolvers are used to try to get a value for the additional parameters (other than the message itself) of the subscribed methods. IArgumentResolver Used as base for the more specialized IMessageArgumentResolver and IAdditionalArgumentResolver . ILazyArgumentValue Represent a value for an argument that will be available in the future. IMessageArgumentResolver These resolvers are used to cast or transform the message parameter to be forwarded to the subscribed method. ISingleMessageArgumentResolver These resolvers are used to handle the single message parameter (the pure message, not wrapped in any enumerable or collection). IStreamEnumerableMessageArgumentResolver These resolvers are used to handle the message streams such as IMessageStreamEnumerable<TMessage> . The streams are basically handled as a single message by the publisher. The difference is that it is guaranteed that the subscribers are invoked from another thread, when published via PublishAsync(Object) / PublishAsync<TResult>(Object) . This is done to avoid blocking the original thread waiting for the stream to complete."
  },
  "api/Silverback.Messaging.Subscribers.ArgumentResolvers.IAdditionalArgumentResolver.html": {
    "href": "api/Silverback.Messaging.Subscribers.ArgumentResolvers.IAdditionalArgumentResolver.html",
    "title": "Interface IAdditionalArgumentResolver | Silverback",
    "keywords": "Interface IAdditionalArgumentResolver These resolvers are used to try to get a value for the additional parameters (other than the message itself) of the subscribed methods. Inherited Members IArgumentResolver.CanResolve(Type) Namespace : Silverback.Messaging.Subscribers.ArgumentResolvers Assembly : Silverback.Core.dll Syntax public interface IAdditionalArgumentResolver : IArgumentResolver Methods | Improve this doc View source GetValue(Type, IServiceProvider) Returns a suitable value for the parameter of the specified type. Declaration object GetValue(Type parameterType, IServiceProvider serviceProvider) Parameters Type Name Description System.Type parameterType The type of the parameter to be resolved. System.IServiceProvider serviceProvider The System.IServiceProvider to be used to resolve the necessary services. Returns Type Description System.Object A value to be forwarded to the subscribed method."
  },
  "api/Silverback.Messaging.Subscribers.ArgumentResolvers.IArgumentResolver.html": {
    "href": "api/Silverback.Messaging.Subscribers.ArgumentResolvers.IArgumentResolver.html",
    "title": "Interface IArgumentResolver | Silverback",
    "keywords": "Interface IArgumentResolver Used as base for the more specialized IMessageArgumentResolver and IAdditionalArgumentResolver . Namespace : Silverback.Messaging.Subscribers.ArgumentResolvers Assembly : Silverback.Core.dll Syntax public interface IArgumentResolver Methods | Improve this doc View source CanResolve(Type) Returns a boolean value indicating whether this resolver instance can handle the parameter of the specified type. Declaration bool CanResolve(Type parameterType) Parameters Type Name Description System.Type parameterType The type of the parameter to be resolved. Returns Type Description System.Boolean A boolean value indicating whether the specified parameter type can be handled."
  },
  "api/Silverback.Messaging.Subscribers.ArgumentResolvers.ILazyArgumentValue.html": {
    "href": "api/Silverback.Messaging.Subscribers.ArgumentResolvers.ILazyArgumentValue.html",
    "title": "Interface ILazyArgumentValue | Silverback",
    "keywords": "Interface ILazyArgumentValue Represent a value for an argument that will be available in the future. Namespace : Silverback.Messaging.Subscribers.ArgumentResolvers Assembly : Silverback.Core.dll Syntax public interface ILazyArgumentValue Properties | Improve this doc View source Value Gets the argument value, as soon as it is available. Declaration object Value { get; } Property Value Type Description System.Object Methods | Improve this doc View source WaitUntilCreatedAsync() Gets an awaitable System.Threading.Tasks.Task that completes when the argument value is available. Declaration Task WaitUntilCreatedAsync() Returns Type Description System.Threading.Tasks.Task A System.Threading.Tasks.Task representing the asynchronous operation."
  },
  "api/Silverback.Messaging.Subscribers.ArgumentResolvers.IMessageArgumentResolver.html": {
    "href": "api/Silverback.Messaging.Subscribers.ArgumentResolvers.IMessageArgumentResolver.html",
    "title": "Interface IMessageArgumentResolver | Silverback",
    "keywords": "Interface IMessageArgumentResolver These resolvers are used to cast or transform the message parameter to be forwarded to the subscribed method. Inherited Members IArgumentResolver.CanResolve(Type) Namespace : Silverback.Messaging.Subscribers.ArgumentResolvers Assembly : Silverback.Core.dll Syntax public interface IMessageArgumentResolver : IArgumentResolver Methods | Improve this doc View source GetMessageType(Type) Returns the actual message type in the specified parameter type (e.g. TMessage for a parameter declared as IEnumerable<TMessage> . Declaration Type GetMessageType(Type parameterType) Parameters Type Name Description System.Type parameterType The type of the parameter to be resolved. Returns Type Description System.Type The actual message type."
  },
  "api/Silverback.Messaging.Subscribers.ArgumentResolvers.ISingleMessageArgumentResolver.html": {
    "href": "api/Silverback.Messaging.Subscribers.ArgumentResolvers.ISingleMessageArgumentResolver.html",
    "title": "Interface ISingleMessageArgumentResolver | Silverback",
    "keywords": "Interface ISingleMessageArgumentResolver These resolvers are used to handle the single message parameter (the pure message, not wrapped in any enumerable or collection). Inherited Members IMessageArgumentResolver.GetMessageType(Type) IArgumentResolver.CanResolve(Type) Namespace : Silverback.Messaging.Subscribers.ArgumentResolvers Assembly : Silverback.Core.dll Syntax public interface ISingleMessageArgumentResolver : IMessageArgumentResolver, IArgumentResolver Methods | Improve this doc View source GetValue(Object) Returns the message value in a shape that is compatible with the subscribed method. Declaration object GetValue(object message) Parameters Type Name Description System.Object message The message being published. Returns Type Description System.Object The actual value to be forwarded to the subscribed method."
  },
  "api/Silverback.Messaging.Subscribers.ArgumentResolvers.IStreamEnumerableMessageArgumentResolver.html": {
    "href": "api/Silverback.Messaging.Subscribers.ArgumentResolvers.IStreamEnumerableMessageArgumentResolver.html",
    "title": "Interface IStreamEnumerableMessageArgumentResolver | Silverback",
    "keywords": "Interface IStreamEnumerableMessageArgumentResolver These resolvers are used to handle the message streams such as IMessageStreamEnumerable<TMessage> . The streams are basically handled as a single message by the publisher. The difference is that it is guaranteed that the subscribers are invoked from another thread, when published via PublishAsync(Object) / PublishAsync<TResult>(Object) . This is done to avoid blocking the original thread waiting for the stream to complete. Inherited Members IMessageArgumentResolver.GetMessageType(Type) IArgumentResolver.CanResolve(Type) Namespace : Silverback.Messaging.Subscribers.ArgumentResolvers Assembly : Silverback.Core.dll Syntax public interface IStreamEnumerableMessageArgumentResolver : IMessageArgumentResolver, IArgumentResolver Methods | Improve this doc View source GetValue(IMessageStreamProvider, Type, IReadOnlyCollection<IMessageFilter>) Returns the messages stream in a shape that is compatible with the subscribed method. Declaration ILazyArgumentValue GetValue(IMessageStreamProvider streamProvider, Type targetMessageType, IReadOnlyCollection<IMessageFilter> filters = null) Parameters Type Name Description IMessageStreamProvider streamProvider The IMessageStreamProvider being published. System.Type targetMessageType The actual message type being declared by the subscribed method (e.g. TMessage for an IMessageStreamEnumerable<TMessage> ). System.Collections.Generic.IReadOnlyCollection < IMessageFilter > filters The filters to be applied. Returns Type Description ILazyArgumentValue The actual value to be forwarded to the subscribed method."
  },
  "api/Silverback.Messaging.Subscribers.ArgumentResolvers.SingleMessageArgumentResolver.html": {
    "href": "api/Silverback.Messaging.Subscribers.ArgumentResolvers.SingleMessageArgumentResolver.html",
    "title": "Class SingleMessageArgumentResolver | Silverback",
    "keywords": "Class SingleMessageArgumentResolver Resolves the parameters declared with a type that is compatible with the type of the message being published. Inheritance System.Object SingleMessageArgumentResolver Implements ISingleMessageArgumentResolver IMessageArgumentResolver IArgumentResolver Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Silverback.Messaging.Subscribers.ArgumentResolvers Assembly : Silverback.Core.dll Syntax public class SingleMessageArgumentResolver : ISingleMessageArgumentResolver, IMessageArgumentResolver, IArgumentResolver Methods | Improve this doc View source CanResolve(Type) Declaration public bool CanResolve(Type parameterType) Parameters Type Name Description System.Type parameterType Returns Type Description System.Boolean | Improve this doc View source GetMessageType(Type) Declaration public Type GetMessageType(Type parameterType) Parameters Type Name Description System.Type parameterType Returns Type Description System.Type | Improve this doc View source GetValue(Object) Declaration public object GetValue(object message) Parameters Type Name Description System.Object message Returns Type Description System.Object Implements ISingleMessageArgumentResolver IMessageArgumentResolver IArgumentResolver"
  },
  "api/Silverback.Messaging.Subscribers.ArgumentResolvers.StreamEnumerableMessageArgumentResolver.html": {
    "href": "api/Silverback.Messaging.Subscribers.ArgumentResolvers.StreamEnumerableMessageArgumentResolver.html",
    "title": "Class StreamEnumerableMessageArgumentResolver | Silverback",
    "keywords": "Class StreamEnumerableMessageArgumentResolver Resolves the parameters declared as IMessageStreamEnumerable<TMessage> where TMessage is compatible with the type of the message being published. Inheritance System.Object StreamEnumerableMessageArgumentResolver Implements IStreamEnumerableMessageArgumentResolver IMessageArgumentResolver IArgumentResolver Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Silverback.Messaging.Subscribers.ArgumentResolvers Assembly : Silverback.Core.dll Syntax public class StreamEnumerableMessageArgumentResolver : IStreamEnumerableMessageArgumentResolver, IMessageArgumentResolver, IArgumentResolver Methods | Improve this doc View source CanResolve(Type) Declaration public bool CanResolve(Type parameterType) Parameters Type Name Description System.Type parameterType Returns Type Description System.Boolean | Improve this doc View source GetMessageType(Type) Declaration public Type GetMessageType(Type parameterType) Parameters Type Name Description System.Type parameterType Returns Type Description System.Type | Improve this doc View source GetValue(IMessageStreamProvider, Type, IReadOnlyCollection<IMessageFilter>) Declaration public ILazyArgumentValue GetValue(IMessageStreamProvider streamProvider, Type targetMessageType, IReadOnlyCollection<IMessageFilter> filters = null) Parameters Type Name Description IMessageStreamProvider streamProvider System.Type targetMessageType System.Collections.Generic.IReadOnlyCollection < IMessageFilter > filters Returns Type Description ILazyArgumentValue Implements IStreamEnumerableMessageArgumentResolver IMessageArgumentResolver IArgumentResolver"
  },
  "api/Silverback.Messaging.Subscribers.html": {
    "href": "api/Silverback.Messaging.Subscribers.html",
    "title": "Namespace Silverback.Messaging.Subscribers | Silverback",
    "keywords": "Namespace Silverback.Messaging.Subscribers Classes MessageFilterAttribute Can be placed on a subscribed method to filter the messages to be processed. SubscribeAttribute Used to identify the methods that have to be subscribed to the messages stream. The first parameter of the subscriber method always correspond to the message and must be declared with a type compatible with the message to be received (the message type, a base type or an implemented interface) or a collection of items of that type. The methods can be either synchronous or asynchronous (returning a System.Threading.Tasks.Task ) and don't need to be publicly visible. SubscribedMethod A subscribed method that can process certain messages. SubscribedMethodInvocationException The exception that is thrown when a subscribed method cannot be invoked. This usually happens because no value can be resolved for one or more arguments. SubscribedMethodsLoaderService Resolves all the subscribers and build the types cache to boost the first publish performance. Interfaces IMessageFilter Filters the messages to be processed. ISubscribedMethodsCache Stores the map of the subscribed methods for each message type."
  },
  "api/Silverback.Messaging.Subscribers.IMessageFilter.html": {
    "href": "api/Silverback.Messaging.Subscribers.IMessageFilter.html",
    "title": "Interface IMessageFilter | Silverback",
    "keywords": "Interface IMessageFilter Filters the messages to be processed. Namespace : Silverback.Messaging.Subscribers Assembly : Silverback.Core.dll Syntax public interface IMessageFilter Methods | Improve this doc View source MustProcess(Object) Returns a boolean value indicating whether the specified message must be processed by the subscribed method decorated with this attribute. Declaration bool MustProcess(object message) Parameters Type Name Description System.Object message The message to be checked. Returns Type Description System.Boolean A boolean value indicating whether the message must be processed by the subscribed method."
  },
  "api/Silverback.Messaging.Subscribers.ISubscribedMethodsCache.html": {
    "href": "api/Silverback.Messaging.Subscribers.ISubscribedMethodsCache.html",
    "title": "Interface ISubscribedMethodsCache | Silverback",
    "keywords": "Interface ISubscribedMethodsCache Stores the map of the subscribed methods for each message type. Namespace : Silverback.Messaging.Subscribers Assembly : Silverback.Core.dll Syntax public interface ISubscribedMethodsCache Properties | Improve this doc View source HasAnyMessageStreamSubscriber Gets a value indicating whether there is at least one subscriber that would potentially receive an IMessageStreamEnumerable<TMessage> . Declaration bool HasAnyMessageStreamSubscriber { get; } Property Value Type Description System.Boolean Methods | Improve this doc View source IsSubscribed(Object) Checks whether the specified message would be handled by any of the registered subscribers. Declaration bool IsSubscribed(object message) Parameters Type Name Description System.Object message The message that could be published. Returns Type Description System.Boolean true if at least a subscriber would be invoked for the specified message, otherwise false ."
  },
  "api/Silverback.Messaging.Subscribers.MessageFilterAttribute.html": {
    "href": "api/Silverback.Messaging.Subscribers.MessageFilterAttribute.html",
    "title": "Class MessageFilterAttribute | Silverback",
    "keywords": "Class MessageFilterAttribute Can be placed on a subscribed method to filter the messages to be processed. Inheritance System.Object System.Attribute MessageFilterAttribute Implements IMessageFilter Inherited Members System.Attribute.Equals(System.Object) System.Attribute.GetCustomAttribute(System.Reflection.Assembly, System.Type) System.Attribute.GetCustomAttribute(System.Reflection.Assembly, System.Type, System.Boolean) System.Attribute.GetCustomAttribute(System.Reflection.MemberInfo, System.Type) System.Attribute.GetCustomAttribute(System.Reflection.MemberInfo, System.Type, System.Boolean) System.Attribute.GetCustomAttribute(System.Reflection.Module, System.Type) System.Attribute.GetCustomAttribute(System.Reflection.Module, System.Type, System.Boolean) System.Attribute.GetCustomAttribute(System.Reflection.ParameterInfo, System.Type) System.Attribute.GetCustomAttribute(System.Reflection.ParameterInfo, System.Type, System.Boolean) System.Attribute.GetCustomAttributes(System.Reflection.Assembly) System.Attribute.GetCustomAttributes(System.Reflection.Assembly, System.Boolean) System.Attribute.GetCustomAttributes(System.Reflection.Assembly, System.Type) System.Attribute.GetCustomAttributes(System.Reflection.Assembly, System.Type, System.Boolean) System.Attribute.GetCustomAttributes(System.Reflection.MemberInfo) System.Attribute.GetCustomAttributes(System.Reflection.MemberInfo, System.Boolean) System.Attribute.GetCustomAttributes(System.Reflection.MemberInfo, System.Type) System.Attribute.GetCustomAttributes(System.Reflection.MemberInfo, System.Type, System.Boolean) System.Attribute.GetCustomAttributes(System.Reflection.Module) System.Attribute.GetCustomAttributes(System.Reflection.Module, System.Boolean) System.Attribute.GetCustomAttributes(System.Reflection.Module, System.Type) System.Attribute.GetCustomAttributes(System.Reflection.Module, System.Type, System.Boolean) System.Attribute.GetCustomAttributes(System.Reflection.ParameterInfo) System.Attribute.GetCustomAttributes(System.Reflection.ParameterInfo, System.Boolean) System.Attribute.GetCustomAttributes(System.Reflection.ParameterInfo, System.Type) System.Attribute.GetCustomAttributes(System.Reflection.ParameterInfo, System.Type, System.Boolean) System.Attribute.GetHashCode() System.Attribute.IsDefaultAttribute() System.Attribute.IsDefined(System.Reflection.Assembly, System.Type) System.Attribute.IsDefined(System.Reflection.Assembly, System.Type, System.Boolean) System.Attribute.IsDefined(System.Reflection.MemberInfo, System.Type) System.Attribute.IsDefined(System.Reflection.MemberInfo, System.Type, System.Boolean) System.Attribute.IsDefined(System.Reflection.Module, System.Type) System.Attribute.IsDefined(System.Reflection.Module, System.Type, System.Boolean) System.Attribute.IsDefined(System.Reflection.ParameterInfo, System.Type) System.Attribute.IsDefined(System.Reflection.ParameterInfo, System.Type, System.Boolean) System.Attribute.Match(System.Object) System.Attribute.TypeId System.Object.Equals(System.Object, System.Object) System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Silverback.Messaging.Subscribers Assembly : Silverback.Core.dll Syntax [AttributeUsage(AttributeTargets.Method, AllowMultiple = true, Inherited = false)] public abstract class MessageFilterAttribute : Attribute, IMessageFilter Methods | Improve this doc View source MustProcess(Object) Declaration public abstract bool MustProcess(object message) Parameters Type Name Description System.Object message Returns Type Description System.Boolean Implements IMessageFilter"
  },
  "api/Silverback.Messaging.Subscribers.ReturnValueHandlers.AsyncEnumerableMessagesReturnValueHandler.html": {
    "href": "api/Silverback.Messaging.Subscribers.ReturnValueHandlers.AsyncEnumerableMessagesReturnValueHandler.html",
    "title": "Class AsyncEnumerableMessagesReturnValueHandler | Silverback",
    "keywords": "Class AsyncEnumerableMessagesReturnValueHandler Handles the returned System.Collections.Generic.IAsyncEnumerable<T> republishing all the messages. Inheritance System.Object AsyncEnumerableMessagesReturnValueHandler Implements IReturnValueHandler Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Silverback.Messaging.Subscribers.ReturnValueHandlers Assembly : Silverback.Core.dll Syntax public class AsyncEnumerableMessagesReturnValueHandler : IReturnValueHandler Constructors | Improve this doc View source AsyncEnumerableMessagesReturnValueHandler(IPublisher, IBusOptions) Initializes a new instance of the AsyncEnumerableMessagesReturnValueHandler class. Declaration public AsyncEnumerableMessagesReturnValueHandler(IPublisher publisher, IBusOptions busOptions) Parameters Type Name Description IPublisher publisher The IPublisher to be used to publish the messages. IBusOptions busOptions The IBusOptions that specify which message types have to be handled. Methods | Improve this doc View source CanHandle(Object) Declaration public bool CanHandle(object returnValue) Parameters Type Name Description System.Object returnValue Returns Type Description System.Boolean | Improve this doc View source Handle(Object) Declaration public void Handle(object returnValue) Parameters Type Name Description System.Object returnValue | Improve this doc View source HandleAsync(Object) Declaration public Task HandleAsync(object returnValue) Parameters Type Name Description System.Object returnValue Returns Type Description System.Threading.Tasks.Task Implements IReturnValueHandler"
  },
  "api/Silverback.Messaging.Subscribers.ReturnValueHandlers.EnumerableMessagesReturnValueHandler.html": {
    "href": "api/Silverback.Messaging.Subscribers.ReturnValueHandlers.EnumerableMessagesReturnValueHandler.html",
    "title": "Class EnumerableMessagesReturnValueHandler | Silverback",
    "keywords": "Class EnumerableMessagesReturnValueHandler Handles the returned System.Collections.Generic.IEnumerable<T> republishing all the messages. Inheritance System.Object EnumerableMessagesReturnValueHandler Implements IReturnValueHandler Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Silverback.Messaging.Subscribers.ReturnValueHandlers Assembly : Silverback.Core.dll Syntax public class EnumerableMessagesReturnValueHandler : IReturnValueHandler Constructors | Improve this doc View source EnumerableMessagesReturnValueHandler(IPublisher, IBusOptions) Initializes a new instance of the EnumerableMessagesReturnValueHandler class. Declaration public EnumerableMessagesReturnValueHandler(IPublisher publisher, IBusOptions busOptions) Parameters Type Name Description IPublisher publisher The IPublisher to be used to publish the messages. IBusOptions busOptions The IBusOptions that specify which message types have to be handled. Methods | Improve this doc View source CanHandle(Object) Declaration public bool CanHandle(object returnValue) Parameters Type Name Description System.Object returnValue Returns Type Description System.Boolean | Improve this doc View source Handle(Object) Declaration public void Handle(object returnValue) Parameters Type Name Description System.Object returnValue | Improve this doc View source HandleAsync(Object) Declaration public Task HandleAsync(object returnValue) Parameters Type Name Description System.Object returnValue Returns Type Description System.Threading.Tasks.Task Implements IReturnValueHandler"
  },
  "api/Silverback.Messaging.Subscribers.ReturnValueHandlers.html": {
    "href": "api/Silverback.Messaging.Subscribers.ReturnValueHandlers.html",
    "title": "Namespace Silverback.Messaging.Subscribers.ReturnValueHandlers | Silverback",
    "keywords": "Namespace Silverback.Messaging.Subscribers.ReturnValueHandlers Classes AsyncEnumerableMessagesReturnValueHandler Handles the returned System.Collections.Generic.IAsyncEnumerable<T> republishing all the messages. EnumerableMessagesReturnValueHandler Handles the returned System.Collections.Generic.IEnumerable<T> republishing all the messages. ReadOnlyCollectionMessagesReturnValueHandler Handles the returned System.Collections.Generic.IReadOnlyCollection<T> republishing all the messages. SingleMessageReturnValueHandler Handles the returned message republishing it. Interfaces IReturnValueHandler These types are used to handle the subscribed methods return values (e.g. to republish the returned messages)."
  },
  "api/Silverback.Messaging.Subscribers.ReturnValueHandlers.IReturnValueHandler.html": {
    "href": "api/Silverback.Messaging.Subscribers.ReturnValueHandlers.IReturnValueHandler.html",
    "title": "Interface IReturnValueHandler | Silverback",
    "keywords": "Interface IReturnValueHandler These types are used to handle the subscribed methods return values (e.g. to republish the returned messages). Namespace : Silverback.Messaging.Subscribers.ReturnValueHandlers Assembly : Silverback.Core.dll Syntax public interface IReturnValueHandler Methods | Improve this doc View source CanHandle(Object) Returns a boolean value indicating whether this handler can handle the specified value. Declaration bool CanHandle(object returnValue) Parameters Type Name Description System.Object returnValue The value to be handled. Returns Type Description System.Boolean A boolean value indicating whether the value can be handled. | Improve this doc View source Handle(Object) Handles the specified return value. Declaration void Handle(object returnValue) Parameters Type Name Description System.Object returnValue The value to be handled. | Improve this doc View source HandleAsync(Object) Handles the specified return value. Declaration Task HandleAsync(object returnValue) Parameters Type Name Description System.Object returnValue The value to be handled. Returns Type Description System.Threading.Tasks.Task A System.Threading.Tasks.Task representing the asynchronous operation."
  },
  "api/Silverback.Messaging.Subscribers.ReturnValueHandlers.ReadOnlyCollectionMessagesReturnValueHandler.html": {
    "href": "api/Silverback.Messaging.Subscribers.ReturnValueHandlers.ReadOnlyCollectionMessagesReturnValueHandler.html",
    "title": "Class ReadOnlyCollectionMessagesReturnValueHandler | Silverback",
    "keywords": "Class ReadOnlyCollectionMessagesReturnValueHandler Handles the returned System.Collections.Generic.IReadOnlyCollection<T> republishing all the messages. Inheritance System.Object ReadOnlyCollectionMessagesReturnValueHandler Implements IReturnValueHandler Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Silverback.Messaging.Subscribers.ReturnValueHandlers Assembly : Silverback.Core.dll Syntax public class ReadOnlyCollectionMessagesReturnValueHandler : IReturnValueHandler Constructors | Improve this doc View source ReadOnlyCollectionMessagesReturnValueHandler(IPublisher, IBusOptions) Initializes a new instance of the ReadOnlyCollectionMessagesReturnValueHandler class. Declaration public ReadOnlyCollectionMessagesReturnValueHandler(IPublisher publisher, IBusOptions busOptions) Parameters Type Name Description IPublisher publisher The IPublisher to be used to publish the messages. IBusOptions busOptions The IBusOptions that specify which message types have to be handled. Methods | Improve this doc View source CanHandle(Object) Declaration public bool CanHandle(object returnValue) Parameters Type Name Description System.Object returnValue Returns Type Description System.Boolean | Improve this doc View source Handle(Object) Declaration public void Handle(object returnValue) Parameters Type Name Description System.Object returnValue | Improve this doc View source HandleAsync(Object) Declaration public Task HandleAsync(object returnValue) Parameters Type Name Description System.Object returnValue Returns Type Description System.Threading.Tasks.Task Implements IReturnValueHandler"
  },
  "api/Silverback.Messaging.Subscribers.ReturnValueHandlers.SingleMessageReturnValueHandler.html": {
    "href": "api/Silverback.Messaging.Subscribers.ReturnValueHandlers.SingleMessageReturnValueHandler.html",
    "title": "Class SingleMessageReturnValueHandler | Silverback",
    "keywords": "Class SingleMessageReturnValueHandler Handles the returned message republishing it. Inheritance System.Object SingleMessageReturnValueHandler Implements IReturnValueHandler Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Silverback.Messaging.Subscribers.ReturnValueHandlers Assembly : Silverback.Core.dll Syntax public class SingleMessageReturnValueHandler : IReturnValueHandler Constructors | Improve this doc View source SingleMessageReturnValueHandler(IPublisher, IBusOptions) Initializes a new instance of the SingleMessageReturnValueHandler class. Declaration public SingleMessageReturnValueHandler(IPublisher publisher, IBusOptions busOptions) Parameters Type Name Description IPublisher publisher The IPublisher to be used to publish the messages. IBusOptions busOptions The IBusOptions that specify which message types have to be handled. Methods | Improve this doc View source CanHandle(Object) Declaration public bool CanHandle(object returnValue) Parameters Type Name Description System.Object returnValue Returns Type Description System.Boolean | Improve this doc View source Handle(Object) Declaration public void Handle(object returnValue) Parameters Type Name Description System.Object returnValue | Improve this doc View source HandleAsync(Object) Declaration public Task HandleAsync(object returnValue) Parameters Type Name Description System.Object returnValue Returns Type Description System.Threading.Tasks.Task Implements IReturnValueHandler"
  },
  "api/Silverback.Messaging.Subscribers.SubscribeAttribute.html": {
    "href": "api/Silverback.Messaging.Subscribers.SubscribeAttribute.html",
    "title": "Class SubscribeAttribute | Silverback",
    "keywords": "Class SubscribeAttribute Used to identify the methods that have to be subscribed to the messages stream. The first parameter of the subscriber method always correspond to the message and must be declared with a type compatible with the message to be received (the message type, a base type or an implemented interface) or a collection of items of that type. The methods can be either synchronous or asynchronous (returning a System.Threading.Tasks.Task ) and don't need to be publicly visible. Inheritance System.Object System.Attribute SubscribeAttribute Inherited Members System.Attribute.Equals(System.Object) System.Attribute.GetCustomAttribute(System.Reflection.Assembly, System.Type) System.Attribute.GetCustomAttribute(System.Reflection.Assembly, System.Type, System.Boolean) System.Attribute.GetCustomAttribute(System.Reflection.MemberInfo, System.Type) System.Attribute.GetCustomAttribute(System.Reflection.MemberInfo, System.Type, System.Boolean) System.Attribute.GetCustomAttribute(System.Reflection.Module, System.Type) System.Attribute.GetCustomAttribute(System.Reflection.Module, System.Type, System.Boolean) System.Attribute.GetCustomAttribute(System.Reflection.ParameterInfo, System.Type) System.Attribute.GetCustomAttribute(System.Reflection.ParameterInfo, System.Type, System.Boolean) System.Attribute.GetCustomAttributes(System.Reflection.Assembly) System.Attribute.GetCustomAttributes(System.Reflection.Assembly, System.Boolean) System.Attribute.GetCustomAttributes(System.Reflection.Assembly, System.Type) System.Attribute.GetCustomAttributes(System.Reflection.Assembly, System.Type, System.Boolean) System.Attribute.GetCustomAttributes(System.Reflection.MemberInfo) System.Attribute.GetCustomAttributes(System.Reflection.MemberInfo, System.Boolean) System.Attribute.GetCustomAttributes(System.Reflection.MemberInfo, System.Type) System.Attribute.GetCustomAttributes(System.Reflection.MemberInfo, System.Type, System.Boolean) System.Attribute.GetCustomAttributes(System.Reflection.Module) System.Attribute.GetCustomAttributes(System.Reflection.Module, System.Boolean) System.Attribute.GetCustomAttributes(System.Reflection.Module, System.Type) System.Attribute.GetCustomAttributes(System.Reflection.Module, System.Type, System.Boolean) System.Attribute.GetCustomAttributes(System.Reflection.ParameterInfo) System.Attribute.GetCustomAttributes(System.Reflection.ParameterInfo, System.Boolean) System.Attribute.GetCustomAttributes(System.Reflection.ParameterInfo, System.Type) System.Attribute.GetCustomAttributes(System.Reflection.ParameterInfo, System.Type, System.Boolean) System.Attribute.GetHashCode() System.Attribute.IsDefaultAttribute() System.Attribute.IsDefined(System.Reflection.Assembly, System.Type) System.Attribute.IsDefined(System.Reflection.Assembly, System.Type, System.Boolean) System.Attribute.IsDefined(System.Reflection.MemberInfo, System.Type) System.Attribute.IsDefined(System.Reflection.MemberInfo, System.Type, System.Boolean) System.Attribute.IsDefined(System.Reflection.Module, System.Type) System.Attribute.IsDefined(System.Reflection.Module, System.Type, System.Boolean) System.Attribute.IsDefined(System.Reflection.ParameterInfo, System.Type) System.Attribute.IsDefined(System.Reflection.ParameterInfo, System.Type, System.Boolean) System.Attribute.Match(System.Object) System.Attribute.TypeId System.Object.Equals(System.Object, System.Object) System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Silverback.Messaging.Subscribers Assembly : Silverback.Core.dll Syntax [AttributeUsage(AttributeTargets.Method)] public sealed class SubscribeAttribute : Attribute Properties | Improve this doc View source Exclusive Gets or sets a value indicating whether the method can be executed concurrently to other methods handling the same message . The default value is true (the method will be executed sequentially to other subscribers). Declaration public bool Exclusive { get; set; } Property Value Type Description System.Boolean"
  },
  "api/Silverback.Messaging.Subscribers.SubscribedMethod.html": {
    "href": "api/Silverback.Messaging.Subscribers.SubscribedMethod.html",
    "title": "Class SubscribedMethod | Silverback",
    "keywords": "Class SubscribedMethod A subscribed method that can process certain messages. Inheritance System.Object SubscribedMethod Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Silverback.Messaging.Subscribers Assembly : Silverback.Core.dll Syntax public class SubscribedMethod Constructors | Improve this doc View source SubscribedMethod(Func<IServiceProvider, Object>, MethodInfo, SubscriptionOptions) Initializes a new instance of the SubscribedMethod class. Declaration public SubscribedMethod(Func<IServiceProvider, object> targetTypeFactory, MethodInfo methodInfo, SubscriptionOptions options) Parameters Type Name Description System.Func < System.IServiceProvider , System.Object > targetTypeFactory The delegate to be used to resolve an instantiate of the type declaring the subscribed method. System.Reflection.MethodInfo methodInfo The MethodInfo related to the subscribed method. SubscriptionOptions options The SubscriptionOptions . Properties | Improve this doc View source AdditionalArgumentsResolvers Gets the list of IAdditionalArgumentResolver to be used to invoke the method. Declaration public IReadOnlyList<IAdditionalArgumentResolver> AdditionalArgumentsResolvers { get; } Property Value Type Description System.Collections.Generic.IReadOnlyList < IAdditionalArgumentResolver > | Improve this doc View source MessageArgumentResolver Gets the IMessageArgumentResolver to be used to invoke the method. Declaration public IMessageArgumentResolver MessageArgumentResolver { get; } Property Value Type Description IMessageArgumentResolver | Improve this doc View source MessageArgumentType Gets the type of the message argument (e.g. MyMessage or IEnumerable<MyMessage> ). Declaration public Type MessageArgumentType { get; } Property Value Type Description System.Type | Improve this doc View source MessageType Gets the type of the message (or envelope) being subscribe. Declaration public Type MessageType { get; } Property Value Type Description System.Type | Improve this doc View source MethodInfo Gets the MethodInfo related to the subscribed method. Declaration public MethodInfo MethodInfo { get; } Property Value Type Description System.Reflection.MethodInfo | Improve this doc View source Options Gets the SubscriptionOptions . Declaration public SubscriptionOptions Options { get; } Property Value Type Description SubscriptionOptions | Improve this doc View source Parameters Gets the System.Reflection.ParameterInfo for each parameter of the subscribed method. Declaration public IReadOnlyList<ParameterInfo> Parameters { get; } Property Value Type Description System.Collections.Generic.IReadOnlyList < System.Reflection.ParameterInfo > Methods | Improve this doc View source ResolveTargetType(IServiceProvider) Resolves an instantiate of the type declaring the subscribed method. Declaration public object ResolveTargetType(IServiceProvider serviceProvider) Parameters Type Name Description System.IServiceProvider serviceProvider The System.IServiceProvider to be used to resolve the type or the necessary services. Returns Type Description System.Object The target type ."
  },
  "api/Silverback.Messaging.Subscribers.SubscribedMethodInvocationException.html": {
    "href": "api/Silverback.Messaging.Subscribers.SubscribedMethodInvocationException.html",
    "title": "Class SubscribedMethodInvocationException | Silverback",
    "keywords": "Class SubscribedMethodInvocationException The exception that is thrown when a subscribed method cannot be invoked. This usually happens because no value can be resolved for one or more arguments. Inheritance System.Object System.Exception SilverbackException SubscribedMethodInvocationException Implements System.Runtime.Serialization.ISerializable Inherited Members System.Exception.GetBaseException() System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo, System.Runtime.Serialization.StreamingContext) System.Exception.GetType() System.Exception.ToString() System.Exception.Data System.Exception.HelpLink System.Exception.HResult System.Exception.InnerException System.Exception.Message System.Exception.Source System.Exception.StackTrace System.Exception.TargetSite System.Exception.SerializeObjectState System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Silverback.Messaging.Subscribers Assembly : Silverback.Core.dll Syntax [Serializable] public class SubscribedMethodInvocationException : SilverbackException, ISerializable Constructors | Improve this doc View source SubscribedMethodInvocationException() Initializes a new instance of the SubscribedMethodInvocationException class. Declaration public SubscribedMethodInvocationException() | Improve this doc View source SubscribedMethodInvocationException(MethodInfo, String) Initializes a new instance of the SubscribedMethodInvocationException class with the specified message and related to the specified MethodInfo . Declaration public SubscribedMethodInvocationException(MethodInfo methodInfo, string message) Parameters Type Name Description System.Reflection.MethodInfo methodInfo The MethodInfo of the related subscribed method. System.String message The exception message. | Improve this doc View source SubscribedMethodInvocationException(SerializationInfo, StreamingContext) Initializes a new instance of the SubscribedMethodInvocationException class with the serialized data. Declaration protected SubscribedMethodInvocationException(SerializationInfo info, StreamingContext context) Parameters Type Name Description System.Runtime.Serialization.SerializationInfo info The System.Runtime.Serialization.SerializationInfo that holds the serialized object data about the exception being thrown. System.Runtime.Serialization.StreamingContext context The System.Runtime.Serialization.StreamingContext that contains contextual information about the source or destination. | Improve this doc View source SubscribedMethodInvocationException(String) Initializes a new instance of the SubscribedMethodInvocationException class with the specified message. Declaration public SubscribedMethodInvocationException(string message) Parameters Type Name Description System.String message The exception message. | Improve this doc View source SubscribedMethodInvocationException(String, Exception) Initializes a new instance of the SubscribedMethodInvocationException class with the specified message and inner exception. Declaration public SubscribedMethodInvocationException(string message, Exception innerException) Parameters Type Name Description System.String message The exception message. System.Exception innerException The inner exception. Properties | Improve this doc View source MethodInfo Gets the MethodInfo representing the subscribed method whose invocation thrown the exception. Declaration public MethodInfo MethodInfo { get; } Property Value Type Description System.Reflection.MethodInfo Implements System.Runtime.Serialization.ISerializable"
  },
  "api/Silverback.Messaging.Subscribers.SubscribedMethodsLoaderService.html": {
    "href": "api/Silverback.Messaging.Subscribers.SubscribedMethodsLoaderService.html",
    "title": "Class SubscribedMethodsLoaderService | Silverback",
    "keywords": "Class SubscribedMethodsLoaderService Resolves all the subscribers and build the types cache to boost the first publish performance. Inheritance System.Object Microsoft.Extensions.Hosting.BackgroundService SubscribedMethodsLoaderService Implements Microsoft.Extensions.Hosting.IHostedService System.IDisposable Inherited Members Microsoft.Extensions.Hosting.BackgroundService.StartAsync(System.Threading.CancellationToken) Microsoft.Extensions.Hosting.BackgroundService.StopAsync(System.Threading.CancellationToken) Microsoft.Extensions.Hosting.BackgroundService.Dispose() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Silverback.Messaging.Subscribers Assembly : Silverback.Core.dll Syntax public class SubscribedMethodsLoaderService : BackgroundService, IHostedService, IDisposable Constructors | Improve this doc View source SubscribedMethodsLoaderService(IServiceScopeFactory) Initializes a new instance of the SubscribedMethodsLoaderService class. Declaration public SubscribedMethodsLoaderService(IServiceScopeFactory serviceScopeFactory) Parameters Type Name Description Microsoft.Extensions.DependencyInjection.IServiceScopeFactory serviceScopeFactory The Microsoft.Extensions.DependencyInjection.IServiceScopeFactory . Methods | Improve this doc View source ExecuteAsync(CancellationToken) Declaration protected override Task ExecuteAsync(CancellationToken stoppingToken) Parameters Type Name Description System.Threading.CancellationToken stoppingToken Returns Type Description System.Threading.Tasks.Task Overrides Microsoft.Extensions.Hosting.BackgroundService.ExecuteAsync(System.Threading.CancellationToken) Implements Microsoft.Extensions.Hosting.IHostedService System.IDisposable"
  },
  "api/Silverback.Messaging.Subscribers.Subscriptions.html": {
    "href": "api/Silverback.Messaging.Subscribers.Subscriptions.html",
    "title": "Namespace Silverback.Messaging.Subscribers.Subscriptions | Silverback",
    "keywords": "Namespace Silverback.Messaging.Subscribers.Subscriptions Classes SubscriptionOptions The subscription options such as filters and parallelism settings. TypeSubscriptionOptions Interfaces ISubscription Represents a subscription configuration. Each subscription can resolve to multiple SubscribedMethod ."
  },
  "api/Silverback.Messaging.Subscribers.Subscriptions.ISubscription.html": {
    "href": "api/Silverback.Messaging.Subscribers.Subscriptions.ISubscription.html",
    "title": "Interface ISubscription | Silverback",
    "keywords": "Interface ISubscription Represents a subscription configuration. Each subscription can resolve to multiple SubscribedMethod . Namespace : Silverback.Messaging.Subscribers.Subscriptions Assembly : Silverback.Core.dll Syntax public interface ISubscription Methods | Improve this doc View source GetSubscribedMethods(IServiceProvider) Gets the SubscribedMethod collection. Declaration IReadOnlyCollection<SubscribedMethod> GetSubscribedMethods(IServiceProvider serviceProvider) Parameters Type Name Description System.IServiceProvider serviceProvider The System.IServiceProvider to be used to resolve the required services. Returns Type Description System.Collections.Generic.IReadOnlyCollection < SubscribedMethod > A collection of SubscribedMethod ."
  },
  "api/Silverback.Messaging.Subscribers.Subscriptions.SubscriptionOptions.html": {
    "href": "api/Silverback.Messaging.Subscribers.Subscriptions.SubscriptionOptions.html",
    "title": "Class SubscriptionOptions | Silverback",
    "keywords": "Class SubscriptionOptions The subscription options such as filters and parallelism settings. Inheritance System.Object SubscriptionOptions TypeSubscriptionOptions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Silverback.Messaging.Subscribers.Subscriptions Assembly : Silverback.Core.dll Syntax public class SubscriptionOptions Properties | Improve this doc View source Exclusive Gets or sets a value indicating whether the method(s) can be executed concurrently to other methods handling the same message. The default value is true (the method(s) will be executed sequentially to other subscribers). Declaration public bool Exclusive { get; set; } Property Value Type Description System.Boolean | Improve this doc View source Filters Gets or sets the filters to be applied. Declaration public IReadOnlyCollection<IMessageFilter> Filters { get; set; } Property Value Type Description System.Collections.Generic.IReadOnlyCollection < IMessageFilter >"
  },
  "api/Silverback.Messaging.Subscribers.Subscriptions.TypeSubscriptionOptions.html": {
    "href": "api/Silverback.Messaging.Subscribers.Subscriptions.TypeSubscriptionOptions.html",
    "title": "Class TypeSubscriptionOptions | Silverback",
    "keywords": "Class TypeSubscriptionOptions Inheritance System.Object SubscriptionOptions TypeSubscriptionOptions Inherited Members SubscriptionOptions.Exclusive SubscriptionOptions.Filters System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Silverback.Messaging.Subscribers.Subscriptions Assembly : Silverback.Core.dll Syntax public class TypeSubscriptionOptions : SubscriptionOptions Properties | Improve this doc View source AutoSubscribeAllPublicMethods Gets or sets a value indicating whether all public methods of the specified type have to be automatically subscribed. When set to false only the methods decorated with the SubscribeAttribute are subscribed. Declaration public bool AutoSubscribeAllPublicMethods { get; set; } Property Value Type Description System.Boolean"
  },
  "api/Silverback.SilverbackException.html": {
    "href": "api/Silverback.SilverbackException.html",
    "title": "Class SilverbackException | Silverback",
    "keywords": "Class SilverbackException The base class for all the custom exceptions thrown by Silverback. Inheritance System.Object System.Exception SilverbackException DatabaseTableNotFoundException EventSourcingException EventStoreException UnhandledMessageException SubscribedMethodInvocationException Implements System.Runtime.Serialization.ISerializable Inherited Members System.Exception.GetBaseException() System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo, System.Runtime.Serialization.StreamingContext) System.Exception.GetType() System.Exception.ToString() System.Exception.Data System.Exception.HelpLink System.Exception.HResult System.Exception.InnerException System.Exception.Message System.Exception.Source System.Exception.StackTrace System.Exception.TargetSite System.Exception.SerializeObjectState System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Silverback Assembly : Silverback.Core.dll Syntax [Serializable] public abstract class SilverbackException : Exception, ISerializable Constructors | Improve this doc View source SilverbackException() Initializes a new instance of the SilverbackException class. Declaration protected SilverbackException() | Improve this doc View source SilverbackException(SerializationInfo, StreamingContext) Initializes a new instance of the SilverbackException class with the serialized data. Declaration protected SilverbackException(SerializationInfo info, StreamingContext context) Parameters Type Name Description System.Runtime.Serialization.SerializationInfo info The System.Runtime.Serialization.SerializationInfo that holds the serialized object data about the exception being thrown. System.Runtime.Serialization.StreamingContext context The System.Runtime.Serialization.StreamingContext that contains contextual information about the source or destination. | Improve this doc View source SilverbackException(String) Initializes a new instance of the SilverbackException class with the specified message. Declaration protected SilverbackException(string message) Parameters Type Name Description System.String message The exception message. | Improve this doc View source SilverbackException(String, Exception) Initializes a new instance of the SilverbackException class with the specified message and inner exception. Declaration protected SilverbackException(string message, Exception innerException) Parameters Type Name Description System.String message The exception message. System.Exception innerException The inner exception. Implements System.Runtime.Serialization.ISerializable"
  },
  "api/Silverback.Testing.html": {
    "href": "api/Silverback.Testing.html",
    "title": "Namespace Silverback.Testing | Silverback",
    "keywords": "Namespace Silverback.Testing Classes InboundSpyBrokerBehavior Added at the end of the consumer pipeline, forwards the processed Silverback.Messaging.Messages.IInboundEnvelope to the IIntegrationSpy . InboundSpySubscriber Subscribes to all the Silverback.Messaging.Messages.IOutboundEnvelope transiting through the internal bus and forwards them to the IIntegrationSpy to be collected. IntegrationSpy KafkaTestingHelper MqttTestingHelper OutboundSpyBrokerBehavior Added at the very beginning of the producer pipeline, forwards the published Silverback.Messaging.Messages.IOutboundEnvelope to the IIntegrationSpy . RawInboundSpyBrokerBehavior Added at the very beginning of the consumer pipeline, forwards the untouched Silverback.Messaging.Messages.IRawInboundEnvelope to the IIntegrationSpy . RawOutboundSpyBrokerBehavior Added at the very end of the producer pipeline, forwards the produced Silverback.Messaging.Messages.IRawOutboundEnvelope to the IIntegrationSpy . TestingHelper<TBroker> Interfaces IIntegrationSpy Monitors and collects all outbound and inbound messages. IKafkaTestingHelper IMqttTestingHelper ITestingHelper<TBroker> Exposes some helper methods and shortcuts to simplify testing."
  },
  "api/Silverback.Testing.IIntegrationSpy.html": {
    "href": "api/Silverback.Testing.IIntegrationSpy.html",
    "title": "Interface IIntegrationSpy | Silverback",
    "keywords": "Interface IIntegrationSpy Monitors and collects all outbound and inbound messages. Namespace : Silverback.Testing Assembly : Silverback.Integration.Testing.dll Syntax public interface IIntegrationSpy Properties | Improve this doc View source InboundEnvelopes Gets the list of Silverback.Messaging.Messages.IInboundEnvelope corresponding to all the inbound messages that have been processed by the consumer pipeline (except the ones that couldn't be deserialized, e.g. the ones with an empty body). Declaration IReadOnlyList<IInboundEnvelope> InboundEnvelopes { get; } Property Value Type Description System.Collections.Generic.IReadOnlyList < Silverback.Messaging.Messages.IInboundEnvelope > | Improve this doc View source OutboundEnvelopes Gets the list of Silverback.Messaging.Messages.IOutboundEnvelope corresponding to all the outbound messages. Declaration IReadOnlyList<IOutboundEnvelope> OutboundEnvelopes { get; } Property Value Type Description System.Collections.Generic.IReadOnlyList < Silverback.Messaging.Messages.IOutboundEnvelope > Remarks The messages produces via RawProduce or RawProduceAsync will not go through the Silverback pipeline and will therefore not show up in this collection. | Improve this doc View source RawInboundEnvelopes Gets the list of Silverback.Messaging.Messages.IRawInboundEnvelope corresponding to all the inbound messages, before they are even processed by the consumer pipeline. Declaration IReadOnlyList<IRawInboundEnvelope> RawInboundEnvelopes { get; } Property Value Type Description System.Collections.Generic.IReadOnlyList < Silverback.Messaging.Messages.IRawInboundEnvelope > | Improve this doc View source RawOutboundEnvelopes Gets the list of Silverback.Messaging.Messages.IRawOutboundEnvelope corresponding to all the actual outbound messages being produced (these may differ from the OutboundEnvelopes , e.g. if chunking is applied). Declaration IReadOnlyList<IRawOutboundEnvelope> RawOutboundEnvelopes { get; } Property Value Type Description System.Collections.Generic.IReadOnlyList < Silverback.Messaging.Messages.IRawOutboundEnvelope > Remarks The messages produces via RawProduce or RawProduceAsync will not go through the Silverback pipeline and will therefore not show up in this collection."
  },
  "api/Silverback.Testing.IKafkaTestingHelper.html": {
    "href": "api/Silverback.Testing.IKafkaTestingHelper.html",
    "title": "Interface IKafkaTestingHelper | Silverback",
    "keywords": "Interface IKafkaTestingHelper Inherited Members ITestingHelper<KafkaBroker>.Broker ITestingHelper<KafkaBroker>.Spy ITestingHelper<KafkaBroker>.WaitUntilConnectedAsync(Nullable<TimeSpan>) ITestingHelper<KafkaBroker>.WaitUntilConnectedAsync(Boolean, Nullable<TimeSpan>) ITestingHelper<KafkaBroker>.WaitUntilAllMessagesAreConsumedAsync(Nullable<TimeSpan>) ITestingHelper<KafkaBroker>.WaitUntilAllMessagesAreConsumedAsync(Boolean, Nullable<TimeSpan>) ITestingHelper<KafkaBroker>.WaitUntilOutboxIsEmptyAsync(CancellationToken) ITestingHelper<KafkaBroker>.IsOutboxEmptyAsync() Namespace : Silverback.Testing Assembly : Silverback.Integration.Kafka.Testing.dll Syntax public interface IKafkaTestingHelper : ITestingHelper<KafkaBroker> Methods | Improve this doc View source GetTopic(String) Returns the IInMemoryTopic with the specified name. Declaration IInMemoryTopic GetTopic(string name) Parameters Type Name Description System.String name The name of the topic. Returns Type Description IInMemoryTopic The IInMemoryTopic . Remarks This method works with the mocked Kafka broker only. See UseMockedKafka(ISilverbackBuilder, Action<IMockedKafkaOptionsBuilder>) or AddMockedKafka(IBrokerOptionsBuilder, Action<IMockedKafkaOptionsBuilder>) . | Improve this doc View source GetTopic(String, String) Returns the IInMemoryTopic with the specified name. Declaration IInMemoryTopic GetTopic(string name, string bootstrapServers) Parameters Type Name Description System.String name The name of the topic. System.String bootstrapServers The bootstrap servers string used to identify the target broker. Returns Type Description IInMemoryTopic The IInMemoryTopic . Remarks This method works with the mocked Kafka broker only. See UseMockedKafka(ISilverbackBuilder, Action<IMockedKafkaOptionsBuilder>) or AddMockedKafka(IBrokerOptionsBuilder, Action<IMockedKafkaOptionsBuilder>) . | Improve this doc View source GetTopics(String, String) Returns the collection of IInMemoryTopic with the specified name. Declaration IReadOnlyCollection<IInMemoryTopic> GetTopics(string name, string bootstrapServers = null) Parameters Type Name Description System.String name The name of the topic. System.String bootstrapServers The bootstrap servers string used to identify the target broker. Returns Type Description System.Collections.Generic.IReadOnlyCollection < IInMemoryTopic > The collection of IInMemoryTopic . Remarks This method works with the mocked Kafka broker only. See UseMockedKafka(ISilverbackBuilder, Action<IMockedKafkaOptionsBuilder>) or AddMockedKafka(IBrokerOptionsBuilder, Action<IMockedKafkaOptionsBuilder>) . | Improve this doc View source WaitUntilAllMessagesAreConsumedAsync(Boolean, IReadOnlyCollection<String>, Nullable<TimeSpan>) Returns a System.Threading.Tasks.Task that completes when all messages routed to the consumers have been processed and committed. Declaration Task WaitUntilAllMessagesAreConsumedAsync(bool throwTimeoutException, IReadOnlyCollection<string> topicNames, TimeSpan? timeout = null) Parameters Type Name Description System.Boolean throwTimeoutException A value specifying whether a System.TimeoutException has to be thrown when the messages aren't consumed before the timeout expires. System.Collections.Generic.IReadOnlyCollection < System.String > topicNames The name of the topics to be monitored. System.Nullable < System.TimeSpan > timeout The time to wait for the messages to be consumed and processed. The default is 30 seconds. Returns Type Description System.Threading.Tasks.Task A System.Threading.Tasks.Task that completes when all messages have been processed. Remarks This method works with the mocked Kafka broker only. See UseMockedKafka(ISilverbackBuilder, Action<IMockedKafkaOptionsBuilder>) or AddMockedKafka(IBrokerOptionsBuilder, Action<IMockedKafkaOptionsBuilder>) . | Improve this doc View source WaitUntilAllMessagesAreConsumedAsync(IReadOnlyCollection<String>, Nullable<TimeSpan>) Returns a System.Threading.Tasks.Task that completes when all messages routed to the consumers have been processed and committed. Declaration Task WaitUntilAllMessagesAreConsumedAsync(IReadOnlyCollection<string> topicNames, TimeSpan? timeout = null) Parameters Type Name Description System.Collections.Generic.IReadOnlyCollection < System.String > topicNames The name of the topics to be monitored. System.Nullable < System.TimeSpan > timeout The time to wait for the messages to be consumed and processed. The default is 30 seconds. Returns Type Description System.Threading.Tasks.Task A System.Threading.Tasks.Task that completes when all messages have been processed. Remarks This method works with the mocked Kafka broker only. See UseMockedKafka(ISilverbackBuilder, Action<IMockedKafkaOptionsBuilder>) or AddMockedKafka(IBrokerOptionsBuilder, Action<IMockedKafkaOptionsBuilder>) ."
  },
  "api/Silverback.Testing.IMqttTestingHelper.html": {
    "href": "api/Silverback.Testing.IMqttTestingHelper.html",
    "title": "Interface IMqttTestingHelper | Silverback",
    "keywords": "Interface IMqttTestingHelper Inherited Members ITestingHelper<MqttBroker>.Broker ITestingHelper<MqttBroker>.Spy ITestingHelper<MqttBroker>.WaitUntilConnectedAsync(Nullable<TimeSpan>) ITestingHelper<MqttBroker>.WaitUntilConnectedAsync(Boolean, Nullable<TimeSpan>) ITestingHelper<MqttBroker>.WaitUntilAllMessagesAreConsumedAsync(Nullable<TimeSpan>) ITestingHelper<MqttBroker>.WaitUntilAllMessagesAreConsumedAsync(Boolean, Nullable<TimeSpan>) ITestingHelper<MqttBroker>.WaitUntilOutboxIsEmptyAsync(CancellationToken) ITestingHelper<MqttBroker>.IsOutboxEmptyAsync() Namespace : Silverback.Testing Assembly : Silverback.Integration.MQTT.Testing.dll Syntax public interface IMqttTestingHelper : ITestingHelper<MqttBroker> Methods | Improve this doc View source GetClientSession(String) Gets the IClientSession of the specified client. Declaration IClientSession GetClientSession(string clientId) Parameters Type Name Description System.String clientId The client id. Returns Type Description IClientSession The IClientSession . Remarks This method works with the mocked MQTT broker only. See UseMockedMqtt(ISilverbackBuilder, Action<IMockedMqttOptionsBuilder>) or AddMockedMqtt(IBrokerOptionsBuilder, Action<IMockedMqttOptionsBuilder>) . | Improve this doc View source GetMessages(String) Gets the messages that have been published to the specified topic. Declaration IReadOnlyList<MqttApplicationMessage> GetMessages(string topic) Parameters Type Name Description System.String topic The name of the topic. Returns Type Description System.Collections.Generic.IReadOnlyList < MQTTnet.MqttApplicationMessage > The messages published to the topic. Remarks This method works with the mocked MQTT broker only. See UseMockedMqtt(ISilverbackBuilder, Action<IMockedMqttOptionsBuilder>) or AddMockedMqtt(IBrokerOptionsBuilder, Action<IMockedMqttOptionsBuilder>) ."
  },
  "api/Silverback.Testing.InboundSpyBrokerBehavior.html": {
    "href": "api/Silverback.Testing.InboundSpyBrokerBehavior.html",
    "title": "Class InboundSpyBrokerBehavior | Silverback",
    "keywords": "Class InboundSpyBrokerBehavior Added at the end of the consumer pipeline, forwards the processed Silverback.Messaging.Messages.IInboundEnvelope to the IIntegrationSpy . Inheritance System.Object InboundSpyBrokerBehavior Implements Silverback.Messaging.Broker.Behaviors.IConsumerBehavior Silverback.Messaging.Broker.Behaviors.IBrokerBehavior ISorted Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Silverback.Testing Assembly : Silverback.Integration.Testing.dll Syntax public class InboundSpyBrokerBehavior : IConsumerBehavior, IBrokerBehavior, ISorted Constructors | Improve this doc View source InboundSpyBrokerBehavior(IntegrationSpy) Initializes a new instance of the InboundSpyBrokerBehavior class. Declaration public InboundSpyBrokerBehavior(IntegrationSpy integrationSpy) Parameters Type Name Description IntegrationSpy integrationSpy The IntegrationSpy . Properties | Improve this doc View source SortIndex Declaration public int SortIndex { get; } Property Value Type Description System.Int32 Methods | Improve this doc View source HandleAsync(ConsumerPipelineContext, ConsumerBehaviorHandler) Declaration public Task HandleAsync(ConsumerPipelineContext context, ConsumerBehaviorHandler next) Parameters Type Name Description Silverback.Messaging.Broker.Behaviors.ConsumerPipelineContext context Silverback.Messaging.Broker.Behaviors.ConsumerBehaviorHandler next Returns Type Description System.Threading.Tasks.Task Implements Silverback.Messaging.Broker.Behaviors.IConsumerBehavior Silverback.Messaging.Broker.Behaviors.IBrokerBehavior ISorted"
  },
  "api/Silverback.Testing.InboundSpySubscriber.html": {
    "href": "api/Silverback.Testing.InboundSpySubscriber.html",
    "title": "Class InboundSpySubscriber | Silverback",
    "keywords": "Class InboundSpySubscriber Subscribes to all the Silverback.Messaging.Messages.IOutboundEnvelope transiting through the internal bus and forwards them to the IIntegrationSpy to be collected. Inheritance System.Object InboundSpySubscriber Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Silverback.Testing Assembly : Silverback.Integration.Testing.dll Syntax public class InboundSpySubscriber Remarks This is used alternatively to the InboundSpyBrokerBehavior . Constructors | Improve this doc View source InboundSpySubscriber(IntegrationSpy) Initializes a new instance of the InboundSpySubscriber class. Declaration public InboundSpySubscriber(IntegrationSpy integrationSpy) Parameters Type Name Description IntegrationSpy integrationSpy The IntegrationSpy ."
  },
  "api/Silverback.Testing.IntegrationSpy.html": {
    "href": "api/Silverback.Testing.IntegrationSpy.html",
    "title": "Class IntegrationSpy | Silverback",
    "keywords": "Class IntegrationSpy Inheritance System.Object IntegrationSpy Implements IIntegrationSpy Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Silverback.Testing Assembly : Silverback.Integration.Testing.dll Syntax public class IntegrationSpy : IIntegrationSpy Properties | Improve this doc View source InboundEnvelopes Declaration public IReadOnlyList<IInboundEnvelope> InboundEnvelopes { get; } Property Value Type Description System.Collections.Generic.IReadOnlyList < Silverback.Messaging.Messages.IInboundEnvelope > | Improve this doc View source OutboundEnvelopes Declaration public IReadOnlyList<IOutboundEnvelope> OutboundEnvelopes { get; } Property Value Type Description System.Collections.Generic.IReadOnlyList < Silverback.Messaging.Messages.IOutboundEnvelope > | Improve this doc View source RawInboundEnvelopes Declaration public IReadOnlyList<IRawInboundEnvelope> RawInboundEnvelopes { get; } Property Value Type Description System.Collections.Generic.IReadOnlyList < Silverback.Messaging.Messages.IRawInboundEnvelope > | Improve this doc View source RawOutboundEnvelopes Declaration public IReadOnlyList<IRawOutboundEnvelope> RawOutboundEnvelopes { get; } Property Value Type Description System.Collections.Generic.IReadOnlyList < Silverback.Messaging.Messages.IRawOutboundEnvelope > Methods | Improve this doc View source AddInboundEnvelope(IInboundEnvelope) Adds an item to the InboundEnvelopes . Declaration public void AddInboundEnvelope(IInboundEnvelope envelope) Parameters Type Name Description Silverback.Messaging.Messages.IInboundEnvelope envelope The Silverback.Messaging.Messages.IInboundEnvelope to add. | Improve this doc View source AddOutboundEnvelope(IOutboundEnvelope) Adds an item to the OutboundEnvelopes . Declaration public void AddOutboundEnvelope(IOutboundEnvelope envelope) Parameters Type Name Description Silverback.Messaging.Messages.IOutboundEnvelope envelope The Silverback.Messaging.Messages.IOutboundEnvelope to add. | Improve this doc View source AddRawInboundEnvelope(IRawInboundEnvelope) Adds an item to the Silverback.Messaging.Messages.RawInboundEnvelope . Declaration public void AddRawInboundEnvelope(IRawInboundEnvelope envelope) Parameters Type Name Description Silverback.Messaging.Messages.IRawInboundEnvelope envelope The Silverback.Messaging.Messages.IRawInboundEnvelope to add. | Improve this doc View source AddRawOutboundEnvelope(IRawOutboundEnvelope) Adds an item to the Silverback.Messaging.Messages.RawOutboundEnvelope . Declaration public void AddRawOutboundEnvelope(IRawOutboundEnvelope envelope) Parameters Type Name Description Silverback.Messaging.Messages.IRawOutboundEnvelope envelope The Silverback.Messaging.Messages.IRawOutboundEnvelope to add. Implements IIntegrationSpy"
  },
  "api/Silverback.Testing.ITestingHelper-1.html": {
    "href": "api/Silverback.Testing.ITestingHelper-1.html",
    "title": "Interface ITestingHelper<TBroker> | Silverback",
    "keywords": "Interface ITestingHelper<TBroker> Exposes some helper methods and shortcuts to simplify testing. Namespace : Silverback.Testing Assembly : Silverback.Integration.Testing.dll Syntax public interface ITestingHelper<out TBroker> where TBroker : IBroker Type Parameters Name Description TBroker The Silverback.Messaging.Broker.IBroker implementation. Properties | Improve this doc View source Broker Gets the current Silverback.Messaging.Broker.IBroker instance. Declaration TBroker Broker { get; } Property Value Type Description TBroker | Improve this doc View source Spy Gets the IIntegrationSpy . Declaration IIntegrationSpy Spy { get; } Property Value Type Description IIntegrationSpy Remarks The IIntegrationSpy must be enabled calling AddIntegrationSpy or AddIntegrationSpyAndSubscriber . Methods | Improve this doc View source IsOutboxEmptyAsync() Checks whether the outbox (table) is empty. Declaration Task<bool> IsOutboxEmptyAsync() Returns Type Description System.Threading.Tasks.Task < System.Boolean > A System.Threading.Tasks.Task<TResult> representing the asynchronous operation. The task result contains true if the outbox is empty, otherwise false . | Improve this doc View source WaitUntilAllMessagesAreConsumedAsync(Boolean, Nullable<TimeSpan>) Returns a System.Threading.Tasks.Task that completes when all messages routed to the consumers have been processed and committed. Declaration Task WaitUntilAllMessagesAreConsumedAsync(bool throwTimeoutException, TimeSpan? timeout = null) Parameters Type Name Description System.Boolean throwTimeoutException A value specifying whether a System.TimeoutException has to be thrown when the messages aren't consumed before the timeout expires. System.Nullable < System.TimeSpan > timeout The time to wait for the messages to be consumed and processed. The default is 30 seconds. Returns Type Description System.Threading.Tasks.Task A System.Threading.Tasks.Task that completes when all messages have been processed. Remarks This method works with the mocked brokers only. | Improve this doc View source WaitUntilAllMessagesAreConsumedAsync(Nullable<TimeSpan>) Returns a System.Threading.Tasks.Task that completes when all messages routed to the consumers have been processed and committed. Declaration Task WaitUntilAllMessagesAreConsumedAsync(TimeSpan? timeout = null) Parameters Type Name Description System.Nullable < System.TimeSpan > timeout The time to wait for the messages to be consumed and processed. The default is 30 seconds. Returns Type Description System.Threading.Tasks.Task A System.Threading.Tasks.Task that completes when all messages have been processed. Remarks This method works with the mocked brokers only. | Improve this doc View source WaitUntilConnectedAsync(Boolean, Nullable<TimeSpan>) Returns a System.Threading.Tasks.Task that completes when all consumers are connected and ready. Declaration Task WaitUntilConnectedAsync(bool throwTimeoutException, TimeSpan? timeout = null) Parameters Type Name Description System.Boolean throwTimeoutException A value specifying whether a System.TimeoutException has to be thrown when the connection isn't established before the timeout expires. System.Nullable < System.TimeSpan > timeout The time to wait for the consumers to connect. The default is 30 seconds. Returns Type Description System.Threading.Tasks.Task A System.Threading.Tasks.Task that completes when all consumers are successfully connected and ready. | Improve this doc View source WaitUntilConnectedAsync(Nullable<TimeSpan>) Returns a System.Threading.Tasks.Task that completes when all consumers are connected and ready. Declaration Task WaitUntilConnectedAsync(TimeSpan? timeout = null) Parameters Type Name Description System.Nullable < System.TimeSpan > timeout The time to wait for the consumers to connect. The default is 30 seconds. Returns Type Description System.Threading.Tasks.Task A System.Threading.Tasks.Task that completes when all consumers are successfully connected and ready. | Improve this doc View source WaitUntilOutboxIsEmptyAsync(CancellationToken) Returns a System.Threading.Tasks.Task that completes when all messages stored in the outbox have been produced. Declaration Task WaitUntilOutboxIsEmptyAsync(CancellationToken cancellationToken) Parameters Type Name Description System.Threading.CancellationToken cancellationToken A System.Threading.CancellationToken to observe while waiting for the task to complete. Returns Type Description System.Threading.Tasks.Task A System.Threading.Tasks.Task that completes when the outbox is empty."
  },
  "api/Silverback.Testing.KafkaTestingHelper.html": {
    "href": "api/Silverback.Testing.KafkaTestingHelper.html",
    "title": "Class KafkaTestingHelper | Silverback",
    "keywords": "Class KafkaTestingHelper Inheritance System.Object TestingHelper < Silverback.Messaging.Broker.KafkaBroker > KafkaTestingHelper Implements IKafkaTestingHelper ITestingHelper < Silverback.Messaging.Broker.KafkaBroker > Inherited Members TestingHelper<KafkaBroker>.Broker TestingHelper<KafkaBroker>.Spy TestingHelper<KafkaBroker>.WaitUntilConnectedAsync(Nullable<TimeSpan>) TestingHelper<KafkaBroker>.WaitUntilConnectedAsync(Boolean, Nullable<TimeSpan>) TestingHelper<KafkaBroker>.WaitUntilAllMessagesAreConsumedAsync(Nullable<TimeSpan>) TestingHelper<KafkaBroker>.WaitUntilOutboxIsEmptyAsync(CancellationToken) TestingHelper<KafkaBroker>.IsOutboxEmptyAsync() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Silverback.Testing Assembly : Silverback.Integration.Kafka.Testing.dll Syntax public class KafkaTestingHelper : TestingHelper<KafkaBroker>, IKafkaTestingHelper, ITestingHelper<KafkaBroker> Constructors | Improve this doc View source KafkaTestingHelper(IServiceProvider, ILogger<KafkaTestingHelper>) Initializes a new instance of the KafkaTestingHelper class. Declaration public KafkaTestingHelper(IServiceProvider serviceProvider, ILogger<KafkaTestingHelper> logger) Parameters Type Name Description System.IServiceProvider serviceProvider The System.IServiceProvider . Microsoft.Extensions.Logging.ILogger < KafkaTestingHelper > logger The ISilverbackLogger . Methods | Improve this doc View source GetTopic(String) Declaration public IInMemoryTopic GetTopic(string name) Parameters Type Name Description System.String name Returns Type Description IInMemoryTopic | Improve this doc View source GetTopic(String, String) Declaration public IInMemoryTopic GetTopic(string name, string bootstrapServers) Parameters Type Name Description System.String name System.String bootstrapServers Returns Type Description IInMemoryTopic | Improve this doc View source GetTopics(String, String) Declaration public IReadOnlyCollection<IInMemoryTopic> GetTopics(string name, string bootstrapServers = null) Parameters Type Name Description System.String name System.String bootstrapServers Returns Type Description System.Collections.Generic.IReadOnlyCollection < IInMemoryTopic > | Improve this doc View source WaitUntilAllMessagesAreConsumedAsync(Boolean, IReadOnlyCollection<String>, Nullable<TimeSpan>) Declaration public Task WaitUntilAllMessagesAreConsumedAsync(bool throwTimeoutException, IReadOnlyCollection<string> topicNames, TimeSpan? timeout = null) Parameters Type Name Description System.Boolean throwTimeoutException System.Collections.Generic.IReadOnlyCollection < System.String > topicNames System.Nullable < System.TimeSpan > timeout Returns Type Description System.Threading.Tasks.Task | Improve this doc View source WaitUntilAllMessagesAreConsumedAsync(Boolean, Nullable<TimeSpan>) Declaration public override Task WaitUntilAllMessagesAreConsumedAsync(bool throwTimeoutException, TimeSpan? timeout = null) Parameters Type Name Description System.Boolean throwTimeoutException System.Nullable < System.TimeSpan > timeout Returns Type Description System.Threading.Tasks.Task Overrides Silverback.Testing.TestingHelper<Silverback.Messaging.Broker.KafkaBroker>.WaitUntilAllMessagesAreConsumedAsync(System.Boolean, System.Nullable<System.TimeSpan>) | Improve this doc View source WaitUntilAllMessagesAreConsumedAsync(IReadOnlyCollection<String>, Nullable<TimeSpan>) Declaration public Task WaitUntilAllMessagesAreConsumedAsync(IReadOnlyCollection<string> topicNames, TimeSpan? timeout = null) Parameters Type Name Description System.Collections.Generic.IReadOnlyCollection < System.String > topicNames System.Nullable < System.TimeSpan > timeout Returns Type Description System.Threading.Tasks.Task Implements IKafkaTestingHelper ITestingHelper<TBroker>"
  },
  "api/Silverback.Testing.MqttTestingHelper.html": {
    "href": "api/Silverback.Testing.MqttTestingHelper.html",
    "title": "Class MqttTestingHelper | Silverback",
    "keywords": "Class MqttTestingHelper Inheritance System.Object TestingHelper < Silverback.Messaging.Broker.MqttBroker > MqttTestingHelper Implements IMqttTestingHelper ITestingHelper < Silverback.Messaging.Broker.MqttBroker > Inherited Members TestingHelper<MqttBroker>.Broker TestingHelper<MqttBroker>.Spy TestingHelper<MqttBroker>.WaitUntilConnectedAsync(Nullable<TimeSpan>) TestingHelper<MqttBroker>.WaitUntilConnectedAsync(Boolean, Nullable<TimeSpan>) TestingHelper<MqttBroker>.WaitUntilAllMessagesAreConsumedAsync(Nullable<TimeSpan>) TestingHelper<MqttBroker>.WaitUntilOutboxIsEmptyAsync(CancellationToken) TestingHelper<MqttBroker>.IsOutboxEmptyAsync() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Silverback.Testing Assembly : Silverback.Integration.MQTT.Testing.dll Syntax public class MqttTestingHelper : TestingHelper<MqttBroker>, IMqttTestingHelper, ITestingHelper<MqttBroker> Constructors | Improve this doc View source MqttTestingHelper(IServiceProvider, ILogger<MqttTestingHelper>) Initializes a new instance of the MqttTestingHelper class. Declaration public MqttTestingHelper(IServiceProvider serviceProvider, ILogger<MqttTestingHelper> logger) Parameters Type Name Description System.IServiceProvider serviceProvider The System.IServiceProvider . Microsoft.Extensions.Logging.ILogger < MqttTestingHelper > logger The ISilverbackLogger . Methods | Improve this doc View source GetClientSession(String) Declaration public IClientSession GetClientSession(string clientId) Parameters Type Name Description System.String clientId Returns Type Description IClientSession | Improve this doc View source GetMessages(String) Declaration public IReadOnlyList<MqttApplicationMessage> GetMessages(string topic) Parameters Type Name Description System.String topic Returns Type Description System.Collections.Generic.IReadOnlyList < MQTTnet.MqttApplicationMessage > | Improve this doc View source WaitUntilAllMessagesAreConsumedAsync(Boolean, Nullable<TimeSpan>) Declaration public override async Task WaitUntilAllMessagesAreConsumedAsync(bool throwTimeoutException, TimeSpan? timeout = null) Parameters Type Name Description System.Boolean throwTimeoutException System.Nullable < System.TimeSpan > timeout Returns Type Description System.Threading.Tasks.Task Overrides Silverback.Testing.TestingHelper<Silverback.Messaging.Broker.MqttBroker>.WaitUntilAllMessagesAreConsumedAsync(System.Boolean, System.Nullable<System.TimeSpan>) Implements IMqttTestingHelper ITestingHelper<TBroker>"
  },
  "api/Silverback.Testing.OutboundSpyBrokerBehavior.html": {
    "href": "api/Silverback.Testing.OutboundSpyBrokerBehavior.html",
    "title": "Class OutboundSpyBrokerBehavior | Silverback",
    "keywords": "Class OutboundSpyBrokerBehavior Added at the very beginning of the producer pipeline, forwards the published Silverback.Messaging.Messages.IOutboundEnvelope to the IIntegrationSpy . Inheritance System.Object OutboundSpyBrokerBehavior Implements Silverback.Messaging.Broker.Behaviors.IProducerBehavior Silverback.Messaging.Broker.Behaviors.IBrokerBehavior ISorted Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Silverback.Testing Assembly : Silverback.Integration.Testing.dll Syntax public class OutboundSpyBrokerBehavior : IProducerBehavior, IBrokerBehavior, ISorted Constructors | Improve this doc View source OutboundSpyBrokerBehavior(IntegrationSpy) Initializes a new instance of the OutboundSpyBrokerBehavior class. Declaration public OutboundSpyBrokerBehavior(IntegrationSpy integrationSpy) Parameters Type Name Description IntegrationSpy integrationSpy The IntegrationSpy . Properties | Improve this doc View source SortIndex Declaration public int SortIndex { get; } Property Value Type Description System.Int32 Methods | Improve this doc View source HandleAsync(ProducerPipelineContext, ProducerBehaviorHandler) Declaration public Task HandleAsync(ProducerPipelineContext context, ProducerBehaviorHandler next) Parameters Type Name Description Silverback.Messaging.Broker.Behaviors.ProducerPipelineContext context Silverback.Messaging.Broker.Behaviors.ProducerBehaviorHandler next Returns Type Description System.Threading.Tasks.Task Implements Silverback.Messaging.Broker.Behaviors.IProducerBehavior Silverback.Messaging.Broker.Behaviors.IBrokerBehavior ISorted"
  },
  "api/Silverback.Testing.RawInboundSpyBrokerBehavior.html": {
    "href": "api/Silverback.Testing.RawInboundSpyBrokerBehavior.html",
    "title": "Class RawInboundSpyBrokerBehavior | Silverback",
    "keywords": "Class RawInboundSpyBrokerBehavior Added at the very beginning of the consumer pipeline, forwards the untouched Silverback.Messaging.Messages.IRawInboundEnvelope to the IIntegrationSpy . Inheritance System.Object RawInboundSpyBrokerBehavior Implements Silverback.Messaging.Broker.Behaviors.IConsumerBehavior Silverback.Messaging.Broker.Behaviors.IBrokerBehavior ISorted Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Silverback.Testing Assembly : Silverback.Integration.Testing.dll Syntax public class RawInboundSpyBrokerBehavior : IConsumerBehavior, IBrokerBehavior, ISorted Constructors | Improve this doc View source RawInboundSpyBrokerBehavior(IntegrationSpy) Initializes a new instance of the RawInboundSpyBrokerBehavior class. Declaration public RawInboundSpyBrokerBehavior(IntegrationSpy integrationSpy) Parameters Type Name Description IntegrationSpy integrationSpy The IntegrationSpy . Properties | Improve this doc View source SortIndex Declaration public int SortIndex { get; } Property Value Type Description System.Int32 Methods | Improve this doc View source HandleAsync(ConsumerPipelineContext, ConsumerBehaviorHandler) Declaration public Task HandleAsync(ConsumerPipelineContext context, ConsumerBehaviorHandler next) Parameters Type Name Description Silverback.Messaging.Broker.Behaviors.ConsumerPipelineContext context Silverback.Messaging.Broker.Behaviors.ConsumerBehaviorHandler next Returns Type Description System.Threading.Tasks.Task Implements Silverback.Messaging.Broker.Behaviors.IConsumerBehavior Silverback.Messaging.Broker.Behaviors.IBrokerBehavior ISorted"
  },
  "api/Silverback.Testing.RawOutboundSpyBrokerBehavior.html": {
    "href": "api/Silverback.Testing.RawOutboundSpyBrokerBehavior.html",
    "title": "Class RawOutboundSpyBrokerBehavior | Silverback",
    "keywords": "Class RawOutboundSpyBrokerBehavior Added at the very end of the producer pipeline, forwards the produced Silverback.Messaging.Messages.IRawOutboundEnvelope to the IIntegrationSpy . Inheritance System.Object RawOutboundSpyBrokerBehavior Implements Silverback.Messaging.Broker.Behaviors.IProducerBehavior Silverback.Messaging.Broker.Behaviors.IBrokerBehavior ISorted Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Silverback.Testing Assembly : Silverback.Integration.Testing.dll Syntax public class RawOutboundSpyBrokerBehavior : IProducerBehavior, IBrokerBehavior, ISorted Constructors | Improve this doc View source RawOutboundSpyBrokerBehavior(IntegrationSpy) Initializes a new instance of the RawOutboundSpyBrokerBehavior class. Declaration public RawOutboundSpyBrokerBehavior(IntegrationSpy integrationSpy) Parameters Type Name Description IntegrationSpy integrationSpy The IntegrationSpy . Properties | Improve this doc View source SortIndex Declaration public int SortIndex { get; } Property Value Type Description System.Int32 Methods | Improve this doc View source HandleAsync(ProducerPipelineContext, ProducerBehaviorHandler) Declaration public Task HandleAsync(ProducerPipelineContext context, ProducerBehaviorHandler next) Parameters Type Name Description Silverback.Messaging.Broker.Behaviors.ProducerPipelineContext context Silverback.Messaging.Broker.Behaviors.ProducerBehaviorHandler next Returns Type Description System.Threading.Tasks.Task Implements Silverback.Messaging.Broker.Behaviors.IProducerBehavior Silverback.Messaging.Broker.Behaviors.IBrokerBehavior ISorted"
  },
  "api/Silverback.Testing.TestingHelper-1.html": {
    "href": "api/Silverback.Testing.TestingHelper-1.html",
    "title": "Class TestingHelper<TBroker> | Silverback",
    "keywords": "Class TestingHelper<TBroker> Inheritance System.Object TestingHelper<TBroker> KafkaTestingHelper MqttTestingHelper Implements ITestingHelper <TBroker> Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Silverback.Testing Assembly : Silverback.Integration.Testing.dll Syntax public abstract class TestingHelper<TBroker> : ITestingHelper<TBroker> where TBroker : IBroker Type Parameters Name Description TBroker Constructors | Improve this doc View source TestingHelper(IServiceProvider, ILogger<TestingHelper<TBroker>>) Initializes a new instance of the TestingHelper<TBroker> class. Declaration protected TestingHelper(IServiceProvider serviceProvider, ILogger<TestingHelper<TBroker>> logger) Parameters Type Name Description System.IServiceProvider serviceProvider The System.IServiceProvider . Microsoft.Extensions.Logging.ILogger < TestingHelper <TBroker>> logger The Microsoft.Extensions.Logging.ILogger<TCategoryName> . Properties | Improve this doc View source Broker Declaration public TBroker Broker { get; } Property Value Type Description TBroker | Improve this doc View source Spy Declaration public IIntegrationSpy Spy { get; } Property Value Type Description IIntegrationSpy Methods | Improve this doc View source IsOutboxEmptyAsync() Declaration public async Task<bool> IsOutboxEmptyAsync() Returns Type Description System.Threading.Tasks.Task < System.Boolean > | Improve this doc View source WaitUntilAllMessagesAreConsumedAsync(Boolean, Nullable<TimeSpan>) Declaration public abstract Task WaitUntilAllMessagesAreConsumedAsync(bool throwTimeoutException, TimeSpan? timeout = null) Parameters Type Name Description System.Boolean throwTimeoutException System.Nullable < System.TimeSpan > timeout Returns Type Description System.Threading.Tasks.Task | Improve this doc View source WaitUntilAllMessagesAreConsumedAsync(Nullable<TimeSpan>) Declaration public Task WaitUntilAllMessagesAreConsumedAsync(TimeSpan? timeout = null) Parameters Type Name Description System.Nullable < System.TimeSpan > timeout Returns Type Description System.Threading.Tasks.Task | Improve this doc View source WaitUntilConnectedAsync(Boolean, Nullable<TimeSpan>) Declaration public async Task WaitUntilConnectedAsync(bool throwTimeoutException, TimeSpan? timeout = null) Parameters Type Name Description System.Boolean throwTimeoutException System.Nullable < System.TimeSpan > timeout Returns Type Description System.Threading.Tasks.Task | Improve this doc View source WaitUntilConnectedAsync(Nullable<TimeSpan>) Declaration public Task WaitUntilConnectedAsync(TimeSpan? timeout = null) Parameters Type Name Description System.Nullable < System.TimeSpan > timeout Returns Type Description System.Threading.Tasks.Task | Improve this doc View source WaitUntilOutboxIsEmptyAsync(CancellationToken) Declaration public async Task WaitUntilOutboxIsEmptyAsync(CancellationToken cancellationToken) Parameters Type Name Description System.Threading.CancellationToken cancellationToken Returns Type Description System.Threading.Tasks.Task Implements ITestingHelper<TBroker>"
  },
  "concepts/background-services.html": {
    "href": "concepts/background-services.html",
    "title": "Distributed Background Services | Silverback",
    "keywords": "Distributed Background Services To implement the <xref:Silverback.Messaging.Outbound.TransactionalOutbox.OutboxWorkerService> we had to create a database based locking mechanism, to ensure that only a single instance of our worker was running. You can take advantage of this implementation to build your IHostedService . DistributedBackgroundService Two base classes are available in Silverback.Core : DistributedBackgroundService implements the basic locking mechanism, while RecurringDistributedBackgroundService adds on top of it the ability to run a task as specified intervals. using Silverback.Background; namespace Sample { public class MyBackroundService : RecurringDistributedBackgroundService { private readonly IMyService _myService; public MyBackroundService( IMyService _myService, IDistributedLockManager distributedLockManager, ILogger<OutboundQueueWorkerService> logger) : base( TimeSpan.FromMinutes(5), // interval distributedLockManager, logger) { } protected override Task ExecuteRecurringAsync( CancellationToken stoppingToken) => _myService.DoWork(stoppingToken); } } Note A DistributedLockSettings object can be passed to the constructor of the base class to customize lock timeout, heartbeat interval, etc. Lock Manager To enable the distributed locks an IDistributedLockManager implementation (probably a DbDistributedLockManager ) must be registered for dependency injection as shown in the next code snippet. Note The Silverback.Core.EntityFrameworkCore package is also required and the DbContext must configure a DbSet<Lock> . See also the Sample DbContext (EF Core) . public class Startup { public void ConfigureServices(IServiceCollection services) { services .AddSilverback() .UseDbContext<MyDbContext>() .AddDbDistributedLockManager(); } }"
  },
  "concepts/broker/behaviors.html": {
    "href": "concepts/broker/behaviors.html",
    "title": "Broker behaviors pipeline | Silverback",
    "keywords": "Broker behaviors pipeline Silverback is built to be modular and most of its feature are plugged into the consumers and producers via some so-called behaviors. The inbound and outbound messages flow through this pipeline and each behavior take care of a specific task such as serialization, encryption, chunking, logging, etc. The <xref:Silverback.Messaging.Broker.Behaviors.IProducerBehavior> and <xref:Silverback.Messaging.Broker.Behaviors.IConsumerBehavior> are the interfaces used to build such behaviors. Note <xref:Silverback.Messaging.Broker.Behaviors.IProducerBehavior> and <xref:Silverback.Messaging.Broker.Behaviors.IConsumerBehavior> inherit the ISorted interface. It is therefore mandatory to specify the exact sort index of each behavior. Built-in producer behaviors This behaviors build the producer pipeline and contain the actual logic to properly serialize the messages according to the applied configuration. Name Index Description <xref:Silverback.Messaging.Diagnostics.ActivityProducerBehavior> 100 Starts an Activity and adds the tracing information to the message headers. <xref:Silverback.Messaging.Headers.HeadersWriterProducerBehavior> 200 Maps the properties decorated with the <xref:Silverback.Messaging.Messages.HeaderAttribute> to the message headers. <xref:Silverback.Messaging.Outbound.Enrichers.MessageEnricherProducerBehavior> 250 Invokes all the <xref:Silverback.Messaging.Outbound.Enrichers.IOutboundMessageEnricher> configured for to the endpoint. <xref:Silverback.Messaging.Broker.Behaviors.MessageIdInitializerProducerBehavior> 300 It ensures that an x-message-id header is always produced. BrokerKeyHeaderInitializer 400 Provided by the message broker implementation (e.g. <xref:Silverback.Messaging.Outbound.KafkaMessageKeyInitializerProducerBehavior> or RabbitRoutingKeyInitializerProducerBehavior ), sets the message key header that will be used by the <xref:Silverback.Messaging.Broker.IProducer> implementation to set the actual message key. <xref:Silverback.Messaging.BinaryFiles.BinaryFileHandlerProducerBehavior> 500 Switches to the <xref:Silverback.Messaging.BinaryFiles.BinaryFileMessageSerializer> if the message being produced implements the <xref:Silverback.Messaging.Messages.IBinaryFileMessage> interface. <xref:Silverback.Messaging.Serialization.SerializerProducerBehavior> 600 Serializes the message being produced using the configured <xref:Silverback.Messaging.Serialization.IMessageSerializer>. <xref:Silverback.Messaging.Encryption.EncryptorProducerBehavior> 700 Encrypts the message according to the <xref:Silverback.Messaging.Encryption.EncryptionSettings>. <xref:Silverback.Messaging.Sequences.SequencerProducerBehavior> 800 Uses the available implementations of <xref:Silverback.Messaging.Sequences.ISequenceWriter> (e.g. <xref:Silverback.Messaging.Sequences.Chunking.ChunkSequenceWriter>) to set the proper headers and split the published message or messages set to create the sequences. <xref:Silverback.Messaging.Outbound.Routing.EndpointNameResolverProducerBehavior> 900 Resolves the actual target endpoint name for the message being published. <xref:Silverback.Messaging.Outbound.Routing.KafkaPartitionResolverProducerBehavior> 901 Resolves the actual target endpoint name for the message being published. <xref:Silverback.Messaging.Headers.CustomHeadersMapperProducerBehavior> 1000 Applies the custom header name mappings. Built-in consumer behaviors This behaviors are the foundation of the consumer pipeline and contain the actual logic to deserialize the incoming messages. Name Index Description <xref:Silverback.Messaging.Diagnostics.ActivityConsumerBehavior> 100 Starts an Activity with the tracing information from the message headers. <xref:Silverback.Messaging.Diagnostics.FatalExceptionLoggerConsumerBehavior> 200 Logs the unhandled exceptions thrown while processing the message. These exceptions are fatal since they will usually cause the consumer to stop. <xref:Silverback.Messaging.Headers.CustomHeadersMapperConsumerBehavior> 300 Applies the custom header name mappings. <xref:Silverback.Messaging.Inbound.Transaction.TransactionHandlerConsumerBehavior> 400 Handles the consumer transaction and applies the error policies. <xref:Silverback.Messaging.Sequences.RawSequencerConsumerBehavior> 500 Uses the available implementations of <xref:Silverback.Messaging.Sequences.ISequenceReader> (e.g. <xref:Silverback.Messaging.Sequences.Chunking.ChunkSequenceReader>) to assign the incoming message to the right sequence. <xref:Silverback.Messaging.Inbound.ExactlyOnce.ExactlyOnceGuardConsumerBehavior> 600 Uses the configured implementation of <xref:Silverback.Messaging.Inbound.ExactlyOnce.IExactlyOnceStrategy> to ensure that the message is processed only once. <xref:Silverback.Messaging.Encryption.DecryptorConsumerBehavior> 700 Decrypts the message according to the <xref:Silverback.Messaging.Encryption.EncryptionSettings>. <xref:Silverback.Messaging.BinaryFiles.BinaryFileHandlerProducerBehavior> 800 Switches to the <xref:Silverback.Messaging.BinaryFiles.BinaryFileMessageSerializer> if the message being consumed is a binary message (according to the x-message-type header. <xref:Silverback.Messaging.Serialization.DeserializerConsumerBehavior> 900 Deserializes the messages being consumed using the configured <xref:Silverback.Messaging.Serialization.IMessageSerializer>. <xref:Silverback.Messaging.Headers.HeadersReaderConsumerBehavior> 1000 Maps the headers with the properties decorated with the <xref:Silverback.Messaging.Messages.HeaderAttribute>. <xref:Silverback.Messaging.Sequences.SequencerConsumerBehavior> 1100 Uses the available implementations of <xref:Silverback.Messaging.Sequences.ISequenceReader> (e.g. <xref:Silverback.Messaging.Sequences.Batch.BatchSequenceReader>) to assign the incoming message to the right sequence. <xref:Silverback.Messaging.Inbound.PublisherConsumerBehavior> 2000 Publishes the consumed messages to the internal bus. Custom behaviors The behaviors can be used to implement cross-cutting concerns or add new features to Silverback. Custom IProducerBehavior example The following example demonstrate how to set a custom message header on each outbound message. Note The <xref:Silverback.Messaging.Broker.Behaviors.ProducerPipelineContext> and <xref:Silverback.Messaging.Broker.Behaviors.ConsumerPipelineContext> hold a reference to the IServiceProvider and can be used to resolve the needed services. The IServiceProvider in the <xref:Silverback.Messaging.Broker.Behaviors.ConsumerPipelineContext> can be either the root service provider or the scoped service provider for the processing of the consumed message (depending on the position of the behavior in the pipeline). Note The broker behaviors can be registered either as singleton or transient services. When registered as transient a new instance will be created per each producer or consumer. ProducerBehavior Startup public class CustomHeadersProducerBehavior : IProducerBehavior { public int SortIndex => 1000; public async Task HandleAsync( ProducerPipelineContext context, ProducerBehaviorHandler next) { context.Envelope.Headers.Add(\"generated-by\", \"silverback\"); await next(context); } } public class Startup { public void ConfigureServices(IServiceCollection services) { services .AddSilverback() .WithConnectionToMessageBroker(options => options .AddKafka()) .AddSingletonBrokerBehavior<CustomHeadersBehavior>(); } } Custom IConsumerBehavior example The following example demonstrate how to log the headers received with each inbound message. ConsumerBehavior Startup public class LogHeadersConsumerBehavior : IConsumerBehavior { private readonly ILogger<LogHeadersBehavior> _logger; public LogHeadersBehavior(ILogger<LogHeadersBehavior> logger) { _logger = logger; } public int SortIndex => 1000; public async Task HandleAsync( ConsumerPipelineContext context, ConsumerBehaviorHandler next) { foreach (var header in context.Envelope.Headers) { _logger.LogTrace( \"{Name}={Value}\", header.Name, header.Value); } await next(context); } } public class Startup { public void ConfigureServices(IServiceCollection services) { services .AddSilverback() .WithConnectionToMessageBroker(options => options .AddKafka()) .AddSingletonBrokerBehavior<LogHeadersBehavior>(); } } See also Behaviors"
  },
  "concepts/broker/binary-files.html": {
    "href": "concepts/broker/binary-files.html",
    "title": "Binary Files | Silverback",
    "keywords": "Binary Files Serializing a binary file (a stream or a byte array) using the regular <xref:Silverback.Messaging.Serialization.JsonMessageSerializer> would mean to encode it in base64 and convert it to a UTF-8 encoded byte array. Beside not being very elegant this approach may cause you some trouble when integrating with other systems expecting the raw file content. This procedure would also result in the transferred byte array to be approximately a 30% bigger than the file itself. In this page it's shown how to use an <xref:Silverback.Messaging.Messages.IBinaryFileMessage> to more efficiently transfer raw binary files. Producer configuration The <xref:Silverback.Messaging.Messages.IBinaryFileMessage> interface is meant to transfer files over the message broker and is natively supported by Silverback. This means that the raw file content will be transferred in its original form. For convenience the <xref:Silverback.Messaging.Messages.BinaryFileMessage> class already implements the <xref:Silverback.Messaging.Messages.IBinaryFileMessage> interface. This class exposes a ContentType property as well, resulting in the content-type header to be produced. EndpointsConfigurator (fluent) EndpointsConfigurator (legacy) Publisher public class MyEndpointsConfigurator : IEndpointsConfigurator { public void Configure(IEndpointsConfigurationBuilder builder) => builder .AddKafkaEndpoints(endpoints => endpoints .Configure(config => { config.BootstrapServers = \"PLAINTEXT://kafka:9092\"; }) .AddOutbound<IBinaryFileMessage>(endpoint => endpoint .ProduceTo(\"raw-files\"))); } public class MyEndpointsConfigurator : IEndpointsConfigurator { public void Configure(IEndpointsConfigurationBuilder builder) => builder .AddOutbound<IBinaryFileMessage>( new KafkaProducerEndpoint(\"inventory-events\") { Configuration = new KafkaProducerConfig { BootstrapServers = \"PLAINTEXT://kafka:9092\" } }); } public class FileTransferService { private readonly IPublisher _publisher; public FileTransferService(IPublisher publisher) { _publisher = publisher; } public async Task TransferFile(byte[] content, string contentType) { await _publihser.PublishAsync( new BinaryFileMessage(content, contentType)); } } Otherwise you can implement the interface yourself or extend the <xref:Silverback.Messaging.Messages.BinaryFileMessage> (e.g. to add some additional headers, as explained in the Message Headers section). EndpointsConfigurator (fluent) EndpointsConfigurator (legacy) Message Publisher public class MyEndpointsConfigurator : IEndpointsConfigurator { public void Configure(IEndpointsConfigurationBuilder builder) => builder .AddKafkaEndpoints(endpoints => endpoints .Configure(config => { config.BootstrapServers = \"PLAINTEXT://kafka:9092\"; }) .AddOutbound<IBinaryFileMessage>(endpoint => endpoint .ProduceTo(\"raw-files\"))); } public class MyEndpointsConfigurator : IEndpointsConfigurator { public void Configure(IEndpointsConfigurationBuilder builder) => builder .AddOutbound<IBinaryFileMessage>( new KafkaProducerEndpoint(\"raw-files\") { Configuration = new KafkaProducerConfig { BootstrapServers = \"PLAINTEXT://kafka:9092\" } }); } public class MyBinaryFileMessage : BinaryFileMessage { [Header(\"x-user-id\")] public Guid UserId { get; set; } } public class FileTransferService { private readonly IPublisher _publisher; public FileTransferService(IPublisher publisher) { _publisher = publisher; } public async Task TransferFile( byte[] content, string contentType, Guid userId) { await _publihser.PublishAsync( new MyBinaryFileMessage { Content = content, ContentType = contentType, UserId = userId }); } } Consumer configuration You don't need to do anything special to consume a binary file, if all necessary headers are in place (ensured by Silverback, if it was used to produce the message). The message will be wrapped again in a <xref:Silverback.Messaging.Messages.BinaryFileMessage> that can be subscribed like any other message. EndpointsConfigurator (fluent) EndpointsConfigurator (legacy) Subscriber public class MyEndpointsConfigurator : IEndpointsConfigurator { public void Configure(IEndpointsConfigurationBuilder builder) => builder .AddKafkaEndpoints(endpoints => endpoints .Configure(config => { config.BootstrapServers = \"PLAINTEXT://kafka:9092\"; }) .AddInbound(endpoint => endpoint .ConsumeFrom(\"raw-files\") .Configure(config => { config.GroupId = \"my-consumer\" })); } public class MyEndpointsConfigurator : IEndpointsConfigurator { public void Configure(IEndpointsConfigurationBuilder builder) => builder .AddInbound( new KafkaConsumerEndpoint(\"raw-files\") { Configuration = new KafkaConsumerConfig { BootstrapServers = \"PLAINTEXT://kafka:9092\" } }); } public class FileSubscriberService { public async Task OnFileReceived(IBinaryFileMessage message) { // ...your file handling logic... } } If the message wasn't produced by Silverback chances are that the message type header is not there. In that case you need to explicitly configure the <xref:Silverback.Messaging.BinaryFiles.BinaryFileMessageSerializer> in the inbound endpoint. EndpointsConfigurator (fluent) EndpointsConfigurator (legacy) Subscriber public class MyEndpointsConfigurator : IEndpointsConfigurator { public void Configure(IEndpointsConfigurationBuilder builder) => builder .AddKafkaEndpoints(endpoints => endpoints .Configure(config => { config.BootstrapServers = \"PLAINTEXT://kafka:9092\"; }) .AddInbound(endpoint => endpoint .ConsumeFrom(\"raw-files\") .ConsumeBinaryFiles() .Configure(config => { config.GroupId = \"my-consumer\" })); } public class MyEndpointsConfigurator : IEndpointsConfigurator { public void Configure(IEndpointsConfigurationBuilder builder) => builder .AddInbound( new KafkaConsumerEndpoint(\"raw-files\") { Configuration = new KafkaConsumerConfig { BootstrapServers = \"PLAINTEXT://kafka:9092\" } , Serializer = BinaryFileMessageSerializer.Default }); } public class FileSubscriberService { public async Task OnFileReceived(IBinaryFileMessage message) { // ...your file handling logic... } } If you need to read additional headers you can either extend the <xref:Silverback.Messaging.Messages.BinaryFileMessage> (suggested approach) or subscribe to an <xref:Silverback.Messaging.Messages.IInboundEnvelope`1> . The following snippet assumes that the files aren't being streamed by a Silverback producer, otherwise it wouldn't be necessary to explicitly set the serializer and the type would be inferred from the x-message-type header. EndpointsConfigurator (fluent) EndpointsConfigurator (legacy) Message Subscriber public class MyEndpointsConfigurator : IEndpointsConfigurator { public void Configure(IEndpointsConfigurationBuilder builder) => builder .AddKafkaEndpoints(endpoints => endpoints .Configure(config => { config.BootstrapServers = \"PLAINTEXT://kafka:9092\"; }) .AddInbound(endpoint => endpoint .ConsumeFrom(\"raw-files\") .ConsumeBinaryFiles(serializer => serializer.UseModel<MyBinaryFileMessage>())); } public class MyEndpointsConfigurator : IEndpointsConfigurator { public void Configure(IEndpointsConfigurationBuilder builder) => builder .AddOutbound<IBinaryFileMessage>( new KafkaProducerEndpoint(\"raw-files\") { Configuration = new KafkaProducerConfig { BootstrapServers = \"PLAINTEXT://kafka:9092\" }, Serializer = new BinaryFileMessageSerializer<MyBinaryFileMessage>() }); } public class MyBinaryFileMessage : BinaryFileMessage { [Header(\"x-user-id\")] public Guid UserId { get; set; } } public class FileSubscriberService { public async Task OnFileReceived(MyBinaryFileMessage message) { // ...your file handling logic... } } Samples Kafka - Files Streaming"
  },
  "concepts/broker/callbacks.html": {
    "href": "concepts/broker/callbacks.html",
    "title": "Broker Callbacks | Silverback",
    "keywords": "Broker Callbacks The callbacks are used to notify some events happening during the lifecycle of a message broker client. An interface has to be implemented by the callback handler that is then registered via the Add*BrokerCallbacksHandler methods. The only generic callback, invoked for any of the actual broker implementation is: <xref:Silverback.Messaging.Broker.Callbacks.IEndpointsConfiguredCallback> Some broker specific callbacks may be added by the specific broker implementation (see Kafka Events and MQTT Events ). Example In the following example an handler for the <xref:Silverback.Messaging.Broker.Callbacks.IEndpointsConfiguredCallback> is being registered. Startup EndpointsConfiguredCallbackHandler public class Startup { public void ConfigureServices(IServiceCollection services) { services .AddSilverback() .WithConnectionToMessageBroker(options => options .AddKafka()) .AddSingletonBrokerCallbacksHandler<EndpointsConfiguredCallbackHandler>(); } } public class EndpointsConfiguredCallbackHandler : IKafkaPartitionsAssignedCallback { public Task OnEndpointsConfiguredAsync() { // Perform some initialization logic, // e.g. create the missing topics } }"
  },
  "concepts/broker/chunking.html": {
    "href": "concepts/broker/chunking.html",
    "title": "Chunking | Silverback",
    "keywords": "Chunking Some message brokers like Apache Kafka are very efficient at handling huge amount of relatively small messages. In order to make the most out of it you may want to split your largest messages (e.g. containing binary data) into smaller chunks. Silverback can handle such scenario transparently, reassembling the message automatically in the consumer before pushing it to the internal bus. The messages are being split into small chunks. Producer configuration The producer endpoint can be configured to split the message into chunks by specifying their maximum size (in bytes). Fluent Legacy public class MyEndpointsConfigurator : IEndpointsConfigurator { public void Configure(IEndpointsConfigurationBuilder builder) => builder .AddKafkaEndpoints(endpoints => endpoints .Configure(config => { config.BootstrapServers = \"PLAINTEXT://kafka:9092\"; }) .AddOutbound<IIntegrationEvent>(endpoint => endpoint .ProduceTo(\"order-events\") .EnableChunking(500000) .ProduceToOutbox()); } public class MyEndpointsConfigurator : IEndpointsConfigurator { public void Configure(IEndpointsConfigurationBuilder builder) => builder .AddOutbound<IIntegrationEvent>( new KafkaProducerEndpoint(\"order-events\") { Configuration = new KafkaProducerConfig { BootstrapServers = \"PLAINTEXT://kafka:9092\" }, Chunk = new ChunkSettings { Size = 500000 }, Strategy = new OutboxProduceStrategy() }); } Important The chunks belonging to the same message must be contiguous. It is therefore recommended to have a single producer per endpoint or partition. If using Kafka see also Kafka Partitioning and Message Key . Consumer configuration No particular configuration is needed in the consumer side. Silverback will automatically recognize the chunks sequence by its headers and transparently reassemble the message. With Silverback 3.0.0 the consumer pipeline has been rewritten completely to handle this scenario in a streaming way, processing each chunk directly and applying the behaviors (such as the deserializer) on the fly. The entire original message is never stored anywhere, therefore this approach is suitable also for very large payloads. Important The chunks belonging to the same message must be contiguous. It is therefore recommended to have a single producer per endpoint or partition. If using Kafka see also Kafka Partitioning and Message Key . Incomplete sequences Some chunks sequences may be incomplete because either the producer failed to publish all chunks or the consumer started consuming from the middle of a sequence. In both cases Silverback will silently ignore the incomplete sequences and log a warning. Limitations As mentioned already, the chunks have to be written to the same partition and have to be contiguous. This is by design. Another limitation is that the <xref:Silverback.Messaging.Inbound.ErrorHandling.MoveMessageErrorPolicy> is currently unable to move a sequence and is therefore unusable with chunked messages. This may be fixed in a future release. Please open an issue on GitHub if this is important for your use case. Headers Some headers are used to describe the chunks sequence. See Message Headers for details. Samples Kafka - Files Streaming"
  },
  "concepts/broker/connecting.html": {
    "href": "concepts/broker/connecting.html",
    "title": "Connecting to a Message Broker | Silverback",
    "keywords": "Connecting to a Message Broker To connect Silverback to a message broker we need a reference to Silverback.Integration , plus the concrete implementation ( Silverback.Integration.Kafka , Silverback.Integration.MQTT , Silverback.Integration.RabbitMQ , etc.). We can then add the broker to the DI and configure the connected endpoints. Sample configuration The following example is very basic and there are of course many more configurations and possibilities. Some more details are given in the dedicated Outbound Endpoint and Inbound Endpoint sections. The basic concepts: WithConnectionToMessageBroker registers the services necessary to connect to a message broker AddKafka , AddMqtt , AddRabbit , etc. register the message broker implementation(s) AddEndpointsConfigurator is used to outsource the endpoints configuration into a separate class implementing the <xref:Silverback.Messaging.Configuration.IEndpointsConfigurator> interface (of course multiple configurators can be registered) AddInbound is used to automatically relay the incoming messages to the internal bus and they can therefore be subscribed as seen in the previous chapters AddOutbound works the other way around and subscribes to the internal bus to forward the integration messages to the message broker More complex and complete samples can be found in the Samples section. Basic configuration The following sample demonstrates how to setup some inbound and outbound endpoints against the built-in message brokers (Apache Kafka, MQTT or RabbitMQ). Apache Kafka Startup EndpointsConfigurator public class Startup { public void ConfigureServices(IServiceCollection services) { services .AddSilverback() .WithConnectionToMessageBroker(options => options .AddKafka()) .AddEndpointsConfigurator<MyEndpointsConfigurator>(); } } public class MyEndpointsConfigurator : IEndpointsConfigurator { public void Configure(IEndpointsConfigurationBuilder builder) => builder .AddKafkaEndpoints(endpoints => endpoints .Configure(config => { config.BootstrapServers = \"PLAINTEXT://kafka:9092\"; }) .AddInbound(endpoint => endpoint .ConsumeFrom(\"basket-events\") .Configure(config => { config.GroupId = \"order-service\"; })) .AddInbound(endpoint => endpoint .ConsumeFrom(\"payment-events\") .Configure(config => { confing.GroupId = \"order-service\" })) .AddOutbound<IIntegrationEvent>(endpoint => endpoint .ProduceTo(\"order-events\"))); } MQTT Startup EndpointsConfigurator public class Startup { public void ConfigureServices(IServiceCollection services) { services .AddSilverback() .WithConnectionToMessageBroker(options => options .AddMqtt()) .AddEndpointsConfigurator<MyEndpointsConfigurator>(); } } public class MyEndpointsConfigurator : IEndpointsConfigurator { public void Configure(IEndpointsConfigurationBuilder builder) => builder .AddMqttEndpoints(endpoints => endpoints .Configure( config => config .WithClientId(\"order-service\") .ConnectViaTcp(\"localhost\") .SendLastWillMessage( lastWill => lastWill .Message(new TestamentMessage()) .ProduceTo(\"testaments\"))) .AddInbound(endpoint => endpoint .ConsumeFrom(\"basket-events\") .WithQualityOfServiceLevel( MqttQualityOfServiceLevel.AtLeastOnce)) .AddInbound(endpoint => endpoint .ConsumeFrom(\"payment-events\") .WithQualityOfServiceLevel( MqttQualityOfServiceLevel.AtLeastOnce)) .AddOutbound<IIntegrationEvent>(endpoint => endpoint .ProduceTo(\"order-events\") .WithQualityOfServiceLevel( MqttQualityOfServiceLevel.AtLeastOnce) .Retain())); } Important Silverback uses by default the v5 of the MQTT protocol, since it supports the user properties (headers). You can of course configure the client to use an older version but some Silverback functionalities (relying on message headers) might not work. RabbitMQ Startup EndpointsConfigurator public class Startup { public void ConfigureServices(IServiceCollection services) { services .AddSilverback() .WithConnectionToMessageBroker(options => options .AddRabbit()) .AddEndpointsConfigurator<MyEndpointsConfigurator>(); } } public class MyEndpointsConfigurator : IEndpointsConfigurator { public void Configure(IEndpointsConfigurationBuilder builder) { builder .AddInbound( new RabbitExchangeConsumerEndpoint(\"basket-events\") { Connection = new RabbitConnectionConfig { HostName = \"localhost\", UserName = \"guest\", Password = \"guest\", }, Exchange = new RabbitExchangeConfig { IsDurable = true, IsAutoDeleteEnabled = false, ExchangeType = ExchangeType.Fanout }, QueueName = \"basket-events-order-service-queue\", Queue = new RabbitQueueConfig { IsDurable = true, IsExclusive = true, IsAutoDeleteEnabled = false } }) .AddInbound( new RabbitExchangeConsumerEndpoint(\"payment-events\") { Connection = new RabbitConnectionConfig { HostName = \"localhost\", UserName = \"guest\", Password = \"guest\", }, Exchange = new RabbitExchangeConfig { IsDurable = true, IsAutoDeleteEnabled = false, ExchangeType = ExchangeType.Fanout }, QueueName = \"payment-events-order-service-queue\", Queue = new RabbitQueueConfig { IsDurable = true, IsExclusive = true, IsAutoDeleteEnabled = false } }) .AddOutbound<IIntegrationEvent>( new RabbitExchangeProducerEndpoint(\"order-events\") { Connection = new RabbitConnectionConfig { HostName = \"localhost\", UserName = \"guest\", Password = \"guest\" }, Exchange = new RabbitExchangeConfig { IsDurable = true, IsAutoDeleteEnabled = false, ExchangeType = ExchangeType.Fanout } }); } } Tip All <xref:Silverback.Messaging.Configuration.IEndpointsConfigurator> implementations are registered as scoped services. Multiple implementations can be registered to split the configuration and of course dependencies (such as IOption or a DbContext ) can be injected to load the configuration variables. Important Starting from version 3.0.0 the broker(s) will be connected and all consumers started automatically at startup, unless explicitly disabled (see the Connection modes chapter for details). Inline endpoints configuration The preferred and suggested way to configure the message broker endpoints is using the <xref:Silverback.Messaging.Configuration.IEndpointsConfigurator> but you can use AddEndpoints (or AddKafkaEndpoints etc.) directly and configure everything inline. public class Startup { public void ConfigureServices(IServiceCollection services) { services .AddSilverback() .WithConnectionToMessageBroker(options => options .AddKafka()) .AddKafkaEndpoints(endpoints => endpoints .Configure(config => { config.BootstrapServers = \"PLAINTEXT://kafka:9092\"; }) .AddInbound(...) .AddOutbound<IIntegrationEvent>(...)); } } Multiple brokers It is possible to use multiple message broker implementation together in the same application. The following sample demonstrates how to consume from both Apache Kafka and RabbitMQ. Startup EndpointsConfigurator public class Startup { public void ConfigureServices(IServiceCollection services) { services .AddSilverback() .WithConnectionToMessageBroker(options => options .AddKafka() .AddRabbit()) .AddEndpointsConfigurator<MyEndpointsConfigurator>(); } } public class MyEndpointsConfigurator : IEndpointsConfigurator { public void Configure(IEndpointsConfigurationBuilder builder) { builder .AddKafkaEndpoints(endpoints => endpoints .Configure(config => { config.BootstrapServers = \"PLAINTEXT://kafka:9092\"; }) .AddInbound(...) .AddOutbound<IIntegrationEvent>(...)) .AddInbound( new RabbitExchangeConsumerEndpoint(\"rabbit-events\") { ... }); } } Connection modes You may not want to connect your broker immediately. In the following example is shown how to postpone the automatic connection after the application startup. public class Startup { public void ConfigureServices(IServiceCollection services) { services .AddSilverback() .WithConnectionToMessageBroker(options => options .AddKafka() .WithConnectionOptions(new BrokerConnectionOptions { Mode = BrokerConnectionMode.AfterStartup, RetryInterval = TimeSpan.FromMinutes(5) })) .AddEndpointsConfigurator<MyEndpointsConfigurator>(); } } But it's also possible to completely disable the automatic connection and manually perform it. Startup Service public class Startup { public void ConfigureServices(IServiceCollection services) { services .AddSilverback() .WithConnectionToMessageBroker(options => options .AddKafka() .WithConnectionOptions(new BrokerConnectionOptions { Mode = BrokerConnectionMode.Manual })) .AddEndpointsConfigurator<MyEndpointsConfigurator>(); } } public class BrokerConnectionService { private readonly IBroker _broker; public BrokerConnectionService(IBroker broker) { _broker = broker; } public async ConnectAsync() { broker.ConnectAsync(); } } Tip See the <xref:Silverback.Messaging.Configuration.BrokerConnectionOptions> documentation for details about the different options. Note Use <xref:Silverback.Messaging.Broker.IBrokerCollection> instead of <xref:Silverback.Messaging.Broker.IBroker> when multiple broker implementations are used. Important If your application is not running using an IHost ( GenericHost or WebHost , like in a normal ASP.NET Core application) you always need to manually connect it as shown in the second example above. Graceful shutdown It is important to properly close the consumers using the DisconnectAsync method before exiting. The offsets have to be committed and the broker has to be notified (it will then proceed to reassign the partitions as needed). Starting from version 3.0.0 this is done automatically (if your application is running using an IHost ( GenericHost or WebHost , like in a normal ASP.NET Core application). Health Monitoring The Silverback.Integration.HealthChecks package contains some extensions for Microsoft.Extensions.Diagnostics.HealthChecks that can be used to monitor the connection to the message broker. Currently, two checks exists: AddOutboundEndpointsCheck : Adds an health check that sends a ping message to all the outbound endpoints. AddOutboxCheck : Adds an health check that monitors the outbound queue (outbox table), verifying that the messages are being processed. AddConsumersCheck : Adds a health check that verifies that all consumers are connected. The usage is very simple, you just need to configure the checks in the Startup.cs, as shown in the following example. public class Startup { public void ConfigureServices(IServiceCollection services) { services .AddHealthChecks() .AddOutboundEndpointsCheck() .AddOutboundQueueCheck() .AddConsumersCheck(); } public void Configure(IApplicationBuilder app) { app.UseHealthChecks(\"/health\"); } } Consumer management API The consumer exposes some information and statistics that can be used to programmatically check the consumer status (see <xref:Silverback.Messaging.Broker.IConsumer#Silverback_Messaging_Broker_IConsumer_StatusInfo>). A consumer can also be connected, started, stopped and disconnected at will. The following example shows a sample service that is used to monitor the total number of consumed message and restart the faulted consumers (the consumers get disconnected when an unhandled exception is thrown while processing the consumed message). public class ConsumerManagementService { private readonly IBrokerCollection _brokers; public ConsumerManagementService(IBrokerCollection brokers) { _brokers = brokers; } public int GetTotalConsumedMessages() { int totalCount = 0; foreach (var broker in _brokers) { foreach (var consumer in broker.Consumers) { totalCount += consumer.StatusInfo.ConsumedMessagesCount; } } } public void RestartDisconnectedConsumers() { foreach (var broker in _brokers) { if (!broker.IsConnected) continue; foreach (var consumer in broker.Consumers) { if (consumer.StatusInfo.Status == ConsumerStatus.Disconnected) { consumer.Connect(); } } } } } Samples All"
  },
  "concepts/broker/encryption.html": {
    "href": "concepts/broker/encryption.html",
    "title": "Encryption | Silverback",
    "keywords": "Encryption The end-to-end message encryption in Silverback is handled transparently in the producer and consumer and works independently from the used serializer or other features like chunking . The messages are transparently encrypted and decrypted. Symmetric encryption Enabling the end-to-end encryption using a symmetric algorithm just require an extra configuration in the endpoint. Fluent Legacy public class MyEndpointsConfigurator : IEndpointsConfigurator { public void Configure(IEndpointsConfigurationBuilder builder) => builder .AddKafkaEndpoints(endpoints => endpoints .Configure(config => { config.BootstrapServers = \"PLAINTEXT://kafka:9092\"; }) .AddOutbound<InventoryEvent>(endpoint => endpoint .ProduceTo(\"inventory-events\") .EncryptUsingAes(encryptionKey)) .AddInbound(endpoint => endpoint .ConsumeFrom(\"order-events\") .Configure(config => { config.GroupId = \"my-consumer\"; }) .DecryptUsingAes(encryptionKey))); } public class MyEndpointsConfigurator : IEndpointsConfigurator { public void Configure(IEndpointsConfigurationBuilder builder) => builder .AddOutbound<InventoryEvent>( new KafkaProducerEndpoint(\"inventory-events\") { Configuration = new KafkaProducerConfig { BootstrapServers = \"PLAINTEXT://kafka:9092\" }, Encryption = new SymmetricEncryptionSettings { AlgorithmName = \"AES\", Key = encryptionKey } }) .AddInbound( new KafkaConsumerEndpoint(\"order-events\") { Configuration = new KafkaConsumerConfig { BootstrapServers = \"PLAINTEXT://kafka:9092\", GroupId = \"my-consumer\" }, Encryption = new SymmetricEncryptionSettings { AlgorithmName = \"AES\", Key = encryptionKey } }); } The <xref:Silverback.Messaging.Encryption.SymmetricEncryptionSettings> class encapsulates all common settings of a symmetric algorithm (block size, initialization vector, ...). The AlgorithmName is used to load the algorithm implementation using the SymmetricAlgorithm.Create(string) method. Refer to the SymmetricAlgorithm class documentation to see which implementations are available in .net core are. Silverback uses Aes by default. Random initialization vector If no static initialization vector is provided, a random one is automatically generated per each message and prepended to the actual encrypted message. The consumer will automatically extract and use it. It is recommended to stick to this default behavior, for increased security. Ket rotation You can smoothly rotate the key being used to encrypt the messages. In the outbound endpoint you can specify the current key identifier to be submitted as header, while in the inbound endpoint a custom function can be used to provide the correct key, depending on the value in the header. This simple mechanism allows to consume messages that were encrypted using different keys, enabling key rotation and supporting a rolling update of the producers. Fluent Legacy public class MyEndpointsConfigurator : IEndpointsConfigurator { public void Configure(IEndpointsConfigurationBuilder builder) => builder .AddKafkaEndpoints(endpoints => endpoints .Configure(config => { config.BootstrapServers = \"PLAINTEXT://kafka:9092\"; }) .AddOutbound<InventoryEvent>(endpoint => endpoint .ProduceTo(\"inventory-events\") .EncryptUsingAes(encryptionKey, \"key1\")) .AddInbound(endpoint => endpoint .ConsumeFrom(\"order-events\") .Configure(config => { config.GroupId = \"my-consumer\"; }) .DecryptUsingAes(keyIdentifier => { switch (keyIdentifier) { case \"key1\": return encryptionKey1; default: return encryptionKey2; } }))); } public class MyEndpointsConfigurator : IEndpointsConfigurator { public void Configure(IEndpointsConfigurationBuilder builder) => builder .AddOutbound<InventoryEvent>( new KafkaProducerEndpoint(\"inventory-events\") { Configuration = new KafkaProducerConfig { BootstrapServers = \"PLAINTEXT://kafka:9092\" }, Encryption = new SymmetricEncryptionSettings { AlgorithmName = \"AES\", KeyProvider = encryptionKey, KeyIdentifier = \"key1\" } }) .AddInbound( new KafkaConsumerEndpoint(\"order-events\") { Configuration = new KafkaConsumerConfig { BootstrapServers = \"PLAINTEXT://kafka:9092\", GroupId = \"my-consumer\" }, Encryption = new SymmetricEncryptionSettings { AlgorithmName = \"AES\", KeyProvider = keyIdentifier => { switch (keyIdentifier) { case \"key1\": return encryptionKey1; default: return encryptionKey2; } } } }); }"
  },
  "concepts/broker/headers.html": {
    "href": "concepts/broker/headers.html",
    "title": "Message Headers | Silverback",
    "keywords": "Message Headers Custom headers There are multiple ways to add custom headers to an outbound message: adding an enricher to the <xref:Silverback.Messaging.IProducerEndpoint> annotating some properties with the <xref:Silverback.Messaging.Messages.HeaderAttribute>, as shown in the next chapter. using a custom IBehavior or <xref:Silverback.Messaging.Broker.Behaviors.IProducerBehavior> can be implemented, as shown in the Behaviors and Broker behaviors pipeline sections. Warning Some message broker implementations might not support headers and Silverback doesn't currently provide any workaround, thus the headers will simply be ignored. Using enrichers Fluent Legacy public class MyEndpointsConfigurator : IEndpointsConfigurator { public void Configure(IEndpointsConfigurationBuilder builder) => builder .AddKafkaEndpoints(endpoints => endpoints .Configure(config => { config.BootstrapServers = \"PLAINTEXT://kafka:9092\"; }) .AddOutbound<InventoryEvent>(endpoint => endpoint .ProduceTo(\"inventory-events\") .AddHeader( \"x-my-header\", \"static value\") .AddHeader<InventoryEvent>( \"x-product-id\", envelope => envelope.Message?.ProductId))); } public class MyEndpointsConfigurator : IEndpointsConfigurator { public void Configure(IEndpointsConfigurationBuilder builder) => builder .AddOutbound<InventoryEvent>( new KafkaProducerEndpoint(\"inventory-events\") { Configuration = new KafkaProducerConfig { BootstrapServers = \"PLAINTEXT://kafka:9092\" }, MessageEnrichers = new List<IOutboundMessageEnricher> { new GenericOutboundHeadersEnricher( \"x-my-header\", \"static value\"), new GenericOutboundHeadersEnricher<InventoryEvent>( \"x-product-id\", envelope => envelope.Message?.ProductId) } }); } Using HeaderAttribute The <xref:Silverback.Messaging.Messages.HeaderAttribute> usage is very simple: you just have to decorate the properties you want to publish as headers and specify a name for the header. The headers value will also automatically be mapped back to the property upon consuming if the property declares a setter. using Silverback.Messaging.Messages; namespace Sample { public class OrderCreatedEvent { public List<LineItems> Items { get; set; } [Header(\"x-order-type\", PublishDefaultValue = true)] [JsonIgnore] public OrderType OrderType { get; set; } [Header(\"x-books-order\")] public bool ContainsBooks => Items.Any(item => item.Type == \"book\") [Header(\"x-dvd-order\")] public bool ContainsDvd => Items.Any(item => item.Type == \"dvd\") } } Note The PublishDefaultValue boolean property defines whether the header has to be published even if the property is set to the default value for its data type. The default is false . Note that the JsonIgnoreAttribute can be used to prevent the same properties to be serialized in the JSON body, when using the <xref:Silverback.Messaging.Serialization.JsonMessageSerializer>. Important Only the message type will be scanned, therefore the properties decorated with the <xref:Silverback.Messaging.Messages.HeaderAttribute> must be in the root of the message object. Default headers Silverback will add some headers to the produced messages. They may vary depending on the scenario. Here is the list of the default headers that may be sent. Header Key Description x-message-id The message identifier . x-message-type The assembly qualified name of the message type. Used by the default <xref:Silverback.Messaging.Serialization.JsonMessageSerializer>. x-failed-attempts If an exception if thrown the failed attempts will be incremented and stored as header. This is necessary for the error policies to work. x-source-endpoint This will be set by the Move error policy and will contain the name of the endpoint the failed message is being moved from. x-chunk-index The message chunk index, used when chunking is enabled. x-chunk-count The total number of chunks the message was split into, used when chunking is enabled. x-chunk-last A boolean value indicating whether the message is the last one of a chunks sequence, used when chunking is enabled. x-first-chunk-offset The <xref:Silverback.Messaging.Broker.IBrokerMessageOffset> value of the first chunk of the same message, used when chunking is enabled. traceparent Used for distributed tracing. It is set by the <xref:Silverback.Messaging.Broker.IProducer> using the current Activity.Id . The <xref:Silverback.Messaging.Broker.IConsumer> uses it's value to set the Activity.ParentId . Note that an Activity is automatically started by the default <xref:Silverback.Messaging.Broker.IProducer> implementation. The header is implemented according to the W3C Trace Context proposal . tracestate Used for distributed tracing. It corresponds to the Activity.TraceStateString . The header is implemented according to the W3C Trace Context proposal . tracebaggage Used for distributed tracing. It corresponds to the string representation of the Activity.Baggage dictionary. This is not part of the w3c standard. content-type The content type of the binary file , used when producing or consuming an <xref:Silverback.Messaging.Messages.IBinaryFileMessage>. x-failure-reason The header that will be set by the <xref:Silverback.Messaging.Inbound.ErrorHandling.MoveMessageErrorPolicy> and will contain the reason why the message failed to be processed. Kafka specific Header Key Description x-kafka-message-key The header that will be filled with the key of the message consumed from Kafka. x-kafka-message-timestamp The header that will be filled with the timestamp of the message consumed from Kafka. x-source-consumer-group-id The header that will be set by the <xref:Silverback.Messaging.Inbound.ErrorHandling.MoveMessageErrorPolicy> and will contain the GroupId the consumer that consumed the message that failed to be processed. x-source-topic The header that will be set by the <xref:Silverback.Messaging.Inbound.ErrorHandling.MoveMessageErrorPolicy> and will contain the source topic of the message that failed to be processed. x-source-partition The header that will be set by the <xref:Silverback.Messaging.Inbound.ErrorHandling.MoveMessageErrorPolicy> and will contain the source partition of the message that failed to be processed. x-source-offset The header that will be set by the <xref:Silverback.Messaging.Inbound.ErrorHandling.MoveMessageErrorPolicy> and will contain the offset of the message that failed to be processed. x-source-timestamp The header that will be set by the <xref:Silverback.Messaging.Inbound.ErrorHandling.MoveMessageErrorPolicy> and will contain the timestamp of the message that failed to be processed. The static classes <xref:Silverback.Messaging.Messages.DefaultMessageHeaders> and <xref:Silverback.Messaging.Messages.KafkaMessageHeaders> contain all default header names constants. Customizing header names The default header names can be overridden using the WithCustomHeaderName configuration method. public class Startup { public void ConfigureServices(IServiceCollection services) { services .AddSilverback() .WithConnectionToMessageBroker(options => options .AddKafka()) .AddEndpointsConfigurator<MyEndpointsConfigurator>() .WithCustomHeaderName(DefaultMessageHeaders.ChunkId, \"x-ch-id\") .WithCustomHeaderName(DefaultMessageHeaders.ChunksCount, \"x-ch-cnt\")); } }"
  },
  "concepts/broker/inbound.html": {
    "href": "concepts/broker/inbound.html",
    "title": "Inbound Endpoint | Silverback",
    "keywords": "Inbound Endpoint An inbound endpoint is used to configure Silverback to automatically consume a topic/queue and relay the messages to the internal bus. If no exception is thrown by the subscribers, the message is acknowledged and the next one is consumed. The endpoint object identifies the topic/queue that is being connected and the client configuration, such the connection options. The endpoint object is therefore very specific and every broker type will define it's own implementation of IConsumerEndpoint . The options in the endpoint object are also used to tweak the Silverback behavior (e.g. the deserialization ) and to enable additional features such as batch processing , decryption , etc. Note Silverback abstracts the message broker completely and the messages are automatically acknowledged if the subscribers complete without throwing an exception. Apache Kafka The <xref:Silverback.Messaging.KafkaConsumerEndpoint> is defined by Silverback.Integration.Kafka and is used to declare an inbound endpoint connected to Apache Kafka. Fluent (preferred) Legacy public class MyEndpointsConfigurator : IEndpointsConfigurator { public void Configure(IEndpointsConfigurationBuilder builder) => builder .AddKafkaEndpoints(endpoints => endpoints .Configure(config => { config.BootstrapServers = \"PLAINTEXT://kafka:9092\"; }) .AddInbound(endpoint => endpoint .ConsumeFrom(\"order-events\", \"inventory-events\") .Configure(config => { config.GroupId = \"my-consumer\"; config.AutoOffsetReset = AutoOffsetResetType.Earliest; } .OnError(policy => policy.Retry(5)))); } public class MyEndpointsConfigurator : IEndpointsConfigurator { public void Configure(IEndpointsConfigurationBuilder builder) => builder .AddInbound( new KafkaConsumerEndpoint( \"order-events\", \"inventory-events\") { Configuration = new KafkaConsumerConfig { BootstrapServers = \"PLAINTEXT://kafka:9092\", GroupId = \"my-consumer\", AutoOffsetReset = AutoOffsetResetType.Earliest }, ErrorPolicy = new RetryErrorPolicy().MaxFailedAttempts(5) }); } Note You can decide whether to use one consumer per topic or subscribe multiple topics with the same consumer (passing multiple topic names in the endpoint constructor, as shown in the example above). There are advantages and disadvantages of both solutions and the best choice really depends on your specific requirements, the amount of messages being produced, etc. Anyway the main difference is that when subscribing multiple topics you will still consume one message after the other but they will simply be interleaved (this may or may not be an issue, it depends) and on the other hand each consumer will use some resources, so creating multiple consumers will result in a bigger overhead. Note For a more in-depth documentation about the Kafka client configuration refer also to the confluent-kafka-dotnet documentation . MQTT The <xref:Silverback.Messaging.MqttConsumerEndpoint> is defined by Silverback.Integration.MQTT and is used to declare an inbound endpoint connected to an MQTT broker. Fluent (preferred) Legacy public class MyEndpointsConfigurator : IEndpointsConfigurator { public void Configure(IEndpointsConfigurationBuilder builder) => builder .AddMqttEndpoints(endpoints => endpoints .Configure( config => config .WithClientId(\"order-service\") .ConnectViaTcp(\"localhost\") .SendLastWillMessage( lastWill => lastWill .Message(new TestamentMessage()) .ProduceTo(\"testaments\"))) .AddInbound(endpoint => endpoint .ConsumeFrom(\"order-events\", \"inventory-events\") .WithQualityOfServiceLevel( MqttQualityOfServiceLevel.AtLeastOnce) .OnError(policy => policy.Retry(5)))); } public class MyEndpointsConfigurator : IEndpointsConfigurator { public void Configure(IEndpointsConfigurationBuilder builder) => builder .AddInbound( new MqttConsumerEndpoint( \"order-events\", \"inventory-events\") { Configuration = { ClientId = \"order-service\", ChannelOptions = new MqttClientTcpOptions { Server = \"localhost\" }, WillMessage = new MqttApplicationMessage() { ... } }, QualityOfServiceLevel = MqttQualityOfServiceLevel.AtLeastOnce ErrorPolicy = new RetryErrorPolicy().MaxFailedAttempts(5) }); } Note It doesn't matter how you configure the inbound and outbound endpoints, a single client will be created as long as all endpoints match the exact same configuration. (Using a slightly different configuration for the same client it will cause an exception to be thrown when validating the endpoints configuration.) Note For a more in-depth documentation about the MQTT client configuration refer also to the MQTTNet documentation . RabbitMQ Silverback.Integration.RabbitMQ is a bit more intricate and uses 2 different classes to specify an endpoint that connects to a queue ( RabbitQueueConsumerEndpoint ) or directly to an exchange ( RabbitExchangeConsumerEndpoint ). public class MyEndpointsConfigurator : IEndpointsConfigurator { public void Configure(IEndpointsConfigurationBuilder builder) => builder .AddInbound( new RabbitQueueConsumerEndpoint(\"inventory-commands-queue\") { Connection = new RabbitConnectionConfig { HostName = \"localhost\", UserName = \"guest\", Password = \"guest\" }, Queue = new RabbitQueueConfig { IsDurable = true, IsExclusive = false, IsAutoDeleteEnabled = false } }) .AddInbound( new RabbitExchangeConsumerEndpoint(\"order-events\") { Connection = new RabbitConnectionConfig { HostName = \"localhost\", UserName = \"guest\", Password = \"guest\" }, Exchange = new RabbitExchangeConfig { IsDurable = true, IsAutoDeleteEnabled = false, ExchangeType = ExchangeType.Fanout }, QueueName = \"my-consumer-group\", Queue = new RabbitQueueConfig { IsDurable = true, IsExclusive = false, IsAutoDeleteEnabled = false } }); } Note For a more in-depth documentation about the RabbitMQ configuration refer to the RabbitMQ tutorials and documentation . Error handling If an exceptions is thrown by the methods consuming the incoming messages (subscribers) the consumer will stop, unless some error policies are defined. The built-in policies are: <xref:Silverback.Messaging.Inbound.ErrorHandling.StopConsumerErrorPolicy> (default) <xref:Silverback.Messaging.Inbound.ErrorHandling.SkipMessageErrorPolicy> <xref:Silverback.Messaging.Inbound.ErrorHandling.RetryErrorPolicy> <xref:Silverback.Messaging.Inbound.ErrorHandling.MoveMessageErrorPolicy> <xref:Silverback.Messaging.Inbound.ErrorHandling.ErrorPolicyChain> Fluent Legacy public class MyEndpointsConfigurator : IEndpointsConfigurator { public void Configure(IEndpointsConfigurationBuilder builder) => builder .AddKafkaEndpoints(endpoints => endpoints .Configure(config => { config.BootstrapServers = \"PLAINTEXT://kafka:9092\"; }) .AddInbound(endpoint => endpoint .ConsumeFrom(\"order-events\", \"inventory-events\") .Configure(config => { config.GroupId = \"my-consumer\"; config.AutoOffsetReset = AutoOffsetResetType.Earliest; }) .OnError(policy => policy .Retry(3, TimeSpan.FromSeconds(1)) .ThenSkip()))); } public class MyEndpointsConfigurator : IEndpointsConfigurator { public void Configure(IEndpointsConfigurationBuilder builder) => builder .AddInbound( new KafkaConsumerEndpoint( \"order-events\", \"inventory-events\") { Configuration = new KafkaConsumerConfig { BootstrapServers = \"PLAINTEXT://kafka:9092\", GroupId = \"my-consumer\", AutoOffsetReset = AutoOffsetResetType.Earliest }, ErrorPolicy = new ErrorPolicyChain( new RetryErrorPolicy().MaxFailedAttempts(5), new SkipErrorPolicy()) }); } Important If the processing still fails after the last policy is applied the exception will be returned to the consumer, causing it to stop. Important The number of attempts are tracked according to the message id header . A message id must be provided in order for the MaxFailedAttempts mechanism to work. This is ensured by the Silverback producer but might not be the case when consuming messages coming from other sources. Some message broker implementations might transparently cope with the missing message id header and derive it from other identifiers (e.g. the kafka message key) but it's not automatically guaranteed that they will always be unique. You should carefully check that before relying on this feature. Important The <xref:Silverback.Messaging.Inbound.ErrorHandling.RetryErrorPolicy> will prevent the message broker to be polled for the duration of the configured delay, which could lead to a timeout. With Kafka you should for example set the max.poll.interval.ms settings to an higher value. Apply rules Use ApplyTo and Exclude methods to decide which exceptions must be handled by the error policy or take advantage of ApplyWhen to specify a custom apply rule. .OnError(policy => policy .MoveToKafkaTopic( moveEndpoint => moveEndpoint.ProduceTo(\"some-other-topic\"), movePolicy => movePolicy .ApplyTo<MyException>() .ApplyWhen((msg, ex) => msg.Xy == myValue)) .ThenSkip()); public class MyEndpointsConfigurator : IEndpointsConfigurator { public void Configure(IEndpointsConfigurationBuilder builder) => builder .AddKafkaEndpoints(endpoints => endpoints .Configure(config => { config.BootstrapServers = \"PLAINTEXT://kafka:9092\"; }) .AddInbound(endpoint => endpoint .ConsumeFrom(\"order-events\", \"inventory-events\") .Configure(config => { config.GroupId = \"my-consumer\"; }) .OnError(policy => policy .MoveToKafkaTopic( moveEndpoint => moveEndpoint.ProduceTo(\"some-other-topic\"), movePolicy => movePolicy .ApplyTo<MyException>() .ApplyWhen((msg, ex) => msg.Xy == myValue)) .ThenSkip()))); } Publishing events Messages can be published when a policy is applied, in order to execute custom code. EndpointsConfigurator Event Handler public class MyEndpointsConfigurator : IEndpointsConfigurator { public void Configure(IEndpointsConfigurationBuilder builder) => builder .AddKafkaEndpoints(endpoints => endpoints .Configure(config => { config.BootstrapServers = \"PLAINTEXT://kafka:9092\"; }) .AddInbound(endpoint => endpoint .ConsumeFrom(\"order-events\", \"inventory-events\") .Configure(config => { config.GroupId = \"my-consumer\"; }) .OnError(policy => policy .Retry(3, TimeSpan.FromSeconds(1)) .ThenSkip(skipPolicy => skipPolicy .Publish(msg => new ProcessingFailedEvent(msg)))))); } public void OnProcessingFailed(ProcessingFailedEvent @event) { _processingStatusService.SetFailed(@event.Message.Id); _mailService.SendNotification(\"Failed to process message!\"); } Batch processing In some scenario, when having to deal with huge amounts of messages, processing each one of them on its own isn't the most efficient approach. Batch processing allow to process an arbitrary number of unrelated messages as a single unit of work. The messages are processed in batches. Refer to the <xref:Silverback.Messaging.Sequences.Batch.BatchSettings> documentation for details about the configuration. The batch can be subscribed either as IEnumerable , IAsyncEnumerable or IMessageStreamEnumerable<TMessage> . See also Streaming for details. EndpointsConfigurator (fluent) EndpointsConfigurator (legacy) Subscriber public class MyEndpointsConfigurator : IEndpointsConfigurator { public void Configure(IEndpointsConfigurationBuilder builder) => builder .AddKafkaEndpoints(endpoints => endpoints .Configure(config => { config.BootstrapServers = \"PLAINTEXT://kafka:9092\"; }) .AddInbound(endpoint => endpoint .ConsumeFrom(\"inventory-events\") .Configure(config => { config.GroupId = \"my-consumer\"; }) .EnableBatchProcessing(100, TimeSpan.FromSeconds(5)))); } public class MyEndpointsConfigurator : IEndpointsConfigurator { public void Configure(IEndpointsConfigurationBuilder builder) => builder .AddInbound( new KafkaConsumerEndpoint(\"inventory-events\") { Configuration = new KafkaConsumerConfig { BootstrapServers = \"PLAINTEXT://kafka:9092\", GroupId = \"my-consumer\" }, Batch = new Messaging.Batch.BatchSettings { Size = 100, MaxWaitTime = TimeSpan.FromSeconds(5) } }); } public class InventoryService { private DbContext _db; public InventoryService(MyDbContext db) { _db = db; } public async Task OnBatchReceived(IAsyncEnumerable<InventoryUpdateEvent> messages) { async foreach (var message in messages) { // Process each message } // Commit all changes in a single transaction await _db.SaveChangesAsync(); } } Parallelism The consumer processes the messages sequentially, this is by design. The <xref:Silverback.Messaging.Broker.KafkaConsumer> is a bit special and actually processes each assigned partition independently and concurrently. This feature can be toggled using the ProcessAllPartitionsTogether and ProcessPartitionsIndependently methods of the <xref:Silverback.Messaging.Configuration.Kafka.IKafkaConsumerEndpointBuilder> (or the KafkaConsumerEndpoint.ProcessPartitionsIndependently property), while the LimitParallelism method (or the KafkaConsumerEndpoint.MaxDegreeOfParallelism property) can be used to limit the number of messages being actually processed concurrently. Exactly-once processing Silverback is able to keep track of the messages that have been consumed in order to guarantee that each message is processed exactly once. Offset storage The <xref:Silverback.Messaging.Inbound.ExactlyOnce.OffsetStoreExactlyOnceStrategy> will store the offset of the latest processed message (of each topic/partition) into a database table. The offsets are being stored to prevent the very same message to be consumed twice. Note The Silverback.Core.EntityFrameworkCore package is also required and the DbContext must include a DbSet of <xref:Silverback.Database.Model.StoredOffset>. See also the Sample DbContext (EF Core) . Startup EndpointsConfigurator (fluent) EndpointsConfigurator (legacy) public class Startup { public void ConfigureServices(IServiceCollection services) { services .AddSilverback() .UseDbContext<MyDbContext>() .WithConnectionToMessageBroker(options => options .AddKafka() .AddOffsetStoreDatabaseTable()) .AddEndpointsConfigurator<MyEndpointsConfigurator>(); } } public class MyEndpointsConfigurator : IEndpointsConfigurator { public void Configure(IEndpointsConfigurationBuilder builder) => builder .AddKafkaEndpoints(endpoints => endpoints .Configure(config => { config.BootstrapServers = \"PLAINTEXT://kafka:9092\"; }) .AddInbound(endpoint => endpoint .ConsumeFrom(\"inventory-events\") .Configure(config => { config.GroupId = \"my-consumer\"; }) .EnsureExactlyOnce(strategy => strategy.StoreOffsets()))); } public class MyEndpointsConfigurator : IEndpointsConfigurator { public void Configure(IEndpointsConfigurationBuilder builder) => builder .AddInbound( new KafkaConsumerEndpoint(\"inventory-events\") { Configuration = new KafkaConsumerConfig { BootstrapServers = \"PLAINTEXT://kafka:9092\", GroupId = \"my-consumer\" }, ExactlyOnceStrategy = new OffsetStoreExactlyOnceStrategy() }); } Inbound log The <xref:Silverback.Messaging.Inbound.ExactlyOnce.LogExactlyOnceStrategy> will store the identifiers of all processed messages into a database table. The inbound messages are logged to prevent two messages with the same key to be consumed. Note The Silverback.Core.EntityFrameworkCore package is also required and the DbContext must include a DbSet of <xref:Silverback.Database.Model.InboundLogEntry>. See also the Sample DbContext (EF Core) . Startup EndpointsConfigurator (fluent) EndpointsConfigurator (legacy) public class Startup { public void ConfigureServices(IServiceCollection services) { services .AddSilverback() .UseDbContext<MyDbContext>() .WithConnectionToMessageBroker(options => options .AddKafka() .AddInboundLogDatabaseTable()) .AddEndpointsConfigurator<MyEndpointsConfigurator>(); } } public class MyEndpointsConfigurator : IEndpointsConfigurator { public void Configure(IEndpointsConfigurationBuilder builder) => builder .AddKafkaEndpoints(endpoints => endpoints .Configure(config => { config.BootstrapServers = \"PLAINTEXT://kafka:9092\"; }) .AddInbound(endpoint => endpoint .ConsumeFrom(\"inventory-events\") .Configure(config => { config.GroupId = \"my-consumer\"; }) .EnsureExactlyOnce(strategy => strategy.LogMessages()))); } public class MyEndpointsConfigurator : IEndpointsConfigurator { public void Configure(IEndpointsConfigurationBuilder builder) => builder .AddInbound( new KafkaConsumerEndpoint(\"inventory-events\") { Configuration = new KafkaConsumerConfig { BootstrapServers = \"PLAINTEXT://kafka:9092\", GroupId = \"my-consumer\" }, ExactlyOnceStrategy = new LogExactlyOnceStrategy() }); } Custom store At the moment only a database accessed using Entity Framework is supported as offset or log storage, but a custom storage can be used implementing <xref:Silverback.Messaging.Inbound.ExactlyOnce.Repositories.IOffsetStore> or <xref:Silverback.Messaging.Inbound.ExactlyOnce.Repositories.IInboundLog>. public class Startup { public void ConfigureServices(IServiceCollection services) { services .AddSilverback() .UseDbContext<MyDbContext>() .WithConnectionToMessageBroker(options => options .AddKafka() .AddOffsetStore<MyCustomOffsetStore>()) .AddEndpointsConfigurator<MyEndpointsConfigurator>(); } } Samples All"
  },
  "concepts/broker/inboundenvelope.html": {
    "href": "concepts/broker/inboundenvelope.html",
    "title": "IInboundEnvelope | Silverback",
    "keywords": "IInboundEnvelope When a message is consumed Silverback wraps it into an <xref:Silverback.Messaging.Messages.IInboundEnvelope`1> and pushes it to the message bus. Both the <xref:Silverback.Messaging.Messages.IInboundEnvelope`1> or the contained message in its pure form can be subscribed. You can take advantage of this mechanism to gain access to the transport information of the message, since the <xref:Silverback.Messaging.Messages.IInboundEnvelope`1> holds all the information like endpoint, offset and headers data. Subscribing to the <xref:Silverback.Messaging.Messages.IInboundEnvelope`1> works exactly the same as subscribing to any other message. public class SubscribingService { public async Task OnWrappedMessageReceived(IInboundEnvelope<SampleMessage> envelope) { // ...your message handling logic... } public async Task OnPureMessageReceived(SampleMessage message) { // ...your message handling logic... } } Note Subscribing to the non-generic <xref:Silverback.Messaging.Messages.IInboundEnvelope> or <xref:Silverback.Messaging.Messages.IRawInboundEnvelope> it is possible to subscribe even the messages with an empty body."
  },
  "concepts/broker/kafka/kafka-events.html": {
    "href": "concepts/broker/kafka/kafka-events.html",
    "title": "Kafka Events | Silverback",
    "keywords": "Kafka Events The underlying library ( Confluent.Kafka ) uses some events to let you catch important information, interact with the partitions assignment process, etc. Silverback proxies those events to give you full access to those features. Consumer events These callbacks are available: <xref:Silverback.Messaging.Broker.Callbacks.IKafkaPartitionsAssignedCallback> <xref:Silverback.Messaging.Broker.Callbacks.IKafkaPartitionsRevokedCallback> <xref:Silverback.Messaging.Broker.Callbacks.IKafkaOffsetCommittedCallback> <xref:Silverback.Messaging.Broker.Callbacks.IKafkaConsumerErrorCallback> <xref:Silverback.Messaging.Broker.Callbacks.IKafkaConsumerStatisticsCallback> <xref:Silverback.Messaging.Broker.Callbacks.IKafkaConsumerLogCallback> <xref:Silverback.Messaging.Broker.Callbacks.IKafkaPartitionEofCallback> Offset reset example In the following example the partitions assigned event is subscribed in order to reset the start offsets and replay the past messages. Startup ResetOffsetPartitionsAssignedCallbackHandler public class Startup { public void ConfigureServices(IServiceCollection services) { services .AddSilverback() .WithConnectionToMessageBroker(options => options .AddKafka()) .AddSingletonBrokerCallbacksHandler<ResetOffsetPartitionsAssignedCallbackHandler>(); } } public class ResetOffsetPartitionsAssignedCallbackHandler : IKafkaPartitionsAssignedCallback { public IEnumerable<TopicPartitionOffset> OnPartitionsAssigned( IReadOnlyCollection<TopicPartition> topicPartitions, KafkaConsumer consumer) => topicPartitions.Select( topicPartition => new TopicPartitionOffset(topicPartition, Offset.Beginning)); } Producer events These callbacks are available: <xref:Silverback.Messaging.Broker.Callbacks.IKafkaProducerStatisticsCallback> <xref:Silverback.Messaging.Broker.Callbacks.IKafkaProducerLogCallback> See also Broker Callbacks"
  },
  "concepts/broker/kafka/kafka-partitioning.html": {
    "href": "concepts/broker/kafka/kafka-partitioning.html",
    "title": "Kafka Partitioning and Message Key | Silverback",
    "keywords": "Kafka Partitioning and Message Key Producer Destination partition If the destination topic contains multiple partitions, the destination partition is picked according to the hash of the message key . If no explicit message key was set, a random one is generated, resulting in the messages being randomly spread across the partitions. You can override this default behavior explicitly setting the target partition in the endpoint. The endpoint can be statically defined like in the following snippet or resolved via dynamic routing . Fluent Legacy public class MyEndpointsConfigurator : IEndpointsConfigurator { public void Configure(IEndpointsConfigurationBuilder builder) => builder .AddKafkaEndpoints(endpoints => endpoints .Configure(config => { config.BootstrapServers = \"PLAINTEXT://kafka:9092\"; }) .AddOutbound<IIntegrationEvent>(endpoint => endpoint .ProduceTo(\"order-events\", 2))); // <- partition 2 } public class MyEndpointsConfigurator : IEndpointsConfigurator { public void Configure(IEndpointsConfigurationBuilder builder) => builder .AddOutbound<IIntegrationEvent>( new KafkaProducerEndpoint(\"order-events\") { Configuration = new KafkaProducerConfig { BootstrapServers = \"PLAINTEXT://kafka:9092\" }, Partition = 2 }); } Producing to a fixed partition may be required in the case you have multiple producers to the same topic and you have to prevent the messages from the different clients to be interleaved (e.g. because you are relying on sequences, like chunking ). Message key Apache Kafka require a message key for different purposes, such as: Partitioning : Kafka can guarantee ordering only inside the same partition and it is therefore important to be able to route correlated messages into the same partition. To do so you need to specify a key for each message and Kafka will put all messages with the same key in the same partition. Compacting topics : A topic can be configured with cleanup.policy=compact to instruct Kafka to keep only the latest message related to a certain object, identified by the message key. In other words Kafka will retain only 1 message per each key value. The messages with the same key are guaranteed to be written to the same partition. Silverback will always generate a message key (same value as the x-message-id header ) but you can also generate your own key, either adding an enricher to the <xref:Silverback.Messaging.IProducerEndpoint> or decorating the properties that must be part of the key with <xref:Silverback.Messaging.Messages.KafkaKeyMemberAttribute>. Using enricher Fluent Legacy public class MyEndpointsConfigurator : IEndpointsConfigurator { public void Configure(IEndpointsConfigurationBuilder builder) => builder .AddKafkaEndpoints(endpoints => endpoints .Configure(config => { config.BootstrapServers = \"PLAINTEXT://kafka:9092\"; }) .AddOutbound<InventoryEvent>(endpoint => endpoint .ProduceTo(\"inventory-events\") .WithKafkaKey<InventoryEvent>( envelope => envelope.Message?.ProductId))); } public class MyEndpointsConfigurator : IEndpointsConfigurator { public void Configure(IEndpointsConfigurationBuilder builder) => builder .AddOutbound<InventoryEvent>( new KafkaProducerEndpoint(\"inventory-events\") { Configuration = new KafkaProducerConfig { BootstrapServers = \"PLAINTEXT://kafka:9092\" }, MessageEnrichers = new List<IOutboundMessageEnricher> { new OutboundMessageKafkaKeyEnricher<InventoryEvent>( envelope => envelope.Message?.ProductId) } }); } Using KafkaKeyMemberAttribute public class MultipleKeyMembersMessage : IIntegrationMessage { public Guid Id { get; set; } [KafkaKeyMember] public string One { get; set; } [KafkaKeyMember] public string Two { get; set; } public string Three { get; set; } } Note The message key will also be received as header (see Message Headers for details). Consumer Partitions processing While using a single poll loop, Silverback processes the messages consumed from each Kafka partition independently and concurrently. By default up to 10 messages/partitions are processed concurrently (per topic). This value can be tweaked in the endpoint configuration or disabled completely. Fluent Legacy public class MyEndpointsConfigurator : IEndpointsConfigurator { public void Configure(IEndpointsConfigurationBuilder builder) => builder .AddKafkaEndpoints(endpoints => endpoints .Configure(config => { config.BootstrapServers = \"PLAINTEXT://kafka:9092\"; }) .AddInbound(endpoint => endpoint .ConsumeFrom(\"order-events\") .LimitParallelism(2) .Configure(config => { config.GroupId = \"my-consumer\"; }) .AddInbound(endpoint => endpoint .ConsumeFrom(\"inventory-events\") .ProcessAllPartitionsTogether() .Configure(config => { config.GroupId = \"my-consumer\"; }))); } public class MyEndpointsConfigurator : IEndpointsConfigurator { public void Configure(IEndpointsConfigurationBuilder builder) => builder .AddInbound( new KafkaConsumerEndpoint(\"order-events\") { Configuration = new KafkaConsumerConfig { BootstrapServers = \"PLAINTEXT://kafka:9092\", GroupId = \"my-consumer\", }, MaxDegreeOfParallelism = 2 }) .AddInbound( new KafkaConsumerEndpoint(\"inventory-events\") { Configuration = new KafkaConsumerConfig { BootstrapServers = \"PLAINTEXT://kafka:9092\", GroupId = \"my-consumer\", }, ProcessPartitionsIndependently = false }); } Manual partitions assignment In some cases you don't want to let the broker randomly distribute the partitions among the consumers. This might also be useful when dealing with large sequences (e.g. large messages/files being chunked or when batch processing ), to prevent that a rebalance occurs in the middle of a sequence, forcing the consumer to abort and restart from the beginning. The assignment can either be completely static or dynamic using a resolver function that will receive all available partitions as input (see <xref:Silverback.Messaging.Configuration.Kafka.IKafkaConsumerEndpointBuilder> and <xref:Silverback.Messaging.KafkaConsumerEndpoint> for details). Fluent (static) Fluent (dynamic) Legacy (static) Legacy (dynamic) public class MyEndpointsConfigurator : IEndpointsConfigurator { public void Configure(IEndpointsConfigurationBuilder builder) => builder .AddKafkaEndpoints(endpoints => endpoints .Configure(config => { config.BootstrapServers = \"PLAINTEXT://kafka:9092\"; }) .AddInbound(endpoint => endpoint .ConsumeFrom( new TopicPartition(\"order-events\", 0), new TopicPartition(\"order-events\", 1)) .Configure(config => { config.GroupId = \"my-consumer\"; }))); } public class MyEndpointsConfigurator : IEndpointsConfigurator { public void Configure(IEndpointsConfigurationBuilder builder) => builder .AddKafkaEndpoints(endpoints => endpoints .Configure(config => { config.BootstrapServers = \"PLAINTEXT://kafka:9092\"; }) .AddInbound(endpoint => endpoint .ConsumeFrom( \"order-events\", partitions => partitions .Where(partition => partition.Partition % 2 == 0)) .Configure(config => { config.GroupId = \"my-consumer\"; }))); } public class MyEndpointsConfigurator : IEndpointsConfigurator { public void Configure(IEndpointsConfigurationBuilder builder) => builder .AddInbound( new KafkaConsumerEndpoint( new TopicPartition(\"order-events\", 0), new TopicPartition(\"order-events\", 1)) { Configuration = new KafkaConsumerConfig { BootstrapServers = \"PLAINTEXT://kafka:9092\", GroupId = \"my-consumer\" } }); } public class MyEndpointsConfigurator : IEndpointsConfigurator { public void Configure(IEndpointsConfigurationBuilder builder) => builder .AddInbound( new KafkaConsumerEndpoint( \"order-events\", partitions => partitions .Where(partition => partition.Partition % 2 == 0)) { Configuration = new KafkaConsumerConfig { BootstrapServers = \"PLAINTEXT://kafka:9092\", GroupId = \"my-consumer\" } }); } Samples Kafka - Files Streaming"
  },
  "concepts/broker/kafka/multiple-consumer-groups.html": {
    "href": "concepts/broker/kafka/multiple-consumer-groups.html",
    "title": "Multiple Consumer Groups (in same process) | Silverback",
    "keywords": "Multiple Consumer Groups (in same process) In some cases you may want to subscribe multiple times the same consumed message, to perform independent tasks. Having multiple subscribers handling the very same message is not a good idea since a failure in one of them will cause the message to be consumed again and thus reprocessed by all subscribers. A much safer approach is to bind multiple consumers to the same topic, using a different consumer group id. This will cause the message to be consumed multiple times (once per consumer group) and being committed independently. The <xref:Silverback.Messaging.Subscribers.KafkaGroupIdFilterAttribute> can be used to execute a subscribed method according to the group id. EndpointsConfigurator (fluent) EndpointsConfigurator (legacy) Subscriber public class MyEndpointsConfigurator : IEndpointsConfigurator { public void Configure(IEndpointsConfigurationBuilder builder) => builder .AddKafkaEndpoints(endpoints => endpoints .Configure(config => { config.BootstrapServers = \"PLAINTEXT://kafka:9092\"; }) .AddInbound(endpoint => endpoint .ConsumeFrom(\"document-events\") .Configure(config => { config.GroupId = \"group1\"; })) .AddInbound(endpoint => endpoint .ConsumeFrom(\"document-events\") .Configure(config => { config.GroupId = \"group2\"; }))); } public class MyEndpointsConfigurator : IEndpointsConfigurator { public void Configure(IEndpointsConfigurationBuilder builder) => builder .AddInbound( new KafkaConsumerEndpoint(\"document-events\") { Configuration = new KafkaConsumerConfig { BootstrapServers = \"PLAINTEXT://kafka:9092\", GroupId = \"group1\" } }) .AddInbound( new KafkaConsumerEndpoint(\"document-events\") { Configuration = new KafkaConsumerConfig { BootstrapServers = \"PLAINTEXT://kafka:9092\", GroupId = \"group2\" } }); } public class MySubscriber { [KafkaGroupIdFilter(\"group1\")] public void PerformTask1(MyEvent @event) => ... [KafkaGroupIdFilter(\"group2\")] public void PerformTask2(MyEvent @event) => ... } Note The filters can be added dynamically using the overloads of AddSubscriber accepting a SubscriptionOptions or TypeSubscriptionOptions and this allows you to use a variable for the group id. .AddSingletonSubscriber<MySubscriber>( new TypeSubscriptionOptions { Filters = new[] { new KafkaGroupIdFilterAttribute(\"consumer1\") } }) Using the <xref:Silverback.Messaging.Subscribers.KafkaGroupIdFilterAttribute> is the cleanest and easiest approach but alternatively you can always subscribe to the <xref:Silverback.Messaging.Messages.IInboundEnvelope`1> and perform different tasks according to the GroupId value. public class MySubscriber { public void OnMessageReceived(IInboundEnvelope<MyEvent> envelope) { switch (((KafkaConsumerEndpoint)envelope.Endpoint).Configuration.GroupId) { case \"group1\": PerformTask1(envelope.Message); break; case \"group2\": PerformTask2(envelope.Message); break; } } private void PerformTask1(MyEvent @event) => ... private void PerformTask2(MyEvent @event) => ... }"
  },
  "concepts/broker/message-id.html": {
    "href": "concepts/broker/message-id.html",
    "title": "Message Identifier | Silverback",
    "keywords": "Message Identifier Silverback will ensure that an x-message-id header is always set with each message. This header is used mostly for tracing purpose and it's value is always printed in the logs generated by Silverback. The producer will automatically generate a random Guid to be used as message identifier. (This value will be used also as Kafka key by default, see Kafka Partitioning and Message Key .) In the consumer side the message identifier may be used also to rebuild the chunks sequence , implement exactly once processing and similar. If the header is not present, the consumer may artificially set if with another identifier such as the Kafka key (see Kafka Partitioning and Message Key ). Custom value It is of course possible to use a customized message identifier instead of a random Guid , simply overriding the x-message-id header as shown in the following snippet. More information about the message headers can be found in the Message Headers section. using Silverback.Messaging.Messages; namespace Sample { public class OrderSubmittedEvent { [Header(DefaultMessageHeaders.MessageId)] public string UniqueOrderNumber { get; set; } } } Note This example assumes that only one message per each order is published to the same endpoint, because the message id should be unique in order for the various features relying on it to work properly."
  },
  "concepts/broker/mqtt/mqtt-events.html": {
    "href": "concepts/broker/mqtt/mqtt-events.html",
    "title": "MQTT Events | Silverback",
    "keywords": "MQTT Events Some lifetime events are fired by the <xref:Silverback.Messaging.Broker.MqttBroker> and can be handled using the following callbacks: <xref:Silverback.Messaging.Broker.Callbacks.IMqttClientConnectedCallback> <xref:Silverback.Messaging.Broker.Callbacks.IMqttClientDisconnectingCallback> Example In the following example a message is sent as soon as the client is connected. Startup ConnectionCallbackHandler public class Startup { public void ConfigureServices(IServiceCollection services) { services .AddSilverback() .WithConnectionToMessageBroker(options => options .AddMqtt()) .AddSingletonBrokerCallbacksHandler<ConnectionCallbackHandler>(); } } public class ConnectionCallbackHandler : IMqttClientConnectedCallback { private readonly IPublisher _publisher; public ConnectionCallbackHandler(IPublisher publisher) { _publisher = publisher; } public Task OnClientConnectedAsync(MqttClientConfig config) => _publisher.PublishAsync(new ClientConnectedMessage()); } See also Broker Callbacks"
  },
  "concepts/broker/mqtt/multiple-clients.html": {
    "href": "concepts/broker/mqtt/multiple-clients.html",
    "title": "Multiple Clients (in same process) | Silverback",
    "keywords": "Multiple Clients (in same process) In some cases you may want to subscribe multiple times the same consumed message, to perform independent tasks. Having multiple subscribers handling the very same message is not a good idea since a failure in one of them will cause the message to be consumed again and thus reprocessed by all subscribers. A much safer approach is to bind multiple consumers to the same topic, using a different client id. This will cause the message to be consumed multiple times (once per client) and being committed independently. The <xref:Silverback.Messaging.Subscribers.MqttClientIdFilterAttribute> can be used to execute a subscribed method according to the client id. EndpointsConfigurator (fluent) EndpointsConfigurator (legacy) Subscriber public class MyEndpointsConfigurator : IEndpointsConfigurator { public void Configure(IEndpointsConfigurationBuilder builder) => builder .AddMqttEndpoints(endpoints => endpoints .Configure( config => config .ConnectViaTcp(\"localhost\")) .AddInbound(endpoint => endpoint .Configure(config => config.WithClientId(\"client1\")) .ConsumeFrom(\"document-events\")) .AddInbound(endpoint => endpoint .Configure(config => config.WithClientId(\"client2\")) .ConsumeFrom(\"document-events\"))); } public class MyEndpointsConfigurator : IEndpointsConfigurator { public void Configure(IEndpointsConfigurationBuilder builder) => builder .AddInbound( new MqttConsumerEndpoint(\"document-events\") { Configuration = { ClientId = \"client1\", ChannelOptions = new MqttClientTcpOptions { Server = \"localhost\" } } }) .AddInbound( new MqttConsumerEndpoint(\"document-events\") { Configuration = { ClientId = \"client2\", ChannelOptions = new MqttClientTcpOptions { Server = \"localhost\" } } }); } public class MySubscriber { [MqttClientIdFilter(\"client1\")] public void PerformTask1(MyEvent @event) => ... [MqttClientIdFilter(\"client2\")] public void PerformTask2(MyEvent @event) => ... } Note The filters can be added dynamically using the overloads of AddSubscriber accepting a SubscriptionOptions or TypeSubscriptionOptions and this allows you to use a variable for the client id. .AddSingletonSubscriber<MySubscriber>( new TypeSubscriptionOptions { Filters = new[] { new MqttClientIdFilterAttribute(\"client1\") } }) Using the <xref:Silverback.Messaging.Subscribers.MqttClientIdFilterAttribute> is the cleanest and easiest approach but alternatively you can always subscribe to the <xref:Silverback.Messaging.Messages.IInboundEnvelope`1> and perform different tasks according to the ClientId value. public class MySubscriber { public void OnMessageReceived(IInboundEnvelope<MyEvent> envelope) { switch (((MqttConsumerEndpoint)envelope.Endpoint).Configuration.ClientId) { case \"client1\": PerformTask1(envelope.Message); break; case \"client2\": PerformTask2(envelope.Message); break; } } private void PerformTask1(MyEvent @event) => ... private void PerformTask2(MyEvent @event) => ... }"
  },
  "concepts/broker/outbound.html": {
    "href": "concepts/broker/outbound.html",
    "title": "Outbound Endpoint | Silverback",
    "keywords": "Outbound Endpoint An outbound endpoint is used to configure silverback to automatically relay the integration messages that ate published to the internal bus to the message broker. Multiple outbound endpoints can be configured and Silverback will route the messages according to their type or a custom routing logic. The endpoint object identifies the topic/queue that is being connected and the client configuration, such the connection options. The endpoint object is therefore very specific and every broker type will define it's own implementation of IProducerEndpoint . The options in the endpoint object are also used to tweak the Silverback behavior (e.g. the serialization ) and to enable additional features such as chunking , encryption , etc. Apache Kafka The <xref:Silverback.Messaging.KafkaProducerEndpoint> is defined by Silverback.Integration.Kafka and is used to declare an outbound endpoint connected to Apache Kafka. Fluent (preferred) Legacy public class MyEndpointsConfigurator : IEndpointsConfigurator { public void Configure(IEndpointsConfigurationBuilder builder) => builder .AddKafkaEndpoints(endpoints => endpoints .Configure(config => { config.BootstrapServers = \"PLAINTEXT://kafka:9092\"; }) .AddOutbound<IIntegrationEvent>(endpoint => endpoint .ProduceTo(\"order-events\") .EnableChunking(500000) .ProduceToOutbox())); } public class MyEndpointsConfigurator : IEndpointsConfigurator { public void Configure(IEndpointsConfigurationBuilder builder) => builder .AddOutbound<IIntegrationEvent>( new KafkaProducerEndpoint(\"order-events\") { Configuration = new KafkaProducerConfig { BootstrapServers = \"PLAINTEXT://kafka:9092\" }, Chunk = new ChunkSettings { Size = 500000 }, Strategy = new OutboxProduceStrategy() }); } Note For a more in-depth documentation about the Kafka client configuration refer also to the confluent-kafka-dotnet documentation . MQTT The <xref:Silverback.Messaging.MqttProducerEndpoint> is defined by Silverback.Integration.MQTT and is used to declare an outbound endpoint connected to an MQTT broker. Fluent (preferred) Legacy public class MyEndpointsConfigurator : IEndpointsConfigurator { public void Configure(IEndpointsConfigurationBuilder builder) => builder .AddMqttEndpoints(endpoints => endpoints .Configure( config => config .WithClientId(\"order-service\") .ConnectViaTcp(\"localhost\") .SendLastWillMessage( lastWill => lastWill .Message(new TestamentMessage()) .ProduceTo(\"testaments\"))) .AddOutbound<IIntegrationEvent>(endpoint => endpoint .ProduceTo(\"order-events\") .WithQualityOfServiceLevel( MqttQualityOfServiceLevel.AtLeastOnce) .Retain())); } public class MyEndpointsConfigurator : IEndpointsConfigurator { public void Configure(IEndpointsConfigurationBuilder builder) => builder .AddOutbound<IIntegrationEvent>( new MqttProducerEndpoint(\"order-events\") { Configuration = { ClientId = \"order-service\", ChannelOptions = new MqttClientTcpOptions { Server = \"localhost\" }, WillMessage = new MqttApplicationMessage() { ... } }, QualityOfServiceLevel = MqttQualityOfServiceLevel.AtLeastOnce, Retain = true }); } Note For a more in-depth documentation about the MQTT client configuration refer also to the MQTTNet documentation . RabbitMQ Silverback.Integration.RabbitMQ is a bit more intricate and uses 2 different classes to specify an endpoint that connects to a queue ( RabbitQueueProducerEndpoint ) or directly to an exchange ( RabbitExchangeProducerEndpoint ). public class MyEndpointsConfigurator : IEndpointsConfigurator { public void Configure(IEndpointsConfigurationBuilder builder) => builder .AddOutbound<IIntegrationEvent>( new RabbitQueueProducerEndpoint(\"inventory-commands-queue\") { Connection = new RabbitConnectionConfig { HostName = \"localhost\", UserName = \"guest\", Password = \"guest\" }, Queue = new RabbitQueueConfig { IsDurable = true, IsExclusive = false, IsAutoDeleteEnabled = false } }) .AddOutbound<IIntegrationEvent>( new RabbitExchangeProducerEndpoint(\"order-events\") { Connection = new RabbitConnectionConfig { HostName = \"localhost\", UserName = \"guest\", Password = \"guest\" }, Exchange = new RabbitExchangeConfig { IsDurable = true, IsAutoDeleteEnabled = false, ExchangeType = ExchangeType.Fanout } }); } Note For a more in-depth documentation about the RabbitMQ configuration refer to the RabbitMQ tutorials and documentation . Transactional outbox strategy The transactional outbox pattern purpose is to reliably update the database and publish the messages in the same atomic transaction. This is achieved storing the outbound messages into a temporary outbox table, whose changes are committed together with the other changes to the rest of the data. Messages 1, 2 and 3 are stored in the outbox table and produced by a separate thread or process. When using entity framework the outbound messages are stored into a DbSet and are therefore implicitly saved in the same transaction used to save all other changes. Note The Silverback.Core.EntityFrameworkCore package is also required and the DbContext must include a DbSet of <xref:Silverback.Database.Model.OutboxMessage>. See also the Sample DbContext (EF Core) . Important The current <xref:Silverback.Messaging.Outbound.TransactionalOutbox.OutboxWorker> cannot scale horizontally and starting multiple instances will cause the messages to be produced multiple times. In the following example a distributed lock (stored in the database) is used to ensure that only one instance is running and another one will immediately take over when it stops (the DbContext must include a DbSet of Lock as well, see also the Sample DbContext (EF Core) ). Startup EndpointsConfigurator (fluent) EndpointsConfigurator (legacy) Publisher public class Startup { public void ConfigureServices(IServiceCollection services) { services .AddSilverback() .UseDbContext<MyDbContext>() // Setup the lock manager using the database // to handle the distributed locks. // If this line is omitted the OutboundWorker will still // work without locking. .AddDbDistributedLockManager() .WithConnectionToMessageBroker(options => options .AddKafka() .AddOutboxDatabaseTable() .AddOutboxWorker()) .AddEndpointsConfigurator<MyEndpointsConfigurator>(); } } public class MyEndpointsConfigurator : IEndpointsConfigurator { public void Configure(IEndpointsConfigurationBuilder builder) => builder .AddKafkaEndpoints(endpoints => endpoints .Configure(config => { config.BootstrapServers = \"PLAINTEXT://kafka:9092\"; }) .AddOutbound<IIntegrationEvent>( endpoint => endpoint .ProduceTo(\"order-events\") .ProduceToOutbox())); } public class MyEndpointsConfigurator : IEndpointsConfigurator { public void Configure(IEndpointsConfigurationBuilder builder) => builder .AddOutbound<IIntegrationEvent>( new KafkaProducerEndpoint(\"order-events\") { Configuration = new KafkaProducerConfig { BootstrapServers = \"PLAINTEXT://kafka:9092\" }, Strategy = new OutboxProduceStrategy() }); } private readonly IPublisher _publisher; private readonly SampleDbContext _dbContext; public async Task CancelOrder(int orderId) { // You can use _dbContext to update/insert entities here await _publisher.PublishAsync(new OrderCancelledEvent { OrderId = orderId }); // No messages will be published unless you call SaveChangesAsync! await _dbContext.SaveChangesAsync(); } Custom outbox You can easily use another kind of storage as outbox, simply creating your own <xref:Silverback.Messaging.Outbound.TransactionalOutbox.Repositories.IOutboxWriter> and <xref:Silverback.Messaging.Outbound.TransactionalOutbox.Repositories.IOutboxReader> implementations. At the moment only a database table accessed using Entity Framework is supported as outbox, but a custom storage can be used implementing <xref:Silverback.Messaging.Outbound.TransactionalOutbox.Repositories.IOutboxWriter> and <xref:Silverback.Messaging.Outbound.TransactionalOutbox.Repositories.IOutboxReader>. public class Startup { public void ConfigureServices(IServiceCollection services) { services .AddSilverback() .UseDbContext<MyDbContext>() .AddDbDistributedLockManager() .WithConnectionToMessageBroker(options => options .AddKafka() .AddOutbox<MyCustomOutboxWriter, MyCustomOutboxReader() .AddOutboxWorker()) .AddEndpointsConfigurator<MyEndpointsConfigurator>(); } } Subscribing locally The published messages that are routed to an outbound endpoint cannot be subscribed locally (within the same process), unless explicitly desired. public class Startup { public void ConfigureServices(IServiceCollection services) { services .AddSilverback() .AddDbDistributedLockManager() .WithConnectionToMessageBroker(options => options .AddKafka()) .AddEndpointsConfigurator<MyEndpointsConfigurator>() .PublishOutboundMessagesToInternalBus(); } } Note What said above is only partially true, as you can subscribe to the wrapped message (<xref:Silverback.Messaging.Messages.IOutboundEnvelope`1>) even without calling PublishOutboundMessagesToInternalBus . Producing the same message to multiple endpoints An outbound route can point to multiple endpoints resulting in a broadcast to all endpoints. Messages 1, 2 and 3 are published to both topics simultaneously. public class MyEndpointsConfigurator : IEndpointsConfigurator { public void Configure(IEndpointsConfigurationBuilder builder) { builder .AddOutbound<IIntegrationCommand>( new KafkaProducerEndpoint(\"topic-1\") { ... }, new KafkaProducerEndpoint(\"topic-2\") { ... })); } } A message will also be routed to all outbound endpoint mapped to a type compatible with the message type. In the example below an OrderCreatedMessage (that inherits from OrderMessage ) would be sent to both endpoints. public class MyEndpointsConfigurator : IEndpointsConfigurator { public void Configure(IEndpointsConfigurationBuilder builder) { builder .AddOutbound<OrderMessage>( new KafkaProducerEndpoint(\"topic-1\") { ... }) .AddOutbound<OrderCreatedMessage>( new KafkaProducerEndpoint(\"topic-2\") { ... })); } } Dynamic custom routing By default Silverback routes the messages according to their type and the static configuration defined at startup. In some cases you may need more flexibility, being able to apply your own routing rules. More information in the dedicated Outbound Messages Routing chapter. Samples All"
  },
  "concepts/broker/outbound-routing.html": {
    "href": "concepts/broker/outbound-routing.html",
    "title": "Outbound Messages Routing | Silverback",
    "keywords": "Outbound Messages Routing By default Silverback routes the messages according to their type and the static configuration defined at startup. In some cases you may need more flexibility, being able to apply your own routing rules. In such cases it is possible to either take advantage of the simple endpoint name resolvers or even implement a fully customized router. The messages are dynamically routed to the appropriate endpoint. Endpoint name resolver Using an endpoint name resolver is fairly simple and just requires a slightly different configuration in the <xref:Silverback.Messaging.IProducerEndpoint>. Here below a few examples of custom routing. Please refer to the <xref:Silverback.Messaging.KafkaProducerEndpoint>/<xref:Silverback.Messaging.Configuration.Kafka.IKafkaProducerEndpointBuilder> or <xref:Silverback.Messaging.MqttProducerEndpoint>/<xref:Silverback.Messaging.Configuration.Mqtt.IMqttProducerEndpointBuilder> API documentation for further information about all the possibilities. Fluent Legacy ProducerEndpointNameResolver public class MyEndpointsConfigurator : IEndpointsConfigurator { public void Configure(IEndpointsConfigurationBuilder builder) => builder .AddKafkaEndpoints(endpoints => endpoints .Configure(config => { config.BootstrapServers = \"PLAINTEXT://kafka:9092\"; }) // Using a resolver function .AddOutbound<OrderCreatedEvent>(endpoint => endpoint .ProduceTo<OrderCreatedEvent>(envelope => { if (envelope.Message.IsPriority) return \"priority-orders\"; else return \"normal-orders\"; })) // Using format string and arguments function .AddOutbound<OrderCreatedEvent>(endpoint => endpoint .ProduceTo<OrderCreatedEvent>( \"orders-{0}\", envelope => { if (envelope.Message.IsPriority) return new[] { \"priority\" }; else return new[] { \"normal\" }; })) // Using a resolver class .AddOutbound<OrderCreatedEvent>(endpoint => endpoint .UseEndpointNameResolver<MyEndpointNameResolver>()) // Kafka only: using a partition resolver function .AddOutbound<InventoryUpdateMessage>(endpoint => endpoint .ProduceTo<InventoryUpdateMessage>( _ => \"topic1\", envelope => { switch (envelope.Message.Supplier) { case \"foo\": return 0; case \"bar\": return 1; case \"baz\": return 2; } })))); } public class MyEndpointsConfigurator : IEndpointsConfigurator { public void Configure(IEndpointsConfigurationBuilder builder) => builder // Using a resolver function .AddOutbound<OrderCreatedEvent>( new KafkaProducerEndpoint(envelope => { var message = (OrderCreatedEvent) envelope.Message; if (message.IsPriority) return \"priority-orders\"; else return \"normal-orders\"; }) { Configuration = new KafkaProducerConfig { BootstrapServers = \"PLAINTEXT://kafka:9092\" } }) // Using format string and arguments function .AddOutbound<OrderCreatedEvent>( new KafkaProducerEndpoint( \"orders-{0}\", envelope => { var message = (OrderCreatedEvent) envelope.Message; if (message.IsPriority) return new[] { \"priority\" }; else return new[] { \"normal\" }; }) { Configuration = new KafkaProducerConfig { BootstrapServers = \"PLAINTEXT://kafka:9092\" } }) // Using a resolver class .AddOutbound<OrderCreatedEvent>( new KafkaProducerEndpoint(typeof(MyEndpointNameResolver)) { Configuration = new KafkaProducerConfig { BootstrapServers = \"PLAINTEXT://kafka:9092\" } }) // Kafka only: using a partition resolver function .AddOutbound<InventoryUpdateMessage>( new KafkaProducerEndpoint( _ => \"topic1\", envelope => { var message = (InventoryUpdateMessage) envelope.Message; switch (message.Supplier) { case \"foo\": return 0; case \"bar\": return 1; case \"baz\": return 2; } }) { Configuration = new KafkaProducerConfig { BootstrapServers = \"PLAINTEXT://kafka:9092\" } }); } public class MyEndpointNameResolver : ProducerEndpointNameResolver<TestEventOne> { private readonly IMyService _service; public MyEndpointNameResolver(IMyService service) { _service = service; } protected override string GetName(IOutboundEnvelope<TestEventOne> envelope) { if (_service.IsPriorityOrder(envelope.Message.OrderNumber)) return \"priority-orders\"; else return \"normal-orders\"; } } Custom router In the following example a custom router is used to route the messages according to their priority (a copy is also sent to a catch-all topic). Startup EndpointsConfigurator public class Startup { public void ConfigureServices(IServiceCollection services) { services .AddSilverback() .WithConnectionToMessageBroker(options => options .AddKafka()) .AddEndpointsConfigurator<MyEndpointsConfigurator>(); } } public class MyEndpointsConfigurator : IEndpointsConfigurator { public void Configure(IEndpointsConfigurationBuilder builder) => builder .AddOutbound<IPrioritizedCommand>( (message, _, endpointsDictionary) => new [] { endpointsDictionary[message.Priority.ToString()], endpointsDictionary[\"all\"] }, new Dictionary<string, Action<IKafkaProducerEndpointBuilder>> { { \"low\", endpoint => endpoint.ProduceTo(\"low-priority\") }, { \"normal\", endpoint => endpoint.ProduceTo(\"normal-priority\") }, { \"high\", endpoint => endpoint.ProduceTo(\"high-priority\") }, { \"all\", endpoint => endpoint.ProduceTo(\"all\") } }); } Alternatively, an actual router class can also be created to encapsulate the routing logic. Startup EndpointsConfigurator Router public class Startup { public void ConfigureServices(IServiceCollection services) { services .AddSilverback() .WithConnectionToMessageBroker(options => options .AddKafka()) .AddEndpointsConfigurator<MyEndpointsConfigurator>() .AddSingletonOutboundRouter<PrioritizedRouter>(); } } public class MyEndpointsConfigurator : IEndpointsConfigurator { public void Configure(IEndpointsConfigurationBuilder builder) => builder.AddOutbound<IPrioritizedCommand, PrioritizedRouter>(); } public class PrioritizedRouter : OutboundRouter<IPrioritizedCommand> { private static readonly IProducerEndpoint HighPriorityEndpoint = new KafkaProducerEndpoint(\"high-priority\") { ... }; private static readonly IProducerEndpoint NormalPriorityEndpoint = new KafkaProducerEndpoint(\"normal-priority\") { ... }; private static readonly IProducerEndpoint LowPriorityEndpoint = new KafkaProducerEndpoint(\"low-priority\") { ... }; private static readonly IProducerEndpoint AllMessagesEndpoint = new KafkaProducerEndpoint(\"all\") { ... }; public override IEnumerable<IProducerEndpoint> Endpoints { get { yield return AllMessagesEndpoint; yield return LowPriorityEndpoint; yield return NormalPriorityEndpoint; yield return HighPriorityEndpoint; } } public override IEnumerable<IProducerEndpoint> GetDestinationEndpoints( IPrioritizedCommand message, MessageHeaderCollection headers) { yield return AllMessagesEndpoint; switch (message.Priority) { case MessagePriority.Low: yield return LowPriorityEndpoint; break; case MessagePriority.High: yield return HighPriorityEndpoint; break; default: yield return NormalPriorityEndpoint; break; } } }"
  },
  "concepts/broker/producer.html": {
    "href": "concepts/broker/producer.html",
    "title": "Producer | Silverback",
    "keywords": "Producer In some cases when high throughput is important you might want to skip the IPublisher and take advantage of the several options offered by the <xref:Silverback.Messaging.Broker.IProducer> interface. Producing pre serialized messages A pre-serialized message can be produced via the normal Produce / ProduceAsync or the RawProduce / RawProduceAsync methods. The difference is that the latter skip the entire Silverback behaviors pipeline (note that it means that no chunking or other features will kick in). Non-blocking overloads These are especially important for Kafka, since the underlying library is able to batch the outgoing messages for efficiency and that improves the throughput a lot. They will complete as soon as the message has been enqueued and invoke a callback when it is successfully produced (or when it fails / times out). These overloads exist for Produce , ProduceAsync , RawProduce and RawProduceAsync . (Note that ) public class ProducerService { private readonly IProducer _producer; private readonly ILogger _logger; public ProducerService( IBroker broker, ILogger<ProducerService> logger) { _producer = broker.GetProducer(\"some-topic\"); _logger = logger; } public async Task Produce(byte[] rawMessage) { for (int i = 0; i < 100000; i++) { _producer.RawProduce( rawMessage, null, () => _logger.LogInformation($\"Produced {i}\"), ex => _logger.LogError(ex, $\"Failed to produce {i}\"); } } } Note The non-async overload with callback functions is generally the fastest option with Kafka."
  },
  "concepts/broker/rabbit/routing-key.html": {
    "href": "concepts/broker/rabbit/routing-key.html",
    "title": "Routing Key | Silverback",
    "keywords": "Routing Key With RabbitMQ a routing key can be used to route the messages to a specific queue or filter the messages in a topic. See also the routing and topics tutorials on the official RabbitMQ web site. The messages are routed according to the routing key. Silverback offers a convenient way to specify the routing key, using the RabbitRoutingKeyAttribute . public class MyMessage : IIntegrationMessage { [RabbitRoutingKey] public string Key { get; set; } ... }"
  },
  "concepts/broker/serialization.html": {
    "href": "concepts/broker/serialization.html",
    "title": "Serialization | Silverback",
    "keywords": "Serialization Being flexible when serializing and deserializing the messages sent over the message broker is crucial for interoperability and these mechanisms are therefore completely customizable. Default JSON serialization The default <xref:Silverback.Messaging.Serialization.JsonMessageSerializer> internally uses System.Text.Json to serialize the messages as JSON and encode them in UTF-8. A few headers are added to the message, in particular x-message-type is used by the <xref:Silverback.Messaging.Serialization.JsonMessageSerializer> to know the message type when deserializing it in the consumer, thus allowing messages of different types being sent over the same topic or queue. Warning The <xref:Silverback.Messaging.Serialization.JsonMessageSerializer> will obviously try to map the message to a type with the exact assembly qualified name found in the x-message-type header. It is therefore a good practice to share the message models among the services, maybe through a shared project or a nuget package. This is the suggested serialization strategy when both producer and consumer are based on Silverback but may not be ideal for interoperability. Have a look at the Message Headers section for an overview on the headers that are appended to the messages. Fixed-type JSON for interoperability If you are consuming a message coming from another system (not based on Silverback), chances are that the message type name is not being delivered as header. In that case you can resort to the typed <xref:Silverback.Messaging.Serialization.JsonMessageSerializer`1>. This serializer works like the default one seen in the previous chapter, but the message type is hard-coded, instead of being resolved according to the message header. Fluent Legacy public class MyEndpointsConfigurator : IEndpointsConfigurator { public void Configure(IEndpointsConfigurationBuilder builder) => builder .AddKafkaEndpoints(endpoints => endpoints .Configure(config => { config.BootstrapServers = \"PLAINTEXT://kafka:9092\"; }) .AddOutbound<InventoryEvent>(endpoint => endpoint .ProduceTo(\"inventory-events\") .SerializeAsJson(serializer => serializer .UseFixedType<InventoryEvent>())) // Specifying the message type will automatically // switch to the JsonMessageSerializer<TMessage> // and deserialize the specified type without // needing the type header .AddInbound<OrderEvent>(endpoint => endpoint .ConsumeFrom(\"order-events\") .Configure(config => { config.GroupId = \"my-consumer\"; })) // The following configurations is equivalent to the // previous one, but more verbose .AddInbound(endpoint => endpoint .ConsumeFrom(\"order-events\") .Configure(config => { config.GroupId = \"my-consumer\"; }) .DeserializeJson(serializer => serializer .UseFixedType<OrderEvent>()))); } public class MyEndpointsConfigurator : IEndpointsConfigurator { public void Configure(IEndpointsConfigurationBuilder builder) => builder .AddOutbound<InventoryEvent>( new KafkaProducerEndpoint(\"inventory-events\") { Configuration = new KafkaProducerConfig { BootstrapServers = \"PLAINTEXT://kafka:9092\" }, Serializer = new JsonMessageSerializer<InventoryEvent>() }) .AddInbound( new KafkaConsumerEndpoint(\"order-events\") { Configuration = new KafkaConsumerConfig { BootstrapServers = \"PLAINTEXT://kafka:9092\", GroupId = \"my-consumer\" }, Serializer = new JsonMessageSerializer<OrderEvent>() }); } JSON using Newtonsoft.Json Prior to release 3.0.0 the default <xref:Silverback.Messaging.Serialization.JsonMessageSerializer> was based on Newtonsoft.Json instead of System.Text.Json . For backward compatibility reasons and since System.Text.Json may not support all use cases covered by Newtonsoft.Json , the old serializers have been renamed to NewtonsoftJsonMessageSerializer and NewtonsoftJsonMessageSerializer<TMessage> and moved into the dedicated Silverback.Integration.Newtonsoft package. Fluent Legacy public class MyEndpointsConfigurator : IEndpointsConfigurator { public void Configure(IEndpointsConfigurationBuilder builder) => builder .AddKafkaEndpoints(endpoints => endpoints .Configure(config => { config.BootstrapServers = \"PLAINTEXT://kafka:9092\"; }) .AddOutbound<InventoryEvent>(endpoint => endpoint .ProduceTo(\"inventory-events\") .SerializeAsJsonUsingNewtonsoft()) .AddInbound(endpoint => endpoint .ConsumeFrom(\"order-events\") .Configure(config => { config.GroupId = \"my-consumer\"; }) .DeserializeJsonUsingNewtonsoft()) // Specifying the message type will automatically // switch to the NewtonsoftJsonMessageSerializer<TMessage> .AddInbound<DeliveryNotification>(endpoint => endpoint .ConsumeFrom(\"delivery-notification-events\") .Configure(config => { config.GroupId = \"my-consumer\"; }) .DeserializeJsonUsingNewtonsoft()) ); } public class MyEndpointsConfigurator : IEndpointsConfigurator { public void Configure(IEndpointsConfigurationBuilder builder) => builder .AddOutbound<InventoryEvent>( new KafkaProducerEndpoint(\"inventory-events\") { Configuration = new KafkaProducerConfig { BootstrapServers = \"PLAINTEXT://kafka:9092\" }, Serializer = new NewtonsoftJsonMessageSerializer() }) .AddInbound( new KafkaConsumerEndpoint(\"order-events\") { Configuration = new KafkaConsumerConfig { BootstrapServers = \"PLAINTEXT://kafka:9092\", GroupId = \"my-consumer\" }, Serializer = new NewtonsoftJsonMessageSerializer() }); } Apache Avro The <xref:Silverback.Messaging.Serialization.AvroMessageSerializer`1> contained in the Silverback.Integration.Kafka.SchemaRegistry package can be used to connect with a schema registry and exchange messages in Apache Avro format. Fluent Legacy public class MyEndpointsConfigurator : IEndpointsConfigurator { public void Configure(IEndpointsConfigurationBuilder builder) => builder .AddKafkaEndpoints(endpoints => endpoints .Configure(config => { config.BootstrapServers = \"PLAINTEXT://kafka:9092\"; }) .AddOutbound<InventoryEvent>(endpoint => endpoint .ProduceTo(\"inventory-events\") .SerializeAsAvro(serializer => serializer .UseType<InventoryEvent>() .Configure( schemaRegistryConfig => { schemaRegistryConfig.Url = \"localhost:8081\"; }, serializerConfig => { serializerConfig.AutoRegisterSchemas = true; }))) .AddInbound(endpoint => endpoint .ConsumeFrom(\"order-events\") .Configure(config => { config.GroupId = \"my-consumer\"; }) .DeserializeAvro(serializer => serializer .UseType<OrderEvent>() .Configure( schemaRegistryConfig => { schemaRegistryConfig.Url = \"localhost:8081\"; }, serializerConfig => { serializerConfig.AutoRegisterSchemas = true; })))); } public class MyEndpointsConfigurator : IEndpointsConfigurator { public void Configure(IEndpointsConfigurationBuilder builder) => builder .AddOutbound<InventoryEvent>( new KafkaProducerEndpoint(\"inventory-events\") { Configuration = new KafkaProducerConfig { BootstrapServers = \"PLAINTEXT://kafka:9092\" }, Serializer = new AvroMessageSerializer<InventoryEvent> { SchemaRegistryConfig = new SchemaRegistryConfig { Url = \"localhost:8081\" }, AvroSerializerConfig = new AvroSerializerConfig { AutoRegisterSchemas = true } } }) .AddInbound( new KafkaConsumerEndpoint(\"order-events\") { Configuration = new KafkaConsumerConfig { BootstrapServers = \"PLAINTEXT://kafka:9092\", GroupId = \"my-consumer\" }, Serializer = new AvroMessageSerializer<OrderEvent> { SchemaRegistryConfig = new SchemaRegistryConfig { Url = \"localhost:8081\" }, AvroSerializerConfig = new AvroSerializerConfig { AutoRegisterSchemas = true } } }); } Note The C# message models can be generated from an Avro schema using AvroGen . Note This serializer is built for Kafka but it could work with other brokers, as long as a schema registry is available. Custom serializer In some cases you may want to build your very own custom serializer implementing <xref:Silverback.Messaging.Serialization.IMessageSerializer> directly. Fluent Legacy public class MyEndpointsConfigurator : IEndpointsConfigurator { public void Configure(IEndpointsConfigurationBuilder builder) => builder .AddKafkaEndpoints(endpoints => endpoints .Configure(config => { config.BootstrapServers = \"PLAINTEXT://kafka:9092\"; }) .AddOutbound<InventoryEvent>(endpoint => endpoint .ProduceTo(\"inventory-events\") .SerializeUsing(new MyCustomSerializer())) .AddInbound(endpoint => endpoint .ConsumeFrom(\"order-events\") .Configure(config => { config.GroupId = \"my-consumer\"; }) .DeserializeUsing(new MyCustomSerializer()))); } public class MyEndpointsConfigurator : IEndpointsConfigurator { public void Configure(IEndpointsConfigurationBuilder builder) => builder .AddOutbound<InventoryEvent>( new KafkaProducerEndpoint(\"inventory-events\") { Configuration = new KafkaProducerConfig { BootstrapServers = \"PLAINTEXT://kafka:9092\" }, Serializer = new MyCustomSerialzer() }) .AddInbound( new KafkaConsumerEndpoint(\"order-events\") { Configuration = new KafkaConsumerConfig { BootstrapServers = \"PLAINTEXT://kafka:9092\", GroupId = \"my-consumer\" }, Serializer = new MyCustomSerialzer() }); } Note You may need to implement IKafkaMessageSerializer if you want to have full control over the serialization of the Kafka key as well. Binary Files Please refer to the Binary Files page if you need to produce or consume raw binary files."
  },
  "concepts/broker/streaming.html": {
    "href": "concepts/broker/streaming.html",
    "title": "Streaming | Silverback",
    "keywords": "Streaming The IMessageStreamEnumerable<TMessage> can be used to consume an endpoint in a streaming fashion and it is the only way to consume sequences (see for example batch processing ). This stream will be forwarded to the subscribed method as soon as the first message is consumed and it is then asynchronously pushed with the next messages. IMessageStreamEnumerable<TMessage> implements both IEnumerable and IAsyncEnumerable and the subscriber method can either declare an IMessageStreamEnumerable<TMessage> , an IEnumerable or an IAsyncEnumerable as argument. Since the asynchronous and I/O bound nature of this stream it is recommended to take advantage of the IAsyncEnumerable capabilities to asynchronously loop through the messages. public class StreamSubscriber { public async Task OnOrderStreamReceived( IAsyncEnumerable<OrderEvent> eventsStream) { await foreach(var orderEvent in eventsStream) { // ...process the event... } } } A single instance of IMessageStreamEnumerable<TMessage> is created and published per each queue/topic/partition and the messages are acknowledged (committed) after a single iteration completes, unless sequencing (e.g. batch processing ) is configured or a sequence is automatically recognized by Silverback (e.g. a dataset). In that case an instance is published per each sequence and the entire sequence is atomically committed. Rx (Observable) The Silverback.Core.Rx package adds the <xref:Silverback.Messaging.Messages.IMessageStreamObservable`1> that works like the IMessageStreamEnumerable<TMessage> but implements IObservable enabling the usage of Rx.NET . Startup Subscriber public class Startup { public void ConfigureServices(IServiceCollection services) { services.AddSilverback().AsObservable(); } } public class StreamSubscriber { public async Task OnOrderStreamReceived( IObservable<OrderEvent> eventsStream) { stream.Subscribe(...); } } Notes, suggestions and insights The stream will be pushed with messages as they are read from the message broker. Since the I/O bound nature of the operation you should obviously prefer to subscribe to an IAsyncEnumerable instead of an IEnumerable and in any case loop asynchronously ( await foreach or similar approach). If the sequence is interrupted because the application is disconnecting or an error occurred in another subscriber, the IEnumerator will throw an OperationCancelledException . Handle it if you need to gracefully abort or cleanup. Throwing an exception while enumerating a sequence (e.g. a BatchSequence ) will cause it to be aborted and handled according to the defined error policies . If you just break the iteration and the subscriber return, the operation will be considered successful instead and the sequence will be committed."
  },
  "concepts/broker/testing.html": {
    "href": "concepts/broker/testing.html",
    "title": "Testing | Silverback",
    "keywords": "Testing Silverback ships a mocked version of the message broker implementations on a different nuget package: Silverback.Integration.Kafka.Testing (coming soon) Silverback.Integration.RabbitMQ.Testing These packages allow to perform end-to-end tests without having to integrate with a real message broker. Unit Tests Here an example of an xUnit test built using Silverback.Integration.Kafka.Testing . public class KafkaTests { private readonly IServiceProvider _serviceProvider; // Configure DI during setup public InMemoryBrokerTests() { var services = new ServiceCollection(); // Loggers are a prerequisite services.AddSingleton<ILoggerFactory, NullLoggerFactory>(); services.AddSingleton(typeof(ILogger<>), typeof(NullLogger<>)); services // Register Silverback as usual .AddSilverback() // Register the mocked KafkaBroker .WithConnectionToMessageBroker(config => config.AddMockedKafka()) // Configure inbound and outbound endpoints .AddKafkaEndpoints(endpoints => endpoints .Configure(config => { config.BootstrapServers = \"PLAINTEXT://tests\"; }) .AddOutbound<InventoryEvent>(endpoint => endpoint .ProduceTo(\"test-topic\")) .AddInbound(endpoint => endpoint .ConsumeFrom(\"test-topic\") .Configure(config => { config.GroupId = \"my-test-consumer\"; }))) // Register the subscriber under test .AddScopedSubscriber<MySubscriber>(); // ...register all other types you need... _serviceProvider = services.BuildServiceProvider(); } [Fact] public async Task SampleTest() { // Arrange // Connect the broker await _serviceProvider.GetRequiredService<IBroker>().ConnectAsync(); // Create a producer to push to test-topic var producer = _serviceProvider .GetRequiredService<IBroker>() .GetProducer(new KafkaProducerEndpoint(\"test-topic\")); // Act await producer.ProduceAsync(new TestMessage { Content = \"hello!\" }); await producer.ProduceAsync(new TestMessage { Content = \"hello 2!\" }); // Assert // ...your assertions... } } Integration Tests Mocking the message broker is especially interesting for the integration tests, where you probably leverage the ASP.NET Core integration tests to perform a full test based on the real configuration applied in the application's startup class. The following code shows the simplest integration test possible, in which an object is published to the broker and e.g. a subscriber is called. public class IntegrationTests : IClassFixture<WebApplicationFactory<Startup>> { private readonly WebApplicationFactory<Startup> _factory; public IntegrationTests(WebApplicationFactory<Startup> factory) { _factory = factory.WithWebHostBuilder(builder => { builder.ConfigureTestServices(services => { // Replace the usual broker (KafkaBroker) // with the mocked version services.UseMockedKafka(); }); }); } [Fact] public async Task SampleTest() { // Arrange // Resolve a producer to push to test-topic var producer = _factory.Server.Host.Services .GetRequiredService<IBroker>() .GetProducer(new KafkaProducerEndpoint(\"tst-topic\")); // Act await producer.ProduceAsync(new TestMessage { Content = \"abc\" }); // Assert // ...your assertions... } } Testing helper The testing helpers (such has IKafkaTestingHelper ) contain some methods that simplify testing with the message broker, given it's asynchronous nature. public class IntegrationTests : IClassFixture<WebApplicationFactory<Startup>> { private readonly WebApplicationFactory<Startup> _factory; public IntegrationTests(WebApplicationFactory<Startup> factory) { _factory = factory.WithWebHostBuilder(builder => { builder.ConfigureTestServices(services => { services.UseMockedKafka(); }); }); } [Fact] public async Task SampleTest() { // Arrange // Resolve the IKafkaTestingHelper (used below) var testingHelper = _factory.Server.Host.Services .GetRequiredService<IKafkaTestingHelper>(); // Resolve a producer to push to test-topic var producer = testingHelper.Broker .GetProducer(new KafkaProducerEndpoint(\"tst-topic\")); // Act await producer.ProduceAsync(new TestMessage { Content = \"abc\" }); // Wait until all messages have been consumed and // committed before asserting await testingHelper.WaitUntilAllMessagesAreConsumedAsync(); // Assert // ...your assertions... } } IntegrationSpy The IIntegrationSpy ships with the Silverback.Integration.Testing package (referenced by the other Integration.Testing.* packages) and can be used to inspect all outbound and inbound messages. public class IntegrationTests : IClassFixture<WebApplicationFactory<Startup>> { private readonly WebApplicationFactory<Startup> _factory; public IntegrationTests(WebApplicationFactory<Startup> factory) { _factory = factory.WithWebHostBuilder(builder => { builder.ConfigureTestServices(services => { services .ConfigureSilverback() .UseMockedKafka() .AddIntegrationSpy(); }); }); } [Fact] public async Task SampleTest() { // Arrange var testingHelper = _factory.Server.Host.Services .GetRequiredService<IKafkaTestingHelper>(); var producer = testingHelper.Broker .GetProducer(new KafkaProducerEndpoint(\"tst-topic\")); // Act await producer.ProduceAsync(new TestMessage { Content = \"abc\" }); // Wait until all messages have been consumed and // committed before asserting await testingHelper.WaitUntilAllMessagesAreConsumedAsync(); // Assert testingHelper.Spy.OutboundEnvelopes.Should().HaveCount(1); testingHelper.Spy.InboundEnvelopes.Should().HaveCount(1); testingHelper.Spy.InboundEnvelopes[0].Message.As<TestMessage> .Content.Should().Be(\"abc\"); } } Mocked Kafka Many aspects of the Kafka broker have been mocked to replicated as much as possible the behavior you have when connected with the real broker. This new implementation supports commits, kafka events, offset reset, partitioning, rebalance, etc. The mocked topics can be retrieved and inspected via the GetTopic method of the IKafkaTestingHelper . Partitioning By default 5 partitions will be created per each topic being mocked. This number can be configured as shown in the following snippet. The setting is per broker and there's currently no way to configure each topic independently. public class IntegrationTests : IClassFixture<WebApplicationFactory<Startup>> { private readonly WebApplicationFactory<Startup> _factory; public IntegrationTests(WebApplicationFactory<Startup> factory) { _factory = factory.WithWebHostBuilder(builder => { builder.ConfigureTestServices(services => { services .UseMockedKafka(options => options .WithDefaultPartitionsCount(10)); }); }); } }"
  },
  "concepts/broker/tombstone.html": {
    "href": "concepts/broker/tombstone.html",
    "title": "Tombstone Message | Silverback",
    "keywords": "Tombstone Message A tombstone message is a message with a null body, used to indicate that the record has been deleted. This technique is for example used with Kafka topics compaction, to get rid of obsolete records. Consumer Silverback maps by default the messages with a null body to a <xref:Silverback.Messaging.Messages.Tombstone> or <xref:Silverback.Messaging.Messages.Tombstone`1>. This behavior can be changed using the SkipNullMessages or UseLegacyNullMessageHandling of the <xref:Silverback.Messaging.Configuration.IConsumerEndpointBuilder`1>, or setting the NullMessageHandlingStrategy property of the <xref:Silverback.Messaging.ConsumerEndpoint>). The <xref:Silverback.Messaging.Messages.Tombstone>/<xref:Silverback.Messaging.Messages.Tombstone`1> message exposes a single property containing the message identifier . EndpointConfigurator Subscriber public class MyEndpointsConfigurator : IEndpointsConfigurator { public void Configure(IEndpointsConfigurationBuilder builder) => builder .AddKafkaEndpoints(endpoints => endpoints .Configure(config => { config.BootstrapServers = \"PLAINTEXT://kafka:9092\"; }) .AddInbound(endpoint => endpoint .ConsumeFrom(\"catalog-events\") .Configure(config => { config.GroupId = \"my-consumer\"; }) .DeserializeJson(serializer => serializer .UseFixedType<Product>()))); } public class MySubscriber { public async Task OnProductDeleted(Tombstone<Product> tombstone) { // TODO: use tombstone.MessageId to remove the product // from the local database } } Important In order to create a typed <xref:Silverback.Messaging.Messages.Tombstone`1> it is required that either the consumed message declares the x-message-type header or a fixed type deserializer is used (as shown in the example above). Otherwise the null message will be mapped to a simple <xref:Silverback.Messaging.Messages.Tombstone>. Producer A <xref:Silverback.Messaging.Messages.Tombstone`1> (or <xref:Silverback.Messaging.Messages.Tombstone>) can also be used to produce a null message. EndpointConfigurator Publisher public class MyEndpointsConfigurator : IEndpointsConfigurator { public void Configure(IEndpointsConfigurationBuilder builder) => builder .AddKafkaEndpoints(endpoints => endpoints .Configure(config => { config.BootstrapServers = \"PLAINTEXT://kafka:9092\"; }) .AddOutbound<Product>(endpoint => endpoint .ProduceTo(\"catalog-events\"))); } public class MyService { private readonly IPublisher _publisher; public MyService(IPublisher publisher) { _publisher = publisher; } public async Task DeleteProduct(string productId) { ... await _publisher.PublishAsync(new Tombstone<Product>(productId)); } } Note The <xref:Silverback.Messaging.Messages.Tombstone`1> messages are routed according to the type parameter TMessage . This means that they will be published to the outbound endpoints papped to the same TMessage ( Product in the above example), as well as to the outbound endpoints explicitly mapping <xref:Silverback.Messaging.Messages.Tombstone>."
  },
  "concepts/broker/translating-messages.html": {
    "href": "concepts/broker/translating-messages.html",
    "title": "Translating Messages | Silverback",
    "keywords": "Translating Messages It is not uncommon to be willing to slightly transform the internal message and maybe publish only a subset of the information to the message broker (e.g. you may not want to export the full entity related to the domain event). You can easily achieve this with a subscriber that just maps/translates the messages. public class MapperService { public IMessage MapCheckoutEvent(CheckoutDomainEvent message) => new CheckoutIntegrationEvent { UserId = message.Source.UserId, Total = mesage.Source.Total, ... }; } As explained in the Publishing section, when the subscriber returns one or more messages those are automatically republished to the bus. The message is then relayed to the message broker, if its type matches with an outbound endpoint declaration."
  },
  "concepts/broker/validation.html": {
    "href": "concepts/broker/validation.html",
    "title": "Message Validation | Silverback",
    "keywords": "Message Validation Both the consumed and produced messages are being validated using the same mechanism implemented in the asp.net controllers. You can either decorate the message model with the System.ComponentModel.DataAnnotations.ValidationAttribute standard implementations, create your own attributes (extending ValidationAttribute ) or otherwise you can implement the IValidatableObject interface in your message model. Configuration The <xref:Silverback.Messaging.Validation.MessageValidationMode> can be configured per endpoint and has 3 values: LogWarning (default): a warning is logged if the message is not valid ThrowException : an exception is thrown if the message is not valid None : the validation is completely disabled Note If an invalid message is produced, the <xref:Silverback.Messaging.Validation.MessageValidationException> will be rethrown by the Produce / Publish method. In the consumer it will instead be handled like any other exception, according to the configured policies, or leading to the consumer being stopped. Warning The validation might have a - relatively speaking - big impact on the performance, depending on the object size, the number of validations to be performed and their complexity. You might want to consider disabling the validation, if performance is a critical concern in your use case. Fluent Legacy public class MyEndpointsConfigurator : IEndpointsConfigurator { public void Configure(IEndpointsConfigurationBuilder builder) => builder .AddKafkaEndpoints(endpoints => endpoints .Configure(config => { config.BootstrapServers = \"PLAINTEXT://kafka:9092\"; }) .AddOutbound<InventoryEvent>(endpoint => endpoint .ProduceTo(\"inventory-events\") .DisableMessageValidation() .AddInbound(endpoint => endpoint .ConsumeFrom(\"order-events\") .Configure(config => { config.GroupId = \"my-consumer\"; }) .ValidateMessage(throwException: true))); } public class MyEndpointsConfigurator : IEndpointsConfigurator { public void Configure(IEndpointsConfigurationBuilder builder) => builder .AddOutbound<InventoryEvent>( new KafkaProducerEndpoint(\"inventory-events\") { Configuration = new KafkaProducerConfig { BootstrapServers = \"PLAINTEXT://kafka:9092\" }, MessageValidationMode = MessageValidationMode.None }) .AddInbound( new KafkaConsumerEndpoint(\"order-events\") { Configuration = new KafkaConsumerConfig { BootstrapServers = \"PLAINTEXT://kafka:9092\", GroupId = \"my-consumer\" }, MessageValidationMode = MessageValidationMode.ThrowException }); } Validated models examples Using annotations public class CreateUserCommand { [Required] [MinLength(3)] [MaxLength(100)] public string Username { get; set; } } Implementing IValidatableObject public class CreateUserCommand : IValidatableObject { public string Username { get; set; } public IEnumerable<ValidationResult> Validate( ValidationContext validationContext) { if (Username == null || Username.Length < 3 || Username.Length > 100) { yield return new ValidationResult( \"Invalid username.\", new[] { nameof(Username) }); } } }"
  },
  "concepts/bus/behaviors.html": {
    "href": "concepts/bus/behaviors.html",
    "title": "Behaviors | Silverback",
    "keywords": "Behaviors The behaviors can be used to build a custom pipeline (similar to the asp.net pipeline), easily adding your cross-cutting concerns such as logging, validation, etc. The behaviors are implementations of the IBehavior interface and will be invoked by the IPublisher every time a message is published to the internal bus (this includes the inbound/outbound messages, but they will be wrapped into an <xref:Silverback.Messaging.Messages.IInboundEnvelope`1> or <xref:Silverback.Messaging.Messages.IOutboundEnvelope`1>). The HandleAsync method of each registered behavior is called every time a message (or a batch of messages) is published to the internal bus, passing in the collection of messages and the delegate to the next step in the pipeline. This gives you the flexibility to execute any sort of code before and after the messages have been actually published (before or after calling the next step). You can for example modify the messages before publishing them, validate them (like in the above example), add some logging / tracing, etc. The IBehavior implementation have simply to be registered for DI. IBehavior example The following example demonstrates how to use a behavior to trace the messages. Behavior Startup public class TracingBehavior : IBehavior { private readonly ITracer _tracer; public TracingBehavior(ITracer tracer) { _tracer = tracer; } public async Task<IReadOnlyCollection<object?>> HandleAsync( object message, MessageHandler next) { tracer.TraceProcessing(message); var result = await next(message); tracer.TraceProcessed(message); return result; } } public class Startup { public void ConfigureServices(IServiceCollection services) { services .AddSilverback() .AddScopedBehavior<TracingBehavior>(); } } Note <xref:Silverback.Messaging.Messages.IInboundEnvelope> and <xref:Silverback.Messaging.Messages.IOutboundEnvelope> are internally used by Silverback to wrap the messages being sent to or received from the message broker and will be received by the <xref:Silverback.Messaging.Broker.IBroker>. Those interfaces contains the message plus the additional data like endpoint, headers, offset, etc. Sorting The order in which the behaviors are executed might matter and it is possible to precisely define it implementing the ISorted interface. public class SortedBehavior : IBehavior, ISorted { public int SortIndex => 120; public Task<IReadOnlyCollection<object?>> HandleAsync( object message, MessageHandler next) { // ...your logic... return next(message); } } See also Broker behaviors pipeline"
  },
  "concepts/bus/enabling.html": {
    "href": "concepts/bus/enabling.html",
    "title": "Enabling Silverback | Silverback",
    "keywords": "Enabling Silverback Enabling the bus Silverback's main component is the internal in-memory message bus and pretty much all other features are built on top of that. The first mandatory step to start using Silverback is to register the core services (internal bus) with the .net core dependency injection. public class Startup { public void ConfigureServices(IServiceCollection services) { services.AddSilverback(); } } Configuring Silverback The AddSilverback method highlighted in the previous chapter returns an ISilverbackBuilder that exposes all the methods needed to configure Silverback and wire everything up. The several configuration options will are exhaustively presented in each dedicated section of this documentation but here is a basic sample startup. public class Startup { public void ConfigureServices(IServiceCollection services) { services .AddSilverback() .WithConnectionToMessageBroker(options => options .AddKafka()) .AddEndpointsConfigurator<OrdersEndpointsConfigurator>() .AddEndpointsConfigurator<ProductsEndpointsConfigurator>() .AddScopedSubscriber<OrderEventsSubscriber>() .AddScopedSubscriber<ProductEventsSubscriber>(); } } Note that AddSilverback should be called only once but you can use the ConfigureSilverback extension method on the IServiceCollection to retrieve the ISilverbackBuilder instance once again. Startup Orders Feature Products Feature public class Startup { public void ConfigureServices(IServiceCollection services) { services .AddSilverback() .WithConnectionToMessageBroker(options => options .AddKafka()); services .AddOrdersFeature() .AddProductsFeature(); } } public static class OrdersFeatureConfigurator { public static void AddOrdersFeature(this IServiceCollection services) { services .ConfigureSilverback() .AddEndpointsConfigurator<OrdersEndpointsConfigurator>() .AddScopedSubscriber<OrderEventsSubscriber>(); } } public static class ProductsFeatureConfigurator { public static void AddProductsFeature(this IServiceCollection services) { services .ConfigureSilverback() .AddEndpointsConfigurator<ProductsEndpointsConfigurator>() .AddScopedSubscriber<ProductEventsSubscriber>(); } }"
  },
  "concepts/bus/model.html": {
    "href": "concepts/bus/model.html",
    "title": "Creating the Message model | Silverback",
    "keywords": "Creating the Message model Basics First of all we need to create a message class. The message class can be any POCO class, it just need to be serializable. public class SampleMessage { public string Content { get; set; } } It is very much suggested to consider using the Silverback.Core.Model package (documented in the next chapter) to better organize your message and write better and more readable code. Silverback.Core.Model A hierarchy of interfaces is available in Silverback.Core.Model to help specify the meaning of each message and produce in better, cleaner and more readable code. The internal messages are being sent through the internal in-memory bus and don't leave the service scope, while the integration messages are those messages exchanged between different microservices, through a message broker like Apache Kafka or RabbitMQ. Event though strongly suggested, it's not mandatory to use the proposed hierarchy from Silverback.Core.Model and everything can be achieved using POCO classes as messages and using the generic IPublisher to publish them. In the following chapters you will find an overview of the different message types and their meaning but first of all we need to reference the Silverback.Core.Model package and register it with the dependency injection. public class Startup { public void ConfigureServices(IServiceCollection services) { services.AddSilverback().UseModel(); } } Internal Messages This messages can be used internally to the microservice bus but cannot be relayed to the message broker. See Translating Messages for a convenient way to map the internal message to an IIntegrationMessage . Events IEvent is to be used to notify thing that happened inside a service and may be of some interest for one or more other service. The events are a fire-and-forget message type and no response is expected. The IDomainEvent and IDomainEvent<TEntity> extend IEvent and the types implementing this interface are usually published only from within the domain entities (actually adding them to the internal collection and letting them be published during the save changes transaction). See also DDD and Domain Events . Commands ICommand or ICommand<TResult> are used to trigger an action in another service or component and are therefore very specific and usually consumed by one single subscriber. This messages can return a value (of type TResult). Queries IQuery<TResult> works exactly like ICommand<TResult> . This messages are obviously always returning something since they represent a request for data (query). Integration messages The IIntegrationMessage interface identifies those messages that are either published to the message broker or received through it. Note that IIntegrationMessage implements IMessage , obviously. Integration Event IIntegrationEvent can be used to export events to other microservices or, more generally, other applications. IEventPublisher can be used to publish these events and they will automatically be routed to the message broker if an outbound connector was properly configured. See Connecting to a Message Broker for details. Integration Command IIntegrationCommand is used to trigger an action on another microservices (or application). ICommandPublisher can be used to publish these messages and they will automatically be routed to the message broker if an outbound connector was properly configured. See Connecting to a Message Broker for details."
  },
  "concepts/bus/publish.html": {
    "href": "concepts/bus/publish.html",
    "title": "Publishing | Silverback",
    "keywords": "Publishing Basic Publishing To publish the message you just need an instance of IPublisher (or derived interfaces if using Silverback.Core.Model , as shown later on). using Silverback.Messaging.Publishing; public class PublishingService { private readonly IPublisher _publisher; public PublishingService(IPublisher publisher) { _publisher = publisher; } public async Task PublishSomething() { await _publisher.PublishAsync(new SampleMessage { Content = \"whatever\" }); } } The publisher always exposes a synchronous and an asynchronous version of each method. The second option is of course to be preferred to take advantage of non-blocking async/await. Return values In some cases you will of course return a response after having processed the message. public async Task<Report> PublishSomething() { var result = await _publisher.PublishAsync(new ReportQuery() { ... }); return result.Single(); } Important Please note the required call to Single() , because Silverback allows you to have multiple subscribers for the same message and therefore collect multiple return values. This is not needed if using IQueryPublisher or ICommandPublisher described in the Creating the Message model page. Silverback.Core.Model Silverback.Core.Model has been introduced in the previous page Creating the Message model . Each message type ( IEvent , ICommand / ICommand<TResult> and IQuery<TResult> ) also comes with its specialized IPublisher as quickly shown in the following sub-chapters. Events The messages implementing IEvent , IDomainEvent or IIntegrationEvent can be published using an IEventPublisher . using Silverback.Messaging.Publishing; public class PublishingService { private readonly IEventPublisher _publisher; public PublishingService(IEventPublisher publisher) { _publisher = publisher; } public async Task PublishEvent() { var myEvent = new MyEvent() { ... }; await _publisher.PublishAsync(myEvent); } } Commands The messages that implement ICommand , ICommand<TResult> or IIntegrationCommand can be published using an ICommandPublisher . Without result With result using Silverback.Messaging.Publishing; public class PublishingService { private readonly ICommandPublisher _publisher; public PublishingService(ICommandPublisher publisher) { _publisher = publisher; } public async Task ExecuteCommand() { var command = new MyCommand() { ... }; await _publisher.ExecuteAsync(command); } } using Silverback.Messaging.Publishing; public class PublishingService { private readonly ICommandPublisher _publisher; public PublishingService(ICommandPublisher publisher) { _publisher = publisher; } public async Task<MyResult> ExecuteCommand() { var command = new MyCommand() { ... }; var result = await _publisher.ExecuteAsync(command); return result; } } Queries The IQueryPublisher ca be used to publish the messages implementing the IQuery<TResult> interface. using Silverback.Messaging.Publishing; public class PublishingService { private readonly IQueryPublisher _publisher; public PublishingService(IQueryPublisher publisher) { _publisher = publisher; } public async Task<MyResult> GetResults() { var query = new MyQuery() { ... }; var result = await _publisher.ExecuteAsync(myQuery); return result; } }"
  },
  "concepts/bus/subscribe.html": {
    "href": "concepts/bus/subscribe.html",
    "title": "Subscribing | Silverback",
    "keywords": "Subscribing Now all is left to do is write a subscriber method to process the published messages. Introduction The subscription in the Silverback internal bus is based on the message type. This means that when a message is published Silverback will simply evaluate the signature of the subscribed methods and invoke the ones that accept a message of that specific type, a base type or an implemented interface. For example, given the following message structure: public abstract class OrderEvent : IEvent { ... } public class OrderCreatedEvent : OrderEvent { ... } All these subscriber methods will be invoked to handle an instance of OrderCreatedEvent : void Handle(OrderCreatedEvent message) void Handle(OrderMessage message) void Handle(IEvent message) Note It is perfectly fine to have multiple subscribers handling the same message but you have to be aware that all them will share the same DI scope (and thus the same DbContext instance). Subscriber class The default and usually preferred way to subscribe is to implement the message handling logic into a subscriber class. Such class can declare one or more public message handler methods that are automatically subscribed. All subscribers must be registered with the service provider as shown in the following example. Subscriber Startup public class SubscribingService { public async Task OnMessageReceived(SampleMessage message) { // TODO: Process message } public async Task OnOtherMessageReceived(OtherSampleMessage message) { // TODO: Process message } } public class Startup { public void ConfigureServices(IServiceCollection services) { services .AddSilverback() .AddScopedSubscriber<SubscribingService>(); } } Subscription options All public methods are automatically subscribed by default but the SubscribeAttribute can be used to decorate the non-public methods and subscribe them as well. The SubscribeAttribute can also be used to customize the subscription options, see the attribute properties for details. It is also possible to disable the automatic subscription of the public methods. public class Startup { public void ConfigureServices(IServiceCollection services) { services .AddSilverback() .AddScopedSubscriber<SubscribingService>( autoSubscribeAllPublicMethods: false) } } Delegate based subscription In some cases you may prefer to subscribe a method delegate (or an inline lambda) directly using the AddDelegateSubscriber method. public class Startup { public void ConfigureServices(IServiceCollection services) { services .AddSilverback() .AddDelegateSubscriber((SampleMessage message) => { // TODO: Process messages }); } } Supported methods and parameters The subscribed method can either be synchronous or asynchronous (returning a Task ). The first parameter must be the message and the parameter type can be the specific message, a base class or an implemented interface. Furthermore, when consuming from a message broker, it is possible to subscribe to the message stream and asynchronously enumerate through the messages, as shown in the Streaming chapter. The method can have other parameters that will be resolved using the service provider. Most useful to integrate existing code subscribing via a delegate. Delegate Subscriber public class Startup { public void ConfigureServices(IServiceCollection services) { services .AddSilverback() .AddDelegateSubscriber( (BasketCheckoutMessage message, CheckoutService service) => { service.Checkout(message.BaksetId, message.UserId) }); } } public class SubscribingService { public async Task OnMessageReceived(BasketCheckoutMessage message, CheckoutService service) { service.Checkout(message.BaksetId, message.UserId) } } Return values A subscriber can also have a return value that can be collected by the publisher. public class SubscribingService { public async Task<SampleResult> OnMessageReceived(SampleMessage message) { ... return new SampleResult(...); } } Return new messages (republishing) A subscribed method can also optionally return a message or a collection of messages (either IEnumerable , IReadOnlyCollection or IObservable , if using Silverback.Core.Rx ) that will be automatically republished to the internal bus. Single Multiple public class SubscribingService { public async Task<OtherSampleMessage> OnMessageReceived(SampleMessage message) { ... return new OtherSampleMessage { ... }; } } public class SubscribingService { public IEnumerable<IMessage> OnMessageReceived(IEnumerable<SampleMessage> messages) => messages.SelectMany(message => { yield return new OtherSampleMessage1 { ... }; yield return new OtherSampleMessage2 { ... }; }); } Silverback recognizes per default only the messages implementing IMessage but you can register your own types (you can register base types and interfaces as well). Startup Subscriber Message Model public class Startup { public void ConfigureServices(IServiceCollection services) { services .AddSilverback() .HandleMessagesOfType<ICustomMessage>(); } } public class SubscribingService { public async Task<CustomSampleMessage> OnMessageReceived(SampleMessage message) { ... return new CustomSampleMessage { ... }; } } public class CustomSampleMessage : ICustomMessage { public string SomeProperty { get; set; } }"
  },
  "concepts/dbcontext.html": {
    "href": "concepts/dbcontext.html",
    "title": "Sample DbContext (EF Core) | Silverback",
    "keywords": "Sample DbContext (EF Core) Default Tables Some features rely on data being stored in a persistent storage such as a database. This chapter highlights the DbSet 's that have to be added to your DbContext when using Silverback in combination with EF Core (via the Silverback.Core.EntityFrameworkCore ). Here a breakdown of the use cases that require a DbSet : Using an outbox table (see Outbound Endpoint ) will require a DbSet<OutboundMessage> and possibly a DbSet<Lock> , to enable horizontal scaling. Either a DbSet<StoredOffset> or a DbSet<InboundMessage> is necessary to ensure exactly-once processing (see Inbound Endpoint ). When consuming chunked messages (see Chunking ), you may want to temporary store the received chunks into a database table, until all chunks are received and the full message can be rebuilt and processed and you therefore need a DbSet<TemporaryMessageChunk> to be configured. This is what a DbContext built to support all the aforementioned features will look like. using Microsoft.EntityFrameworkCore; using Silverback.Database.Model; using Silverback.EntityFrameworkCore; namespace Sample { public class SampleDbContext : DbContext { public SampleDbContext(DbContextOptions options) : base(options) { } public DbSet<OutboxMessage> Outbox { get; set; } = null!; public DbSet<InboundLogEntry> InboundMessages { get; set; } = null!; public DbSet<StoredOffset> StoredOffsets { get; set; } = null!; public DbSet<Lock> Locks { get; set; } = null!; protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity<InboundLogEntry>() .HasKey(t => new { t.MessageId, t.ConsumerGroupName }); } } } Warning <xref:Silverback.Database.Model.InboundLogEntry> declare a composite primary key via annotation, thing that isn't supported yet by EF Core. It is therefore mandatory to explicitly redeclare their primary key via the HasKey fluent API. DDD and Transactional Messages Some additional changes are required in order for the events generated by the domain entities to be fired as part of the SaveChanges transaction. More details on this topic can be found in the DDD and Domain Events section. using Microsoft.EntityFrameworkCore; using Silverback.EntityFrameworkCore; using Silverback.Messaging.Publishing; namespace Sample { public class SampleDbContext : DbContext { private readonly DbContextEventsPublisher _eventsPublisher; public SampleDbContext(IPublisher publisher) { _eventsPublisher = new DbContextEventsPublisher(publisher, this); } public SampleDbContext(DbContextOptions options, IPublisher publisher) : base(options) { _eventsPublisher = new DbContextEventsPublisher(publisher, this); } // ...DbSet properties and OnModelCreating... public override int SaveChanges() => SaveChanges(true); public override int SaveChanges(bool acceptAllChangesOnSuccess) => _eventsPublisher.ExecuteSaveTransaction(() => base.SaveChanges(acceptAllChangesOnSuccess)); public override Task<int> SaveChangesAsync(CancellationToken cancellationToken = default) => SaveChangesAsync(true, cancellationToken); public override Task<int> SaveChangesAsync( bool acceptAllChangesOnSuccess, CancellationToken cancellationToken = default) => _eventsPublisher.ExecuteSaveTransactionAsync(() => base.SaveChangesAsync(acceptAllChangesOnSuccess, cancellationToken)); } }"
  },
  "concepts/domain-events.html": {
    "href": "concepts/domain-events.html",
    "title": "DDD and Domain Events | Silverback",
    "keywords": "DDD and Domain Events One of the core features of Silverback is the ability to publish the domain events as part of the DbContext save changes transaction in order to guarantee consistency. The Silverback.Core.Model package contains a sample implementation of a DomainEntity but you can also implement you own type. Important In case of a custom implementation the only constraint is that you must implement the IMessagesSource interface in order for Silverback to be able to access the associated events. The DomainEntity.AddEvent method adds the domain event to the events collection, to be published when the entity is saved. To enable this mechanism we just need to override the various SaveChanges methods to plug-in the DbContextEventsPublisher contained in the Silverback.Core.EntityFrameworkCore package. Sample Entity DbContext using Silverback.Domain; namespace Sample { public class Basket : DomainEntity, IAggregateRoot { private readonly List<BasketItem> _items = new List<BasketItem>(); private Basket() { } public Basket(Guid userId) { UserId = userId; Created = DateTime.UtcNow; } [Key] public int Id { get; private set; } public IEnumerable<BasketItem> Items => _items.AsReadOnly(); public Guid UserId { get; private set; } public DateTime Created { get; private set; } public DateTime? CheckoutDate { get; private set; } public void Checkout() { CheckoutDate = DateTime.UtcNow; AddEvent<BasketCheckoutEvent>(); } } } using Microsoft.EntityFrameworkCore; using Silverback.EntityFrameworkCore; using Silverback.Messaging.Publishing; namespace Sample { public class SampleDbContext : DbContext { private readonly DbContextEventsPublisher _eventsPublisher; public SampleDbContext(IPublisher publisher) { _eventsPublisher = new DbContextEventsPublisher(publisher, this); } public SampleDbContext(DbContextOptions options, IPublisher publisher) : base(options) { _eventsPublisher = new DbContextEventsPublisher(publisher, this); } public override int SaveChanges() => SaveChanges(true); public override int SaveChanges(bool acceptAllChangesOnSuccess) => _eventsPublisher.ExecuteSaveTransaction(() => base.SaveChanges(acceptAllChangesOnSuccess)); public override Task<int> SaveChangesAsync(CancellationToken cancellationToken = default) => SaveChangesAsync(true, cancellationToken); public override Task<int> SaveChangesAsync( bool acceptAllChangesOnSuccess, CancellationToken cancellationToken = default) => _eventsPublisher.ExecuteSaveTransactionAsync(() => base.SaveChangesAsync(acceptAllChangesOnSuccess, cancellationToken)); } }"
  },
  "concepts/event-sourcing.html": {
    "href": "concepts/event-sourcing.html",
    "title": "Event Sourcing | Silverback",
    "keywords": "Event Sourcing Silverback.EventSourcing is a basic implementation of an event store that perfectly integrates within the Silverback ecosystem. At the moment only a version using Entity Framework Core is implemented, allowing to store the events in a database but other implementations may be added in the future. Configuration The only needed configuration is the call to UseDbContext<TDbContext> when initializing Silverback. public class Startup { public void ConfigureServices(IServiceCollection services) { services.AddSilverback().UseDbContext<MyDbContext>() } } Creating the Event Store Creating an event store is very straightforward and requires basically just 3 components: a domain entity model, the event store model and a repository. Domain Entity model The domain entity have to extend EventSourcingDomainEntity (or a custom class implementing IEventSourcingDomainEntity ). The two generic type parameters refer to the type of the key (entity unique identifier) and the base type for the domain events (can be omited if you don't need domain events). public class Person : EventSourcingDomainEntity<int, PersonDomainEvent> { public Person() { } public Person(IReadOnlyCollection<IEntityEvent> events) : base(events) { } public string Name { get; private set; } public string SocialSecurityNumber { get; private set; } public int Age { get; private set; } public string PhoneNumber { get; private set; } } Important The domain entity must have a constructor able to rebuild the entity state from the stored events. The AddAndApplyEvent protected method must be used to add new events. public class Person : EventSourcingDomainEntity<int, PersonDomainEvent> { public void ChangeName(string newName) => AddAndApplyEvent(new NameChangedEvent { NewName = newName }); public void ChangeAge(int newAge) => AddAndApplyEvent(new AgeChangedEvent { NewAge = newAge }); public void ChangePhoneNumber(string newPhoneNumber) => AddAndApplyEvent(new PhoneNumberChangedEvent { NewPhoneNumber = newPhoneNumber }); } An Apply method is needed for each event type to modify the entity current state according to the described mutation. public class Person : EventSourcingDomainEntity<int, PersonDomainEvent> { private void Apply(NameChangedEvent @event) => Name = @event.NewName; private void Apply(AgeChangedEvent @event) => Age = @event.NewAge; private void Apply(PhoneNumberChangedEvent @event, bool isReplaying) { PhoneNumber = @event.NewPhoneNumber; // Fire domain event only if the event is new if (!isReplaying) AddEvent<PhoneNumberChangedDomainEvent>(); } } Note The apply method can be private but it must have a specific signature: its name must begin with \"Apply\" and have a parameter of the specific event type (or base type). It can also receive an additional boolean parameter ( isReplaying ) that will let you differentiate between new events and events that are being reapplied because loaded from the store. The events are just models inheriting from EntityEvent (or another custom class implementing IEntityEvent ). public class NameChangedEvent : EntityEvent { public string NewName { get; set; } } public class AgeChangedEvent : EntityEvent { public int NewAge { get; set; } } public class PhoneNumberChangedEvent : EntityEvent { public string NewPhoneNumber { get; set; } } Event Store model The event store basically consists of an EventStore entity and related event (they either inherit from EventStoreEntity and EventEntity or implement the interfaces IEventStoreEntity and IEventEntity respectively). public class PersonEventStore : EventStoreEntity<PersonEvent> { [Key] public int Id { get; set; } public string SocialSecurityNumber { get; set; } } public class PersonEvent : EventEntity { [Key] public int Id { get; private set; } } Note The event store record can be extended with extra fields (see SocialSecurityNumber in the example above) and those will be automatically set with the value of the matching propertyi in the domain entity (unless the mapping method is overridden in the repository implementing a custom logic). Important It is advised to add some indexes and a concurrency token, to ensure proper performance and consistency. A DbSet must also be mapped to the defined event store entity and that's it. public class MyDbContext : DbContext { public MyDbContext(DbContextOptions options) : base(options) { } public DbSet<PersonEventStore> Persons { get; set; } } EventStore repository The repository is the component that is storing the domain entity in form of single events, being able to rebuild it afterwards. The repository must inherit from DbContextEventStoreRepository and the 4 generic type parameters refer respectively to: the domain entity its unique key the event store entity its related event entity public class PersonEventStoreRepository : DbContextEventStoreRepository<Person, int, PersonEventStore, PersonEvent> { public PersonEventStoreRepository(DbContext dbContext) : base(dbContext) { } } Storing and retrieving entities Using the EventStoreRepository to store and retrieve domain entities is fairly simple. Have a look at the following code snippet to get an idea. public class PersonService { private readonly MyDbContext _dbContext; private readonly PersonEventStoreRepository _repository = new PersonEventStoreRepository(_dbContext); public async Task<Person> CreatePerson(string name, int age) { var person = new Person(); person.ChangeName(\"Sergio\"); person.ChangeAge(35); person = await _repository.StoreAsync(person); await _dbContext.SaveChangesAsync(); return person; } public async Task<Person> ChangePhoneNumber( int personId, string newPhoneNumber) { var person = _repository.Get(p => p.Id == personId); person.ChangePhoneNumber(newPhoneNumber); person = await _repository.StoreAsync(person); await _dbContext.SaveChangesAsync(); return person; } } Merging events / handling conflicts You may need to merge events coming from different sources and/or being received with a certain latency. In the example below the Apply method checks whether another (newer) conflicting event was added already in the meantime. private void Apply(NameChangedEvent @event, bool isReplaying) { // Skip if a newer event exists if (!isReplaying && Events.Any(e => e is NameChangedEvent && e.Timestamp > @event.Timestamp)) { return; } Name = @event.NewName; }"
  },
  "concepts/introduction.html": {
    "href": "concepts/introduction.html",
    "title": "Introduction | Silverback",
    "keywords": "Introduction What's Silverback? Silverback is essentially a bus that can be either used internally to an application or connected to a message broker to integrate different applications or microservices. Silverback is used to exchange message inside an application and/or connect to a message broker to integrate with other applications or microservices. Samples and examples This documentation is filled with examples and code snippets, plus an entire section is dedicated to fully functional ready-to-run code samples . The plan is to improve the samples section over time, adding real-world scenarios that demonstrates how to take advantage of the various Silverback features in your projects. A few notes about the code: Even though it will compile and work just fine (most of the time), it is intended for demo purpose only and don't automatically imply the best practices are being in place nor it is by any mean production ready. Sometimes some shortcuts may have been taken to keep the code compact, readable and focused on the aspect that is being highlighted. Not all examples are ported to each message broker implementation, but most of them can be adapted to work with either Kafka, MQTT or Rabbit with minimal effort (unless some broker-specific features are being used, of course). Packages Silverback is modular and delivered in multiple packages, available through nuget.org . Core Silverback.Core It implements a very simple, yet very effective, publish/subscribe in-memory bus that can be used to decouple the software parts and easily implement a Domain Driven Design approach. Silverback.Core.Model It contains some interfaces that will help organize the messages and write cleaner code, adding some semantic. It also includes a sample implementation of a base class for your domain entities. Silverback.Core.EntityFrameworkCore It contains the storage implementation to integrate Silverback with Entity Framework Core. It is needed to use a DbContext as storage for (temporary) data and to fire the domain events as part of the SaveChanges transaction. Silverback.Core.Rx Adds the possibility to create an Rx Observable over the internal bus. Integration Silverback.Integration Contains the message broker and connectors abstraction. Inbound and outbound connectors can be attached to a message broker to either export some events/commands/messages to other microservices or react to the messages fired by other microservices in the same way as internal messages are handled. Silverback.Integration.Testing Includes some utilities to help writing automated tests involving Silverback.Integration. Silverback.Integration.Kafka An implementation of Silverback.Integration for the popular Apache Kafka message broker. Silverback.Integration.Kafka.SchemaRegistry Adds the support for Apache Avro and the schema registry on top of Silverback.Integration.Kafka . Silverback.Integration.Kafka.Testing Includes a mock for the Kafka message broker to be used for in-memory testing. Silverback.Integration.MQTT An implementation of Silverback.Integration for MQTT. Silverback.Integration.MQTT.Testing Includes a mock for the MQTT message broker to be used for in-memory testing. Silverback.Integration.RabbitMQ An implementation of Silverback.Integration for the popular RabbitMQ message broker. Silverback.Integration.RabbitMQ.Testing (coming soon) Includes a mock for the RabbitMQ message broker to be used for in-memory testing. Silverback.Integration.HealthChecks Contains the extensions for Microsoft.Extensions.Diagnostics.HealthChecks to monitor the connection to the message broker. Silverback.Integration.Newtonsoft Contains the legacy implementations of <xref:Silverback.Messaging.Serialization.IMessageSerializer>, based on Newtonsoft.Json. Event Sourcing Silverback.EventSourcing Contains an implementation of an event store that perfectly integrates within the Silverback ecosystem. Glossary The following list serves as introduction to the terminology and types used in Silverback. Publisher An object that can be used to publish messages to the internal in-memory bus. It is represented by the IPublisher or (better) the more specific IEventPublisher and ICommandPublisher interfaces, that can be resolved via dependency injection. Subscriber A method (or delegate) that is subscribed to the bus and will process some (or all) of the messages that will be published or consumed from a message broker (since those messages are automatically pushed to the internal bus). Broker A message broker, like Apache Kafka or RabbitMQ. It is represented by the <xref:Silverback.Messaging.Broker.IBroker> interface and is used internally by Silverback to bind the internal bus with a message broker. It can be resolved and used directly but that shouldn't be necessary for most of the use cases. Producer An object used to publish messages to the broker. It is represented by the <xref:Silverback.Messaging.Broker.IProducer> interface. Consumer An object used to receive messages from the broker. It is represented by the <xref:Silverback.Messaging.Broker.IConsumer> interface. Endpoint Identifies a specific topic or queue. It also contains all the settings to bind to that endpoint and is therefore specific to the message broker implementation. It is represented by an implementation of the <xref:Silverback.Messaging.IEndpoint> interface. Inbound Endpoint / Consumer Endpoint An endpoint that is consumed and whose messages are relayed into the internal bus, where they can be consumed by one or more subscribers. It is represented by an implementation of the <xref:Silverback.Messaging.IConsumerEndpoint> interface such as the <xref:Silverback.Messaging.KafkaConsumerEndpoint>. Outbound Endpoint / Producer Endpoint Silverback can be configured to automatically publish some messages to the message broker, observing the internal bus and relaying the messages matching with the configure type. The outbound/producer endpoint specifies the topic or queue where those message have to be produced. It is represented by an implementation of the <xref:Silverback.Messaging.IProducerEndpoint> interface such as the <xref:Silverback.Messaging.KafkaProducerEndpoint>. Behavior Multiple behaviors are chained to build a sort of pipeline to process the messages transiting across the internal bus, the consumer or the producer. They are used to implement cross-cutting concerns, isolate responsibilities and allow for greater flexibility. Some built-in behaviors are responsible for serialization, error policies enforcement, batching, chunking, encryption, etc."
  },
  "concepts/logging.html": {
    "href": "concepts/logging.html",
    "title": "Logging | Silverback",
    "keywords": "Logging Silverback logs quite a few events that may be very useful for troubleshooting. It is recommended to set the minum log level to Information for the Silverback namespace, in order to have the important logs while avoiding too much noise. Customizing log levels The WithLogLevels configuration method can be used to tweak the log levels of each event. public class Startup { public void ConfigureServices(IServiceCollection services) { services .AddSilverback() .WithLogLevels(configurator => configurator .SetLogLevel(IntegrationLogEvents.MessageSkipped, LogLevel.Critical) .SetLogLevel(IntegrationLogEvents.ErrorProcessingInboundMessage, LogLevel.Error)); } } Each package (that writes any log) has a static class declaring each log event (see next chapter). Logged events Here is a list of all events that are being logged and their default log level. See also: CoreLogEvents <xref:Silverback.Diagnostics.IntegrationLogEvents> <xref:Silverback.Diagnostics.KafkaLogEvents> RabbitLogEvents Core Id Level Message Reference 11 Debug Discarding result of type {type} because it doesn't match the expected return type {expectedType}. SubscriberResultDiscarded 21 Information Trying to acquire lock {lockName} ({lockUniqueId})... AcquiringDistributedLock 22 Information Acquired lock {lockName} ({lockUniqueId}). DistributedLockAcquired 23 Debug Failed to acquire lock {lockName} ({lockUniqueId}). FailedToAcquireDistributedLock 24 Information Released lock {lockName} ({lockUniqueId}). DistributedLockReleased 25 Warning Failed to release lock {lockName} ({lockUniqueId}). FailedToReleaseDistributedLock 26 Error Failed to check lock {lockName} ({lockUniqueId}). FailedToCheckDistributedLock 27 Error Failed to send heartbeat for lock {lockName} ({lockUniqueId}). FailedToSendDistributedLockHeartbeat 41 Information Starting background service {backgroundService}... BackgroundServiceStarting 42 Information Lock acquired, executing background service {backgroundService}. BackgroundServiceLockAcquired 43 Error Background service {backgroundService} execution failed. BackgroundServiceException 51 Information Background service {backgroundService} stopped. RecurringBackgroundServiceStopped 52 Debug Background service {backgroundService} sleeping for {delay} milliseconds. RecurringBackgroundServiceSleeping 53 Warning Background service {backgroundService} execution failed. RecurringBackgroundServiceException Integration Id Level Message Reference 1001 Information Processing inbound message. ProcessingInboundMessage 1002 Error Error occurred processing the inbound message. ErrorProcessingInboundMessage 1003 Debug Message '{messageId}' added to {sequenceType} '{sequenceId}'. | length: {sequenceLength} MessageAddedToSequence 1004 Debug Started new {sequenceType} '{sequenceId}'. SequenceStarted 1005 Debug {sequenceType} '{sequenceId}' completed. | length: {sequenceLength} SequenceCompleted 1006 Debug The {sequenceType} '{sequenceId}' processing has been aborted. | length: {sequenceLength}, reason: {reason} SequenceProcessingAborted 1007 Error Error occurred processing the {sequenceType} '{sequenceId}'. | length: {sequenceLength} ErrorProcessingInboundSequence 1008 Warning The incomplete {sequenceType} '{sequenceId}' is aborted. | length: {sequenceLength} IncompleteSequenceAborted 1009 Warning Skipping the incomplete sequence '{sequenceId}'. The first message is missing. SkippingIncompleteSequence 1110 Warning Error occurred aborting the {sequenceType} '{sequenceId}'. ErrorAbortingInboundSequence 1011 Debug {broker} connecting to message broker... BrokerConnecting 1012 Information {broker} connected to message broker. BrokerConnected 1013 Debug {broker} disconnecting from message broker... BrokerDisconnecting 1014 Information {broker} disconnected from message broker. BrokerDisconnected 1015 Information Creating new consumer for endpoint '{endpointName}'. CreatingNewConsumer 1016 Information Creating new producer for endpoint '{endpointName}'. CreatingNewProducer 1017 Error Error occurred connecting to the message broker(s). BrokerConnectionError 1021 Debug Connected consumer to endpoint. ConsumerConnected 1022 Debug Disconnected consumer from endpoint. ConsumerDisconnected 1023 Critical Fatal error occurred processing the consumed message. The consumer will be stopped. ConsumerFatalError 1024 Warning Error occurred while disposing the consumer. ConsumerDisposingError 1025 Error Commit failed. ConsumerCommitError 1026 Error Rollback failed. ConsumerRollbackError 1127 Error Error occurred while connecting the consumer. ConsumerConnectError 1128 Error Error occurred while disconnecting the consumer. ConsumerDisconnectError 1129 Error Error occurred while (re)starting the consumer. ConsumerStartError 1130 Error Error occurred while stopping the consumer. ConsumerStopError 1131 Warning Failed to reconnect the consumer. Will retry in {retryDelay} milliseconds. ErrorReconnectingConsumer 1027 Debug Connected producer to endpoint. ProducerConnected 1028 Debug Disconnected producer from endpoint. ProducerDisconnected 1031 Information Message produced. MessageProduced 1032 Warning Error occurred producing the message. ErrorProducingMessage 1041 Trace The {policyType} will be skipped because the current failed attempts ({failedAttempts}) exceeds the configured maximum attempts ({maxFailedAttempts}). PolicyMaxFailedAttemptsExceeded 1042 Trace The {policyType} will be skipped because the {exceptionType} is not in the list of handled exceptions. PolicyExceptionNotIncluded 1043 Trace The {policyType} will be skipped because the {exceptionType} is in the list of excluded exceptions. PolicyExceptionExcluded 1044 Trace The {policyType} will be skipped because the apply rule evaluated to false. PolicyApplyRuleReturnedFalse 1045 Trace All policies have been applied but the message(s) couldn't be successfully processed. The consumer will be stopped. PolicyChainCompleted 1046 Information The message(s) will be processed again. RetryMessageProcessing 1047 Trace Waiting {delay} milliseconds before retrying to process the message(s). RetryDelayed 1048 Information The message will be moved to the endpoint '{targetEndpointName}'. MessageMoved 1049 Information The message(s) will be skipped. MessageSkipped 1050 Warning The message belongs to a {sequenceType} and cannot be moved. CannotMoveSequences 1051 Warning Error occurred while rolling back, the retry error policy cannot be applied. The consumer will be reconnected. RollbackToRetryFailed 1052 Warning Error occurred while rolling back or committing, the skip message error policy cannot be applied. The consumer will be reconnected. RollbackToSkipFailed 1061 Warning Not used anymore. ErrorInitializingActivity 1062 Information The null message will be skipped. NullMessageSkipped 1072 Information Message is being skipped since it was already processed. MessageAlreadyProcessed 1073 Debug Writing the outbound message to the transactional outbox. MessageWrittenToOutbox 1074 Trace Reading a batch of {readBatchSize} messages from the outbox queue... ReadingMessagesFromOutbox 1075 Trace The outbox is empty. OutboxEmpty 1076 Debug Processing outbox message {currentMessageIndex} of {totalMessages}. ProcessingOutboxStoredMessage 1077 Error Failed to produce the message stored in the outbox. ErrorProducingOutboxStoredMessage 1078 Error Error occurred processing the outbox. ErrorProcessingOutbox 1079 Warning An invalid message has been produced. | validation errors:{validationErrors} InvalidMessageProduced 1080 Warning An invalid message has been processed. | validation errors:{validationErrors} InvalidMessageProcessed 1101 Critical Invalid configuration for endpoint '{endpointName}'. InvalidEndpointConfiguration 1102 Critical Error occurred configuring the endpoints. | configurator: {endpointsConfiguratorName} EndpointConfiguratorError 1103 Error Error occurred invoking the callback handler(s). CallbackHandlerError 1999 Trace The actual message will vary. LowLevelTracing Kafka Id Level Message Reference 2011 Debug Consuming message: {topic}[{partition}]@{offset}. ConsumingMessage 2012 Information Partition EOF reached: {topic}[{partition}]@{offset}. EndOfPartition 2013 Warning An error occurred while trying to pull the next message. The consumer will try to recover. KafkaExceptionAutoRecovery 2014 Error An error occurred while trying to pull the next message. The consumer will be stopped. Enable auto recovery to allow Silverback to automatically try to recover (EnableAutoRecovery=true in the consumer configuration). KafkaExceptionNoAutoRecovery 2015 Warning Not used anymore. ErrorRecoveringFromKafkaException 2016 Trace Consuming canceled. ConsumingCanceled 2021 Debug Creating Confluent.Kafka.Producer... CreatingConfluentProducer 2022 Warning The message was transmitted to broker, but no acknowledgement was received. ProduceNotAcknowledged 2031 Information Assigned partition {topic}[{partition}]. PartitionAssigned 2032 Debug {topic}[{partition}] offset will be reset to {offset}. PartitionOffsetReset 2033 Information Revoked partition {topic}[{partition}] (offset was {offset}). PartitionRevoked 2034 Debug Successfully committed offset {topic}[{partition}]@{offset}. OffsetCommitted 2035 Error Error occurred committing the offset {topic}[{partition}]@{offset}: '{errorReason}' ({errorCode}). OffsetCommitError 2036 Error Fatal error in Kafka consumer: '{errorReason}' ({errorCode}). ConfluentConsumerFatalError 2037 Error Error in Kafka error handler. KafkaErrorHandlerError 2038 Debug Kafka consumer statistics received: {statistics} ConsumerStatisticsReceived 2039 Debug Kafka producer statistics received: {statistics} ProducerStatisticsReceived 2040 Error The received statistics JSON couldn't be deserialized. StatisticsDeserializationError 2041 Information Assigned partition {topic}[{partition}]@{offset}. PartitionManuallyAssigned 2042 Warning Error in Kafka consumer: '{errorReason}' ({errorCode}). ConfluentConsumerError 2043 Error Error in Kafka log handler. KafkaLogHandlerError 2050 Warning An error occurred while disconnecting the consumer. ConfluentConsumerDisconnectError 2060 Warning {sysLogLevel} event from Confluent.Kafka consumer: '{logMessage}'. -> The consumer will try to recover. PollTimeoutAutoRecovery 2061 Error {sysLogLevel} event from Confluent.Kafka consumer: '{logMessage}'. -> Enable auto recovery to allow Silverback to automatically try to recover (EnableAutoRecovery=true in the consumer configuration). PollTimeoutNoAutoRecovery 2201 Critical {sysLogLevel} event from Confluent.Kafka producer: '{logMessage}'. ConfluentProducerLogCritical 2202 Error {sysLogLevel} event from Confluent.Kafka producer: '{logMessage}'. ConfluentProducerLogError 2203 Warning {sysLogLevel} event from Confluent.Kafka producer: '{logMessage}'. ConfluentProducerLogWarning 2204 Information {sysLogLevel} event from Confluent.Kafka producer: '{logMessage}'. ConfluentProducerLogInformation 2205 Debug {sysLogLevel} event from Confluent.Kafka producer: '{logMessage}'. ConfluentProducerLogDebug 2211 Critical {sysLogLevel} event from Confluent.Kafka consumer: '{logMessage}'. ConfluentConsumerLogCritical 2212 Error {sysLogLevel} event from Confluent.Kafka consumer: '{logMessage}'. ConfluentConsumerLogError 2213 Warning {sysLogLevel} event from Confluent.Kafka consumer: '{logMessage}'. ConfluentConsumerLogWarning 2214 Information {sysLogLevel} event from Confluent.Kafka consumer: '{logMessage}'. ConfluentConsumerLogInformation 2215 Debug {sysLogLevel} event from Confluent.Kafka consumer: '{logMessage}'. ConfluentConsumerLogDebug MQTT Id Level Message Reference 4011 Debug Consuming message '{messageId}' from topic '{topic}'. ConsumingMessage 4021 Warning Error occurred connecting to the MQTT broker. | clientId: {clientId} ConnectError 4022 Debug Error occurred retrying to connect to the MQTT broker. | clientId: {clientId} ConnectRetryError 4023 Warning Connection with the MQTT broker lost. The client will try to reconnect. | clientId: {clientId} ConnectionLost 4031 Debug Producer queue processing was canceled. ProducerQueueProcessingCanceled 4101 Error Error from MqttClient ({source}): '{logMessage}'. MqttClientLogError 4102 Warning Warning from MqttClient ({source}): '{logMessage}'. MqttClientLogWarning 4103 Information Information from MqttClient ({source}): '{logMessage}'. MqttClientLogInformation 4104 Trace Verbose from MqttClient ({source}): '{logMessage}'. MqttClientLogVerbose Tracing An Activity is created: in the Consumer when a message is received (initialized with the traceparent header, if submitted) in the Producer when a message is being sent (submitting the Activity.Id in the traceparent header ) when a sequence (e.g. a BatchSequence ) is being consumed when a subscriber is being invoked (either internally or from a consumer) This allows to trace the methods execution and follow a message across different services (distributed tracing). The following table summarizes the activities and the information being tracked. Id Description / Tags Silverback.Integration.Produce A message is being produced to a message broker. Tags: messaging.message_id messaging.destination [ messaging.kafka.message_key ] [ messaging.kafka.partition ] Silverback.Integration.Consume A consumed message is being processed. Tags: messaging.message_id messaging.destination [ messaging.sequence.activity ] [ messaging.kafka.message_key ] [ messaging.kafka.partition ] Silverback.Integration.Sequence A sequence of messages is being processed. Tags: none Silverback.Core.Subscribers.InvokeSubscriber A subscriber is being invoked to process a message. Tags: SubscriberType SubscriberMethod"
  },
  "contributing.html": {
    "href": "contributing.html",
    "title": "Contributing | Silverback",
    "keywords": "Contributing You are encouraged to contribute to Silverback! Please check out the how to contribute guide for guidelines about how to proceed. Source Code The full source code is available on GitHub Versioning The Directory.Build.props file in the root of the repository contains the current version of the NuGet packages being built and referenced. The <BaseVersion> and <VersionSuffix> tags can be used to increment the current version. Commits Please try to follow the Conventional Commits specification for the commit messages. Building (NuGet packages) The nuget packages can be built locally using the powershell script under /nuget/Update.ps1 . Add the -l switch to clear the local nuget cache as well (especially useful when building the same version over and over). Testing The main solution contains quite a few unit tests and additionally some samples are implemented in a separate solution. Contributors Thank you to all the present and future contributors . You are amazing!"
  },
  "index.html": {
    "href": "index.html",
    "title": "Home | Silverback",
    "keywords": ""
  },
  "releases.html": {
    "href": "releases.html",
    "title": "Releases | Silverback",
    "keywords": "Releases 4.4.0 What's new Allow parallel processing of MQTT messages Upgrade to MQTTnet 4.3.1.873 Upgrade to Confluent.Kafka 2.2.0 Fixes Correctly set message timestamp in mocked Kafka Properly handle Kafka partitions revoked event when no partitions were assigned [ #214 ] Respect IgnoreUnhandledException when batch processing [ #216 ] 4.3.2 Fixes Fix potential message loss in OutboxWorker 4.3.1 Fixes Fix deadlock in OutboxWorker when enforceMessageOrder=true (default) 4.3.0 What's new Upgrade to MQTTnet 4.2.0.706 Upgrade to Confluent.Kafka 2.1.1 Upgrade to Newtonsoft.Json 13.0.3 Add ReasonCode and ReasonString to MqttProduceException message 4.2.1 Fixes Prevent an ObjectDisposedException to be thrown by the BrokerCallbackInvoker during application shutdown Fix possible deadlock in BatchSequence with timeout 4.2.0 What's new Upgrade to Confluent.Kafka 2.1.0 4.1.2 Fixes Fix chained error policies attempts counter 4.1.1 Fixes Fix bug in outbox producer writing to the wrong endpoint [ #165 ] 4.1.0 What's new Upgrade to Confluent.Kafka 2.0.2 Replace the deprecated package Confluent.Kafka.SchemaRegistry.Serdes with Confluent.Kafka.SchemaRegistry.Serdes.Avro Simplify the Avro serializer configuration and add samples (see Kafka - Avro ) 4.0.1 What's new Upgrade to MQTTnet 4.1.4.563 4.0.0 What's new Upgrade to MQTTnet 4.1.3.436 Upgrade to Confluent.Kafka 1.9.3 Upgrade to Newtonsoft.Json 13.0.2 Disable server-side offset commit in <xref:Silverback.Messaging.Broker.KafkaConsumer> when GroupId is not set Breaking changes Some breaking changes in MQTTnet 4 are reflected into Silverback 3.8.0 What's new Topic name resolvers can be used to filter the messages to be produce: returning null will discard the message Fixes Fix error policies not being triggered consistently when batch consuming Make IntegrationSpy fully thread-safe Prevent errors when the IKafkaPartitionsRevokedCallback is invoked during application shutdown Improve error handling during connection to MQTT 3.7.3 Fixes Support topic names with symbols (e.g. hyphens) in mocked MQTT broker 3.7.2 Fixes Correctly invoke the IKafkaOffsetCommittedCallback when auto commit is disabled [ #167 ] 3.7.1 Fixes Improve message streams abort process to avoid first chance exceptions (e.g. during dispose) 3.7.0 What's new Implement basic support for Kafka transactions via <xref:Silverback.Messaging.Broker.KafkaTransactionalProducer> (Note: this is just a first step and a more comprehensive implementation is planned for the upcoming release 4.0.0) Skip chunking when processing single chunk messages Fixes Fix possible race condition in consumer pipeline 3.6.1 Fixes Handle race condition in BatchSequence with timeout Limit consumer status history 3.6.0 What's new Handle IAsyncEnumerable<T> returned by the subscriber and republished the contained messages Enrich Kafka messages moved by the <xref:Silverback.Messaging.Inbound.ErrorHandling.MoveMessageErrorPolicy> adding some extra headers containing some information about the source topic, partition, offset, etc. (see Message Headers ) Allow filters such as the <xref:Silverback.Messaging.Subscribers.KafkaGroupIdFilterAttribute> or <xref:Silverback.Messaging.Subscribers.MqttClientIdFilterAttribute> to be added to the subscribers at runtime via the configuration API (see Multiple Consumer Groups (in same process) and Multiple Clients (in same process) ) Add overload for Publish method in the error policies that forwards the exception as well as the envelope Throw TimeoutException from KafkaTestingHelper and MqttTestingHelper Improve MQTT connection related logs (info for successful reconnect and add broker name to log messages) Support shared sessions in mocked MQTT broker Fixes Ensure each consumed message gets a unique traceId (when the traceparent header is not present) Fix memory leak in consumer Fully validate messages, including nested objects 3.5.0 What's new Log MqttClient internal events (see Logging ) Upgrade to Confluent.Kafka 1.8.2 Upgrade to MQTTnet 3.0.16 Upgrade to RabbitMQ.Client 6.2.2 Update several dependencies Fixes Fix <xref:Silverback.Messaging.Broker.MqttConsumer> reconnection issues Handle edge cases related to MQTT acknowledgment timeout in <xref:Silverback.Messaging.Broker.MqttConsumer> Allow max retries specification and error policies chains with MQTT V3 3.4.0 What's new Support encryption key rotation (see Encryption ) 3.3.1 Fixes Fix AddHeaders<TMessage> and WithKafkaKey<TMessage> not being correctly invoked by all IProducer.Produce and IProducer.ProducerAsync overloads Add endpoint friendly name to all logs 3.3.0 What's new Optimize in-memory mocked Kafka (avoid spawning too many threads) Support multiple brokers (with overlapping topic names) in mocked Kafka and MQTT Add message validation for both producer and consumer (see Message Validation ) Add new AddInbound overloads specifying message type for a more compact configuration when using the typed deserializer (see Serialization ) Fixes Invoke the Kafka partition EOF callback for all connected consumers Ignore null or empty Kafka key in producer 3.2.0 What's new Add new Kafka partition EOF callback to be notified when the end of a partition is reached by the consumer (see Kafka Events and <xref:Silverback.Messaging.Broker.Callbacks.IKafkaPartitionEofCallback>) Allow multiple calls to IKafkaConsumerEndpointBuilder.Configure or IKafkaProducerEndpointBuilder.Configure for the same endpoint Observe a grace period in the ConsumersHealthCheck to prevent false positives during a normal Kafka rebalance Add optional friendly name to the endpoints (see IEndpointBuilder .WithName and Endpoint.FriendlyName ) Allow filtering the endpoints targeted by the ConsumersHealthCheck (see AddConsumersCheck ) 3.1.1 Fixes Invoke broker callbacks during the application shutdown to allow custom code to be run when disconnecting 3.1.0 What's new Add new ways to configure headers and kafka key (see Message Headers and Kafka Partitioning and Message Key ) New callbacks for Kafka log events (see Kafka Events ) Improve consumer status tracking introducing ConsumerStatus.Ready Revert the Kafka consumer status from Ready to Connected whenever partitions are revoked or a poll timeout occurs Adapt consumer health check to monitor the new status and report unhealthy if not Ready (see Health Monitoring ) Try to automatically recover from Kafka maximum poll interval exceed errors Improve Kafka static partition assignment with resolver function and fetching the available partitions (see Kafka Partitioning and Message Key ) Upgrade to Confluent.Kafka 1.7.0 Upgrade to MQTTnet 3.0.15 Fixes Prevent possible race condition causing messages to be skipped when a RetryPolicy kicks in for messages from multiple Kafka partitions simultaneously Prevent ObjectDisposedException to be thrown when Kafka events (e.g. statistics) are fired during the application shutdown Prevent ObjectDisposedException to be thrown when Consumer.Dispose is called multiple times Properly clear the trace context ( Activity ) when reconnecting the consumer to prevent the newly started consume loop to be tracked under the current message traceId Fix wrong prefix in MQTT log event names 3.0.1 Fixes Fix <xref:Silverback.Messaging.Outbound.TransactionalOutbox.Repositories.IOutboxWriter> lifecycle [ #128 ] 3.0.0 What's new Add support for MQTT (see Connecting to a Message Broker , Inbound Endpoint , Outbound Endpoint , ...) Simplify configuration and reduce boilerplate (see Subscribing and Connecting to a Message Broker ) Simplify subscribers registration and get rid of the ISubscriber interface (see Subscribing ) Scan subscribers automatically at startup to reduce cost of first message Connect brokers and handle graceful shutdown automatically (see Connecting to a Message Broker ) Improve endpoints configuration API (see Connecting to a Message Broker ) Add IServiceCollection.ConfigureSilverback extension method to conveniently split the configuration code (see Enabling Silverback ) Refactor Silverback.Integration to support streaming Create IMessageStreamEnumerable<TMessage> (see Streaming ) Improve chunking support in conjunction with streaming, requiring only one chunk at a time to be loaded into memory Redesign sequences handling to support chunking, batch consuming and future sequences as well Improve Kafka partitions handling (see Kafka Partitioning and Message Key ) Process partitions independently and concurrently Add setting to produce to a specific partition Add setting to manually assign the consumer partitions Add option to throw an exception if no subscriber is handling a message that was published to the internal bus or was consumed from a message broker (see throwIfUnhandled argument in the IPublisher methods and ThrowIfUnhandled property in the <xref:Silverback.Messaging.IConsumerEndpoint>) Handle null messages as <xref:Silverback.Messaging.Messages.Tombstone>/<xref:Silverback.Messaging.Messages.Tombstone`1> (see Tombstone Message ) Replace Newtonsoft.Json with System.Text.Json to improve serialization and deserialization performance (the old serializers have been moved into the Silverback.Integration.Newtonsoft package, see Serialization ) Improve outbound routing customization options with endpoint name resolvers (see Outbound Messages Routing ) Add non-blocking Produce / ProduceAsync / RawProduce / RawProduceAsync overloads to <xref:Silverback.Messaging.Broker.IProducer>, better suitable for higher throughput scenarios (see Producer ) Refactor broker event handlers (see Broker Callbacks ) Expose IConsumer.StopAsync and IConsumer.StartAsync methods to pause and resume consumers Add log levels configuration (see Logging ) Improve (distributed) tracing (see Logging ) Allow header names customization (see Message Headers ) Add consumer status information and statistics (see Connecting to a Message Broker ) Add basic consumer health check (see Health Monitoring ) Allow broker behaviors to be registered as transient, meaning that an instance will be created per each producer or consumer (see Broker behaviors pipeline ) Improve code quality Enhance CI pipeline to use Roslyn analyzers Integrate SonarCloud ) Improve integration tests Increase automated tests coverage Enable nullable reference types and adjust all API Document the entire public API (see API Documentation ) Released some utilities to help writing automated tests involving Silverback.Integration (see Testing ) Upgrade to Confluent.Kafka 1.6.2 Upgrade to RabbitMQ.Client 6.2.1 Fixes Fix <xref:Silverback.Messaging.Outbound.TransactionalOutbox.OutboxWorker> not publishing custom headers [ #102 ] Breaking Changes Refactored IPublisher Removed the overloads to publish a batch of messages (see Publishing ) Cannot subscribe to collection of messages anymore (see Subscribing ), unless they are consumed from a message broker (see Streaming ) The chunks belonging to the same message must be contiguous (interleaved messages are at the moment not supported anymore) and in the same partition in case of Kafka Removed ISubscriber interface Removed BusConfigurator (moved all the configuration into the ISilverbackBuilder extension methods) Replaced BusConfigurator.Connect with ISilverbackBuilder.AddEndpointsConfigurator and ISilverbackBuilder.AddEndpoints (or ISilverbackBuilder.AddKafkaEndpoints etc.) to configure the endpoints, while the broker is connected automatically at startup (see Connecting to a Message Broker ) Replaced BusConfigurator.Subscribe methods with ISilverbackBuilder.AddDelegateSubscriber (see Subscribing ) Replaced BusConfigurator.HandleMessagesOfType methods with ISilverbackBuilder.HandleMessageOfType (see Subscribing ) BusConfigurator.ScanSubscribers is not needed anymore since it gets called automatically at startup (from an IHostedService ) Removed IServiceCollection.Add*Subscriber , IServiceCollection.Add*Behavior , IServiceCollection.Add*BrokerBehavior , IServiceCollection.AddEndpointsConfigurator , IServiceCollection.Add*OutboundRouter extension methods, use the same methods on the ISilverbackBuilder (using IServiceCollection.ConfigureSilverback to get an instance if the ISilverbackBuilder if necessary, as shown in Enabling Silverback ) Removed IBrokerOptionsBuilder.Add*BrokerBehavior , IBrokerOptionsBuilder.RegisterConfigurator , IBrokerOptionsBuilder.Add*OutboundRouter extension methods, use the same methods on the ISilverbackBuilder (using IServiceCollection.ConfigureSilverback to get an instance if the ISilverbackBuilder if necessary, as shown in Enabling Silverback ) Reorganized the Silverback.Messaging.Configuration namespace moving some broker specific types under Silverback.Messaging.Configuration.Kafka , Silverback.Messaging.Configuration.Rabbit or Silverback.Messaging.Configuration.Mqtt The visibility of some types has been changed to internal to favor a cleaner and clearer API where the public types are well documented and their backward compatibility is valued Removed Silverback prefix from exceptions name Removed the IRequest interface (it was implemented by both IQuery<TResult> and ICommand<TResult> ) Changed Impl methods suffix with Core , this affects some virtual members in the <xref:Silverback.Messaging.Broker.Broker`2> and other base classes IConsumer.Received event replaced by a callback delegate IBroker.GetConsumer and IBrokerCollection.GetConsumer methods renamed to IBroker.AddConsumer and IBrokerCollection.AddConsumer IQueueProducer and IQueueConsumer renamed to <xref:Silverback.Messaging.Outbound.TransactionalOutbox.Repositories.IOutboxWriter> and <xref:Silverback.Messaging.Outbound.TransactionalOutbox.Repositories.IOutboxReader> The messages with a null body are by default mapped to a <xref:Silverback.Messaging.Messages.Tombstone>/<xref:Silverback.Messaging.Messages.Tombstone`1> (see Tombstone Message ) Database: Moved all entities (used with Entity Framework Core) to the Silverback.Database.Model namespace Replaced InboundMessage entity with <xref:Silverback.Database.Model.InboundLogEntry> Replaced OutboundMessage entity with <xref:Silverback.Database.Model.OutboxMessage> Removed TemporaryMessageChunk Modified schema of <xref:Silverback.Database.Model.StoredOffset> entity Moved and renamed some internally used types (e.g. QueuedMessage , DbQueuedMessage , ...) Complete redesign of the error policies Removed IMessageIdProvider and all related logic: the Id or MessageId property will not be automatically initialized anymore and its value will not be used as identifier for the outbound message anymore (refer to the Message Identifier page for further details on how to set a custom message id, if needed) WithConnectionTo<> , WithConnectionToKafka , WithConnectionToRabbitMQ and WithInMemoryBroker have been removed, please use the new WithConnectionToMessageBroker and AddKafka / AddRabbit methods (see Connecting to a Message Broker ) Replaced the internal messages for the Kafka events such as partitions revoked/assigned, offset commit, error, log and statistics with event handler interfaces (see Kafka Events ) Deprecated Silverback.Integration.InMemory , use Silverback.Integration.Kafka.Testing , Silverback.Integration.RabbitMQ.Testing , etc. instead Renamed PartitioningKeyMemberAttribute to <xref:Silverback.Messaging.Messages.KafkaKeyMemberAttribute> Silverback.Integration.Configuration has been discontinued Renamed Settings property to Options in the default <xref:Silverback.Messaging.Serialization.JsonMessageSerializer> (since the switch to System.Text.Json ) Removed LogWithLevel method from <xref:Silverback.Messaging.Inbound.ErrorHandling.SkipMessageErrorPolicy>, use the new WithLogLevels configuration instead Removed Parallel option from SubscribeAttribute Renamed Offset to a more generic BrokerMessageIdentifier in the Silverback.Integration abstractions (including the envelopes) Some changes to the behaviors: Renamed Handle to HandleAsync in the IBehavior , <xref:Silverback.Messaging.Broker.Behaviors.IProducerBehavior> and <xref:Silverback.Messaging.Broker.Behaviors.IConsumerBehavior> Changed signature of the HandleAsync method (see Behaviors and Broker behaviors pipeline ) Changed some sort indexes and introduced some new broker behaviors, you may need to adjust the sort index of your custom behaviors (see Broker behaviors pipeline for the updated list of built-in behaviors) Replaced IBroker.Connect and IBroker.Disconnect with IBroker.ConnectAsync and IBroker.DisconnectAsync Some major changes to batch consuming: Removed all batch events ( BatchStartedEvent , BatchCompleteEvent , BatchProcessedEvent , BatchAbortedEvent ), refer to Streaming to learn how to leverage the new IMessageStreamEnumerable<TMessage> Setting the batch size to 1 doesn't disable batching anymore, set the Batch to null in the <xref:Silverback.Messaging.ConsumerEndpoint> to disable it When batching is enabled the messages can be subscribed only via the IMessageStreamEnumerable<TMessage> (see Streaming ), the subscribers to the single messages will not be invoked <xref:Silverback.Messaging.Sequences.Chunking.ChunkSettings> moved from Silverback.Messaging.LargeMessages namespace to Silverback.Messaging.Sequences.Chunking Replaced CoreEventIds , IntegrationEventIds , KafkaEventIds and RabbitEventIds with CoreLogEvents , <xref:Silverback.Diagnostics.IntegrationLogEvents>, <xref:Silverback.Diagnostics.KafkaLogEvents> and RabbitLogEvents (see also Logging ) Deprecated support for Entity Framework 2, only the version 3.0.1 of Silverback.Core.EntityFrameworkCore will work with Silverback 3.0.0 Modified message encryption for chunked messages and it will not be compatible with previous versions of Silverback (affects chunking+encryption only) 2.2.0 What's new Allow custom outbound routers to be registered as scoped or transient (instead of singleton only) 2.1.2 Fixes Fix delay in Retry policy [ #97 ] 2.1.1 What's new Add support for multiple message brokers (Kafka and RabbitMQ) in the same application (see Connecting to a Message Broker ) Add end-to-end message encryption (see Encryption ) Add dynamic custom routing of outbound messages (see Outbound Messages Routing ) Improve support for message headers (see Message Headers ) Add support for binary files (see Binary Files ) Improve message identifier handling: the IIntegrationMessage is not required to have an Id property anymore (the x-message-id header will still be generated and if the property exists will continue to be automatically initialized) x-first-chunk-offset header added by default (see Message Headers ) Deserialize KafkaStasticsEvent JSON and provided its content as an object (in addition to the raw JSON) Add support for Apache Avro and schema registry (see Serialization ) Upgrade to Confluent.Kafka 1.4.2 Add consumer PrefetchSize and PrefetchCount settings to RabbitConsumerEndpoint Add AcknowledgeEach to the RabbitConsumerEndpoint to define the number of message processed before sending the acknowledgment to the server Upgrade to RabbitMQ.Client 6.0.0 Improve message type resolution performance and reliability in <xref:Silverback.Messaging.Serialization.JsonMessageSerializer> Add LogWithLevel method to <xref:Silverback.Messaging.Inbound.ErrorHandling.SkipMessageErrorPolicy> to specify the desired level for the \"Message skipped\" log entry (the default is now increased to Error ) Breaking Changes These changes shouldn't affect you unless you built your own <xref:Silverback.Messaging.Broker.IBroker> implementation or are interacting at low-level with the <xref:Silverback.Messaging.Broker.IBroker> (this is why has been decided to still mark this as a minor release): The <xref:Silverback.Messaging.Broker.IBroker> interface and <xref:Silverback.Messaging.Broker.Broker`2> abstract base class have been modified to explicitly declare which endpoint type is being handled by the broker implementation The <xref:Silverback.Messaging.Serialization.IMessageSerializer> interfaces has been changed The <xref:Silverback.Messaging.Broker.Behaviors.IConsumerBehavior> and <xref:Silverback.Messaging.Broker.Behaviors.IProducerBehavior> interfaces have been changed Changed the parameters order in some less used overloads in the IBrokerOptionBuilder Announced Breaking Changes These aren't real breaking changes but some methods have been marked as deprecated and will be removed in one of the next major releases: WithConnectionTo<> , WithConnectionToKafka and WithConnectionToRabbitMQ are deprecated (they will still be supported in this version), please use the new WithConnectionToMessageBroker and AddKafka / AddRabbit methods (see Connecting to a Message Broker ) 2.0.0 What's new Create Silverback.Integration.RabbitMQ package to connect Silverback with RabbitMQ (see Connecting to a Message Broker ) Enable subscription of messages with an empty body (you must subscribe to the <xref:Silverback.Messaging.Messages.IInboundEnvelope>) [ #61 ] Add hook to manually set the Kafka partition start offset when a partition is assigned to the consumer (see Kafka Events ) [ #57 ] Support for multiple consumer groups running in the same process (see Multiple Consumer Groups (in same process) ) [ #59 ] Publish KafkaStatisticsEvent also from the <xref:Silverback.Messaging.Broker.KafkaProducer> (previously done in <xref:Silverback.Messaging.Broker.KafkaConsumer> only) Several reliability and performance related improvements Breaking Changes The <xref:Silverback.Messaging.Broker.IBroker>, <xref:Silverback.Messaging.Broker.IProducer> and <xref:Silverback.Messaging.Broker.IConsumer> interfaces have been slightly modified (it shouldn't affect you unless you built your own <xref:Silverback.Messaging.Broker.IBroker> implementation) Many interfaces (such as IBehavior ) and delegates have been slightly modified to pass around an IReadOnlyCollection instead of an IEnumerable , to avoid the possible issues related to multiple enumeration of an IEnumerable The IMessageKeyProvider interface has been renamed to IMessageIdProvider to prevent to be mistaken with the Kafka Key or Rabbit's Routing Key IInboundMessage / IOutboundMessage (plus all the related types) have been renamed to <xref:Silverback.Messaging.Messages.IInboundEnvelope>/<xref:Silverback.Messaging.Messages.IOutboundEnvelope> and the property containing the actual message has been renamed from Content to Message The MustUnwrap option has been removed from the inbound connector configuration (messages are unwrapped by default) 1.2.0 What's new Publish events to the internal bus as a consequence to the Kafka events such as partitions assigned or revoked (see Kafka Events ) [ #34 ] 1.1.0 What's new Add <xref:Silverback.Messaging.Configuration.IEndpointsConfigurator> interface to allow splitting the endpoints configuration across multiple types (see Connecting to a Message Broker ) Add support for distributed tracing (based on System.Diagnostics ) Add <xref:Silverback.Messaging.Broker.Behaviors.IProducerBehavior> and <xref:Silverback.Messaging.Broker.Behaviors.IConsumerBehavior> to create an extension point closer to the actual message broker logic (see Broker behaviors pipeline ) Breaking Changes Replaced ISortedBehavior with a generic ISorted interface 1.0.5 What's new Upgrade to Confluent.Kafka 1.3.0 Fixes Fix OutboundQueueHealthCheck [ #43 ] Remove automatic disposal of the <xref:Silverback.Messaging.Broker.KafkaProducer> when a KafkaException is thrown (creating too many instances of the producer over a short time span could lead to too many active TCP connections) Fix the bug preventing a <xref:Silverback.Messaging.KafkaConsumerEndpoint> pointing to multiple topics to be successfully subscribed 1.0.4 Fixes Fix mortal loop issue: it is finally safe to consume and produce the same type of messages from within the same process (in a natural way, without any extra configuration) Since version 1.0.0 the messages routed to an endpoint aren't forwarded to any subscriber directly Now the inbound connector has been fixed as well, preventing the inbound messages to be immediately routed once again to the outbound endpoint and eliminating all possible causes of mortal loops 1.0.3 What's new Deprecate PartitioningKeyMemberAttribute in favor of <xref:Silverback.Messaging.Messages.KafkaKeyMemberAttribute>, since the message key isn't used just for partitioning (see Kafka Partitioning and Message Key ) Fixes Forward Kafka message key as-is (not hashed anymore) to avoid possible collisions and simplify debugging 1.0.2 Fixes Reintroduce Add*Subscriber and Add*Behavior as IServiceCollection extension methods (for backward compatibility and greater flexibility) [ #41 ] Add WithInMemoryBroker and OverrideWithInMemoryBroker extension methods (see Testing ) 1.0.0 What's new Optimize message size (no wrappers anymore) Improve headers usage: identifiers, types, chunks information, etc. are now all sent in the headers Review severity of some log entries Improve and clean up internal implementation Improve exception handling (flattening of AggregateException ) Upgrade to Confluent.Kafka 1.2.2 Add automatic recovers from fatal errors in <xref:Silverback.Messaging.Broker.KafkaConsumer> (can be disabled via Endpoint configuration) Support .Net Core 3.0 and Entity Framework Core 3.0 Refactor packages (EF binding logic is now in a single package, versioned after the related EF version) Improve configuration API Improve and optimize performance (including #37 ) Improve database locks mechanism (used also to run the OutboundQueueWorker ) Fixes Fix issue requiring types not implementing IMessage to be registered with HandleMessagesOfType<T> to consume them [ #33 ] Mitigate issue causing the DistributedBackgroundService to sometime fail to acquire the database lock [ #39 ] Fix partition key value being lost when using the DeferredOutboundConnector Other small fixes to improve stability and reliability Breaking Changes By default the messages published via IPublisher that are routed to an outbound endpoint are not sent through to the internal bus and cannot therefore be subscribed locally, within the same process (see Outbound Endpoint ) Some changes in IInboundMessage and IOutboundMessage interfaces Changes to the schema of the outbox table ( Silverback.Messaging.Connectors.Model.OutboundMessage ) The configuration fluent API changed quite a bit, refer to the current documentation Important WithConnectionTo<KafkaBroker> has to be replaced with WithConnectionToKafka in order for all features to work properly. When failing to do so no message key will be generated, causing the messages to land in a random partition and/or preventing to publish to a compacted topic. (see Kafka Partitioning and Message Key ) Silverback.Integration.EntityFrameworkCore and Silverback.EventSourcing.EntityFrameworkCore have been deprecated ( Silverback.Core.EntityFrameworkCore contains all the necessary logic to use EF as store) KeyMemberAttribute has been renamed to PartitioningKeyMemberAttribute (see Connecting to a Message Broker ) 0.10.0 What's new Improve error handling: now all exceptions, including the ones thrown by the message serialzer can be handled through the error policies Improve logs: promoted some important logs to Information level, writing all processing errors as (at least) Warning and improved logged information quality (logged attributes) Add ability to modify messages and headers when moving them via <xref:Silverback.Messaging.Inbound.ErrorHandling.MoveMessageErrorPolicy> Refactor message processing to a cleaner, more extensible and predictable API and behavior Fixes Fixed several small (and not so small) issues and bugs 0.8.0 - 0.9.0 Released two versions mostly to fix bugs, do some small adjustments according to some user feedbacks and update the external dependencies (e.g. Confluent.Kafka 1.0.1). Fixes Fix exception loading error policies from JSON in Silverback.Integration.Configuration [ #24 ] 0.7.0 What's new Upgrade to Confluent.Kafka 1.0.0 Create a simple event store that perfectly integrates with the rest of the Silverback framework (see Event Sourcing ) Add Silverback.Integration.InMemory package to mock the message broker behavior in your unit tests Several small optimizations and improvements 0.6.0 What's new Add support for message headers Simplify message subscription even further: now all public methods of the types implementing the marker interface ISubscriber are automatically subscribed by default without having to annotate them with the SubscribeAttribute (this behavior is customizable) Upgrade to Confluent.Kafka 1.0.0-RC1 0.3.x - 0.5.x Some releases where done adding quite a few features. What's new Add Silverback.Integration.Configuration package to load the inbound/outbound configuration from the app.settings json Add batch processing Add parallel subscribers Add delegate subscription as an alternative to SubscribeAttribute based subscription Improve support for Rx.net Add support for legacy messages and POCO classes Add offset storage as an alternative and more optimized way to guarantee exactly once processing, storing just the offset of the last message instead of logging every message (see Inbound Endpoint ) Add behaviors as a convenient way to implement your cross-cutting concerns (like logging, validation, etc.) to be plugged into the internal bus publishing pipeline (see Behaviors ) Add message chunking to automatically split the larger messages and rebuild them on the other end (see Chunking ) ...much more...and a huge amount of refactorings Fixes Several fixes and optimizations 0.3.2 The very first public release of Silverback! It included: In-process message bus Inbound/outbound connector for message broker abstraction Kafka broker implementation Outbox table pattern implementation Exactly once processing ..."
  },
  "samples/kafka/avro.html": {
    "href": "samples/kafka/avro.html",
    "title": "Kafka - Avro | Silverback",
    "keywords": "Kafka - Avro This sample implements a producer and consumer which take advantage of the schema registry and serializes the messages as Avro. Common The message being exchanged is defined in a common project. // ------------------------------------------------------------------------------ // <auto-generated> // Generated by avrogen, version 1.7.7.5 // Changes to this file may cause incorrect behavior and will be lost if code // is regenerated // </auto-generated> // ------------------------------------------------------------------------------ using Silverback.Messaging.Messages; namespace Silverback.Examples.Messages { using System; using System.Collections.Generic; using System.Text; using global::Avro; using global::Avro.Specific; public partial class AvroMessage : ISpecificRecord { public static Schema _SCHEMA = Schema.Parse(\"{\\\"type\\\":\\\"record\\\",\\\"name\\\":\\\"AvroMessage\\\",\\\"namespace\\\":\\\"Silverback.Examples.Messages\\\",\" + \"\\\"fields\\\":[{\\\"name\\\":\\\"number\\\",\\\"type\\\":\\\"string\\\"}]}\"); private string _number; public virtual Schema Schema { get { return AvroMessage._SCHEMA; } } public string number { get { return this._number; } set { this._number = value; } } public virtual object Get(int fieldPos) { switch (fieldPos) { case 0: return this.number; default: throw new AvroRuntimeException(\"Bad index \" + fieldPos + \" in Get()\"); } } public virtual void Put(int fieldPos, object fieldValue) { switch (fieldPos) { case 0: this.number = (System.String) fieldValue; break; default: throw new AvroRuntimeException(\"Bad index \" + fieldPos + \" in Put()\"); } } } } Full source code: https://github.com/BEagle1984/silverback/tree/master/samples/Kafka/Avro.Common Producer The producer uses a hosted service to publish some messages in the background. Startup EndpointsConfigurator Background Service using Microsoft.Extensions.DependencyInjection; namespace Silverback.Samples.Kafka.Avro.Producer { public class Startup { public void ConfigureServices(IServiceCollection services) { // Enable Silverback services .AddSilverback() // Use Apache Kafka as message broker .WithConnectionToMessageBroker( options => options .AddKafka()) // Delegate the inbound/outbound endpoints configuration to a separate // class. .AddEndpointsConfigurator<EndpointsConfigurator>(); // Add the hosted service that produces the random sample messages services.AddHostedService<ProducerBackgroundService>(); } public void Configure() { } } } using Silverback.Examples.Messages; using Silverback.Messaging.Configuration; namespace Silverback.Samples.Kafka.Avro.Producer { public class EndpointsConfigurator : IEndpointsConfigurator { public void Configure(IEndpointsConfigurationBuilder builder) { builder .AddKafkaEndpoints( endpoints => endpoints // Configure the properties needed by all consumers/producers .Configure( config => { // The bootstrap server address is needed to connect config.BootstrapServers = \"PLAINTEXT://localhost:9092\"; }) // Produce the AvroMessage to the samples-avro topic .AddOutbound<AvroMessage>( endpoint => endpoint .ProduceTo(\"samples-avro\") // Configure Avro serialization .SerializeAsAvro( avro => avro.Configure( schemaRegistry => { schemaRegistry.Url = \"localhost:8081\"; }, serializer => { serializer.AutoRegisterSchemas = true; })))); } } } using System; using System.Globalization; using System.Threading; using System.Threading.Tasks; using Microsoft.Extensions.DependencyInjection; using Microsoft.Extensions.Hosting; using Microsoft.Extensions.Logging; using Silverback.Examples.Messages; using Silverback.Messaging.Broker; using Silverback.Messaging.Publishing; namespace Silverback.Samples.Kafka.Avro.Producer { public class ProducerBackgroundService : BackgroundService { private readonly IServiceScopeFactory _serviceScopeFactory; private readonly ILogger<ProducerBackgroundService> _logger; public ProducerBackgroundService( IServiceScopeFactory serviceScopeFactory, ILogger<ProducerBackgroundService> logger) { _serviceScopeFactory = serviceScopeFactory; _logger = logger; } protected override async Task ExecuteAsync(CancellationToken stoppingToken) { // Create a service scope and resolve the IPublisher // (the IPublisher cannot be resolved from the root scope and cannot // therefore be directly injected into the BackgroundService) using var scope = _serviceScopeFactory.CreateScope(); var publisher = scope.ServiceProvider.GetRequiredService<IPublisher>(); var broker = scope.ServiceProvider.GetRequiredService<IBroker>(); int number = 0; while (!stoppingToken.IsCancellationRequested) { // Check whether the connection has been established, since the // BackgroundService will start immediately, before the application // is completely bootstrapped if (!broker.IsConnected) { await Task.Delay(100, stoppingToken); continue; } await ProduceMessageAsync(publisher, ++number); await Task.Delay(100, stoppingToken); } } private async Task ProduceMessageAsync(IPublisher publisher, int number) { try { await publisher.PublishAsync( new AvroMessage { number = number.ToString(CultureInfo.InvariantCulture) }); _logger.LogInformation(\"Produced {Number}\", number); } catch (Exception ex) { _logger.LogError(ex, \"Failed to produce {Number}\", number); } } } } Full source code: https://github.com/BEagle1984/silverback/tree/master/samples/Kafka/Avro.Producer Consumer The consumer processes the messages and outputs their value to the standard output. Startup EndpointsConfigurator Subscriber using Microsoft.Extensions.DependencyInjection; namespace Silverback.Samples.Kafka.Avro.Consumer { public class Startup { public void ConfigureServices(IServiceCollection services) { // Enable Silverback services .AddSilverback() // Use Apache Kafka as message broker .WithConnectionToMessageBroker( options => options .AddKafka()) // Delegate the inbound/outbound endpoints configuration to a separate // class. .AddEndpointsConfigurator<EndpointsConfigurator>() // Register the subscribers .AddSingletonSubscriber<AvroMessageSubscriber>(); } public void Configure() { } } } using Confluent.Kafka; using Silverback.Examples.Messages; using Silverback.Messaging.Configuration; namespace Silverback.Samples.Kafka.Avro.Consumer { public class EndpointsConfigurator : IEndpointsConfigurator { public void Configure(IEndpointsConfigurationBuilder builder) { builder .AddKafkaEndpoints( endpoints => endpoints // Configure the properties needed by all consumers/producers .Configure( config => { // The bootstrap server address is needed to connect config.BootstrapServers = \"PLAINTEXT://localhost:9092\"; }) // Consume the samples-avro topic .AddInbound<AvroMessage>( endpoint => endpoint .ConsumeFrom(\"samples-avro\") // Configure Avro deserialization .DeserializeAvro( avro => avro.Configure( schemaRegistry => { schemaRegistry.Url = \"localhost:8081\"; })) .Configure( config => { // The consumer needs at least the bootstrap // server address and a group id to be able // to connect config.GroupId = \"sample-consumer\"; // AutoOffsetReset.Earliest means that the // consumer must start consuming from the // beginning of the topic, if no offset was // stored for this consumer group config.AutoOffsetReset = AutoOffsetReset.Earliest; }))); } } } using Microsoft.Extensions.Logging; using Silverback.Examples.Messages; namespace Silverback.Samples.Kafka.Avro.Consumer { public class AvroMessageSubscriber { private readonly ILogger<AvroMessageSubscriber> _logger; public AvroMessageSubscriber(ILogger<AvroMessageSubscriber> logger) { _logger = logger; } public void OnMessageReceived(AvroMessage message) => _logger.LogInformation(\"Received {MessageNumber}\", message.number); } } Full source code: https://github.com/BEagle1984/silverback/tree/master/samples/Kafka/Avro.Consumer"
  },
  "samples/kafka/basic.html": {
    "href": "samples/kafka/basic.html",
    "title": "Kafka - Basic | Silverback",
    "keywords": "Kafka - Basic This sample implements the simple possible producer and consumer. See also: Connecting to a Message Broker Common The message being exchanged is defined in a common project. namespace Silverback.Samples.Kafka.Basic.Common { public class SampleMessage { public int Number { get; set; } } } Full source code: https://github.com/BEagle1984/silverback/tree/master/samples/Kafka/Basic.Common Producer The producer uses a hosted service to publish some messages in the background. Startup EndpointsConfigurator Background Service using Microsoft.Extensions.DependencyInjection; namespace Silverback.Samples.Kafka.Basic.Producer { public class Startup { public void ConfigureServices(IServiceCollection services) { // Enable Silverback services .AddSilverback() // Use Apache Kafka as message broker .WithConnectionToMessageBroker( options => options .AddKafka()) // Delegate the inbound/outbound endpoints configuration to a separate // class. .AddEndpointsConfigurator<EndpointsConfigurator>(); // Add the hosted service that produces the random sample messages services.AddHostedService<ProducerBackgroundService>(); } public void Configure() { } } } using Silverback.Messaging.Configuration; using Silverback.Samples.Kafka.Basic.Common; namespace Silverback.Samples.Kafka.Basic.Producer { public class EndpointsConfigurator : IEndpointsConfigurator { public void Configure(IEndpointsConfigurationBuilder builder) { builder .AddKafkaEndpoints( endpoints => endpoints // Configure the properties needed by all consumers/producers .Configure( config => { // The bootstrap server address is needed to connect config.BootstrapServers = \"PLAINTEXT://localhost:9092\"; }) // Produce the SampleMessage to the samples-basic topic .AddOutbound<SampleMessage>( endpoint => endpoint .ProduceTo(\"samples-basic\"))); } } } using System; using System.Threading; using System.Threading.Tasks; using Microsoft.Extensions.DependencyInjection; using Microsoft.Extensions.Hosting; using Microsoft.Extensions.Logging; using Silverback.Messaging.Broker; using Silverback.Messaging.Publishing; using Silverback.Samples.Kafka.Basic.Common; namespace Silverback.Samples.Kafka.Basic.Producer { public class ProducerBackgroundService : BackgroundService { private readonly IServiceScopeFactory _serviceScopeFactory; private readonly ILogger<ProducerBackgroundService> _logger; public ProducerBackgroundService( IServiceScopeFactory serviceScopeFactory, ILogger<ProducerBackgroundService> logger) { _serviceScopeFactory = serviceScopeFactory; _logger = logger; } protected override async Task ExecuteAsync(CancellationToken stoppingToken) { // Create a service scope and resolve the IPublisher // (the IPublisher cannot be resolved from the root scope and cannot // therefore be directly injected into the BackgroundService) using var scope = _serviceScopeFactory.CreateScope(); var publisher = scope.ServiceProvider.GetRequiredService<IPublisher>(); var broker = scope.ServiceProvider.GetRequiredService<IBroker>(); int number = 0; while (!stoppingToken.IsCancellationRequested) { // Check whether the connection has been established, since the // BackgroundService will start immediately, before the application // is completely bootstrapped if (!broker.IsConnected) { await Task.Delay(100, stoppingToken); continue; } await ProduceMessageAsync(publisher, ++number); await Task.Delay(100, stoppingToken); } } private async Task ProduceMessageAsync(IPublisher publisher, int number) { try { await publisher.PublishAsync( new SampleMessage { Number = number }); _logger.LogInformation(\"Produced {Number}\", number); } catch (Exception ex) { _logger.LogError(ex, \"Failed to produce {Number}\", number); } } } } Full source code: https://github.com/BEagle1984/silverback/tree/master/samples/Kafka/Basic.Producer Consumer The consumer processes the messages and outputs their value to the standard output. Startup EndpointsConfigurator Subscriber using Microsoft.Extensions.DependencyInjection; namespace Silverback.Samples.Kafka.Basic.Consumer { public class Startup { public void ConfigureServices(IServiceCollection services) { // Enable Silverback services .AddSilverback() // Use Apache Kafka as message broker .WithConnectionToMessageBroker( options => options .AddKafka()) // Delegate the inbound/outbound endpoints configuration to a separate // class. .AddEndpointsConfigurator<EndpointsConfigurator>() // Register the subscribers .AddSingletonSubscriber<SampleMessageSubscriber>(); } public void Configure() { } } } using Confluent.Kafka; using Silverback.Messaging.Configuration; namespace Silverback.Samples.Kafka.Basic.Consumer { public class EndpointsConfigurator : IEndpointsConfigurator { public void Configure(IEndpointsConfigurationBuilder builder) { builder .AddKafkaEndpoints( endpoints => endpoints // Configure the properties needed by all consumers/producers .Configure( config => { // The bootstrap server address is needed to connect config.BootstrapServers = \"PLAINTEXT://localhost:9092\"; }) // Consume the samples-basic topic .AddInbound( endpoint => endpoint .ConsumeFrom(\"samples-basic\") .Configure( config => { // The consumer needs at least the bootstrap // server address and a group id to be able // to connect config.GroupId = \"sample-consumer\"; // AutoOffsetReset.Earliest means that the // consumer must start consuming from the // beginning of the topic, if no offset was // stored for this consumer group config.AutoOffsetReset = AutoOffsetReset.Earliest; }))); } } } using Microsoft.Extensions.Logging; using Silverback.Samples.Kafka.Basic.Common; namespace Silverback.Samples.Kafka.Basic.Consumer { public class SampleMessageSubscriber { private readonly ILogger<SampleMessageSubscriber> _logger; public SampleMessageSubscriber(ILogger<SampleMessageSubscriber> logger) { _logger = logger; } public void OnMessageReceived(SampleMessage message) => _logger.LogInformation(\"Received {MessageNumber}\", message.Number); } } Full source code: https://github.com/BEagle1984/silverback/tree/master/samples/Kafka/Basic.Consumer"
  },
  "samples/kafka/batch.html": {
    "href": "samples/kafka/batch.html",
    "title": "Kafka - Batch Processing | Silverback",
    "keywords": "Kafka - Batch Processing In this sample the consumed messages are processed in batch. See also: Inbound Endpoint - Batch processing Common The message being exchanged is defined in a common project. namespace Silverback.Samples.Kafka.Batch.Common { public class SampleMessage { public int Number { get; set; } } } Full source code: https://github.com/BEagle1984/silverback/tree/master/samples/Kafka/Batch.Common Producer The producer uses a hosted service to publish some messages in the background. Startup EndpointsConfigurator Background Service using Microsoft.Extensions.DependencyInjection; namespace Silverback.Samples.Kafka.Batch.Producer { public class Startup { public void ConfigureServices(IServiceCollection services) { // Enable Silverback services .AddSilverback() // Use Apache Kafka as message broker .WithConnectionToMessageBroker( options => options .AddKafka()) // Delegate the inbound/outbound endpoints configuration to a separate // class. .AddEndpointsConfigurator<EndpointsConfigurator>(); // Add the hosted service that produces the random sample messages services.AddHostedService<ProducerBackgroundService>(); } public void Configure() { } } } using Silverback.Messaging.Configuration; using Silverback.Samples.Kafka.Batch.Common; namespace Silverback.Samples.Kafka.Batch.Producer { public class EndpointsConfigurator : IEndpointsConfigurator { public void Configure(IEndpointsConfigurationBuilder builder) { builder .AddKafkaEndpoints( endpoints => endpoints // Configure the properties needed by all consumers/producers .Configure( config => { // The bootstrap server address is needed to connect config.BootstrapServers = \"PLAINTEXT://localhost:9092\"; }) // Produce the SampleMessage to the samples-batch topic .AddOutbound<SampleMessage>( endpoint => endpoint .ProduceTo(\"samples-batch\"))); } } } using System; using System.Threading; using System.Threading.Tasks; using Microsoft.Extensions.DependencyInjection; using Microsoft.Extensions.Hosting; using Microsoft.Extensions.Logging; using Silverback.Messaging.Broker; using Silverback.Messaging.Publishing; using Silverback.Samples.Kafka.Batch.Common; namespace Silverback.Samples.Kafka.Batch.Producer { public class ProducerBackgroundService : BackgroundService { private readonly IServiceScopeFactory _serviceScopeFactory; private readonly ILogger<ProducerBackgroundService> _logger; public ProducerBackgroundService( IServiceScopeFactory serviceScopeFactory, ILogger<ProducerBackgroundService> logger) { _serviceScopeFactory = serviceScopeFactory; _logger = logger; } protected override async Task ExecuteAsync(CancellationToken stoppingToken) { // Create a service scope and resolve the IPublisher // (the IPublisher cannot be resolved from the root scope and cannot // therefore be directly injected into the BackgroundService) using var scope = _serviceScopeFactory.CreateScope(); var publisher = scope.ServiceProvider.GetRequiredService<IPublisher>(); var broker = scope.ServiceProvider.GetRequiredService<IBroker>(); int number = 0; while (!stoppingToken.IsCancellationRequested) { // Check whether the connection has been established, since the // BackgroundService will start immediately, before the application // is completely bootstrapped if (!broker.IsConnected) { await Task.Delay(100, stoppingToken); continue; } await ProduceMessageAsync(publisher, ++number); await Task.Delay(50, stoppingToken); } } private async Task ProduceMessageAsync(IPublisher publisher, int number) { try { await publisher.PublishAsync( new SampleMessage { Number = number }); _logger.LogInformation(\"Produced {Number}\", number); } catch (Exception ex) { _logger.LogError(ex, \"Failed to produce {Number}\", number); } } } } Full source code: https://github.com/BEagle1984/silverback/tree/master/samples/Kafka/Batch.Producer Consumer The consumer processes the messages in batch and outputs the batch sum to the standard output. Startup EndpointsConfigurator Subscriber using Microsoft.Extensions.DependencyInjection; namespace Silverback.Samples.Kafka.Batch.Consumer { public class Startup { public void ConfigureServices(IServiceCollection services) { // Enable Silverback services .AddSilverback() // Use Apache Kafka as message broker .WithConnectionToMessageBroker( options => options .AddKafka()) // Delegate the inbound/outbound endpoints configuration to a separate // class. .AddEndpointsConfigurator<EndpointsConfigurator>() // Register the subscribers .AddSingletonSubscriber<SampleMessageBatchSubscriber>(); } public void Configure() { } } } using System; using Confluent.Kafka; using Silverback.Messaging.Configuration; namespace Silverback.Samples.Kafka.Batch.Consumer { public class EndpointsConfigurator : IEndpointsConfigurator { public void Configure(IEndpointsConfigurationBuilder builder) { builder .AddKafkaEndpoints( endpoints => endpoints // Configure the properties needed by all consumers/producers .Configure( config => { // The bootstrap server address is needed to connect config.BootstrapServers = \"PLAINTEXT://localhost:9092\"; }) // Consume the samples-batch topic .AddInbound( endpoint => endpoint .ConsumeFrom(\"samples-batch\") .Configure( config => { // The consumer needs at least the bootstrap // server address and a group id to be able // to connect config.GroupId = \"sample-consumer\"; // AutoOffsetReset.Earliest means that the // consumer must start consuming from the // beginning of the topic, if no offset was // stored for this consumer group config.AutoOffsetReset = AutoOffsetReset.Earliest; }) // Configure processing in batches of 100 messages, // with a max wait time of 5 seconds .EnableBatchProcessing(100, TimeSpan.FromSeconds(5)))); } } } using System.Collections.Generic; using System.Threading.Tasks; using Microsoft.Extensions.Logging; using Silverback.Samples.Kafka.Batch.Common; namespace Silverback.Samples.Kafka.Batch.Consumer { public class SampleMessageBatchSubscriber { private readonly ILogger<SampleMessageBatchSubscriber> _logger; public SampleMessageBatchSubscriber( ILogger<SampleMessageBatchSubscriber> logger) { _logger = logger; } public async Task OnBatchReceivedAsync(IAsyncEnumerable<SampleMessage> batch) { int sum = 0; int count = 0; await foreach (var message in batch) { sum += message.Number; count++; } _logger.LogInformation( \"Received batch of {Count} message -> sum: {Sum}\", count, sum); } } } Full source code: https://github.com/BEagle1984/silverback/tree/master/samples/Kafka/Batch.Consumer"
  },
  "samples/kafka/binaryfile-streaming.html": {
    "href": "samples/kafka/binaryfile-streaming.html",
    "title": "Kafka - Files Streaming | Silverback",
    "keywords": "Kafka - Files Streaming This sample demonstrates how to deal with raw binary contents and large messages, to transfer some files through Kafka. See also: Binary Files , Chunking Producer The producer exposes two REST API that receive the path of a local file to be streamed. The second API uses a custom BinaryFileMessage to forward further metadata (the file name in this example). Startup EndpointsConfigurator CustomBinaryFileMessage API Controller using Microsoft.AspNetCore.Builder; using Microsoft.Extensions.DependencyInjection; namespace Silverback.Samples.Kafka.BinaryFileStreaming.Producer { public class Startup { public void ConfigureServices(IServiceCollection services) { // Enable Silverback services .AddSilverback() // Use Apache Kafka as message broker .WithConnectionToMessageBroker( options => options .AddKafka()) // Delegate the inbound/outbound endpoints configuration to a separate // class. .AddEndpointsConfigurator<EndpointsConfigurator>(); // Add API controllers and SwaggerGen services.AddControllers(); services.AddSwaggerGen(); } public void Configure(IApplicationBuilder app) { // Enable middlewares to serve generated Swagger JSON and UI app.UseSwagger().UseSwaggerUI( uiOptions => { uiOptions.SwaggerEndpoint( \"/swagger/v1/swagger.json\", $\"{GetType().Assembly.FullName} API\"); }); // Enable routing and endpoints for controllers app.UseRouting(); app.UseEndpoints(endpoints => { endpoints.MapControllers(); }); } } } using Silverback.Messaging.Configuration; using Silverback.Messaging.Messages; namespace Silverback.Samples.Kafka.BinaryFileStreaming.Producer { public class EndpointsConfigurator : IEndpointsConfigurator { public void Configure(IEndpointsConfigurationBuilder builder) { builder .AddKafkaEndpoints( endpoints => endpoints // Configure the properties needed by all consumers/producers .Configure( config => { // The bootstrap server address is needed to connect config.BootstrapServers = \"PLAINTEXT://localhost:9092\"; }) // Produce the binary files to the // samples-binary-file-streaming topic .AddOutbound<BinaryFileMessage>( endpoint => endpoint // Force producing to a specific partition (0 in this // case) to be able to scale to multiple producers // writing to the same topic. Assigning a different // partition to each one will ensure that the chunks // are always contiguous. // This isn't mandatory and necessary only when // horizontally scaling the producer. // (In the final solution the \"0\" constant value // should be replaced by a configuration setting.) .ProduceTo(\"samples-binary-file-streaming\", 0) // Split the binary files into chunks of 512 kB .EnableChunking(524288))); } } } using Silverback.Messaging.Messages; namespace Silverback.Samples.Kafka.BinaryFileStreaming.Producer.Messages { public class CustomBinaryFileMessage : BinaryFileMessage { [Header(\"x-filename\")] public string? Filename { get; set; } } } using System.IO; using System.Threading.Tasks; using Microsoft.AspNetCore.Mvc; using Silverback.Messaging.Messages; using Silverback.Messaging.Publishing; using Silverback.Samples.Kafka.BinaryFileStreaming.Producer.Messages; namespace Silverback.Samples.Kafka.BinaryFileStreaming.Producer.Controllers { [ApiController] [Route(\"[controller]\")] public class ProducerController : ControllerBase { private readonly IPublisher _publisher; public ProducerController(IPublisher publisher) { _publisher = publisher; } [HttpPost(\"binary-file\")] public async Task<IActionResult> ProduceBinaryFileAsync( string filePath, string? contentType) { // Open specified file stream using var fileStream = System.IO.File.OpenRead(filePath); // Create a BinaryFileMessage that wraps the file stream var binaryFileMessage = new BinaryFileMessage(fileStream); if (!string.IsNullOrEmpty(contentType)) binaryFileMessage.ContentType = contentType; // Publish the BinaryFileMessage that will be routed to the outbound // endpoint. The FileStream will be read and produced chunk by chunk, // without the entire file being loaded into memory. await _publisher.PublishAsync(binaryFileMessage); return NoContent(); } [HttpPost(\"custom-binary-file\")] public async Task<IActionResult> ProduceBinaryFileWithCustomHeadersAsync( string filePath, string? contentType) { // Open specified file stream using var fileStream = System.IO.File.OpenRead(filePath); // Create a CustomBinaryFileMessage that wraps the file stream. The // CustomBinaryFileMessage extends the BinaryFileMessage adding an extra // Filename property that is also exported as header. var binaryFileMessage = new CustomBinaryFileMessage { Content = fileStream, Filename = Path.GetFileName(filePath) }; if (!string.IsNullOrEmpty(contentType)) binaryFileMessage.ContentType = contentType; // Publish the BinaryFileMessage that will be routed to the outbound // endpoint. The FileStream will be read and produced chunk by chunk, // without the entire file being loaded into memory. await _publisher.PublishAsync(binaryFileMessage); return NoContent(); } } } Full source code: https://github.com/BEagle1984/silverback/tree/master/samples/Kafka/BinaryFileStreaming.Producer Consumer The consumer simply streams the file to a temporary folder in the local file system. Startup EndpointsConfigurator CustomBinaryFileMessage Subscriber using Microsoft.Extensions.DependencyInjection; using Silverback.Samples.Kafka.BinaryFileStreaming.Consumer.Subscribers; namespace Silverback.Samples.Kafka.BinaryFileStreaming.Consumer { public class Startup { public void ConfigureServices(IServiceCollection services) { // Enable Silverback services .AddSilverback() // Use Apache Kafka as message broker .WithConnectionToMessageBroker( options => options .AddKafka()) // Delegate the inbound/outbound endpoints configuration to a separate // class. .AddEndpointsConfigurator<EndpointsConfigurator>() // Register the subscribers .AddSingletonSubscriber<BinaryFileSubscriber>(); } public void Configure() { } } } using Confluent.Kafka; using Silverback.Messaging.Configuration; using Silverback.Samples.Kafka.BinaryFileStreaming.Consumer.Messages; namespace Silverback.Samples.Kafka.BinaryFileStreaming.Consumer { public class EndpointsConfigurator : IEndpointsConfigurator { public void Configure(IEndpointsConfigurationBuilder builder) { builder .AddKafkaEndpoints( endpoints => endpoints // Configure the properties needed by all consumers/producers .Configure( config => { // The bootstrap server address is needed to connect config.BootstrapServers = \"PLAINTEXT://localhost:9092\"; }) // Consume the samples-binary-file-streaming topic .AddInbound( endpoint => endpoint // Manually assign the partitions to prevent the // broker to rebalance in the middle of a potentially // huge sequence of chunks. This is just an // optimization and isn't strictly necessary. // (The partitions resolver function returns the // untouched collection to assign all available // partitions.) .ConsumeFrom( \"samples-binary-file-streaming\", partitions => partitions) .Configure( config => { // The consumer needs at least the bootstrap // server address and a group id to be able // to connect config.GroupId = \"sample-consumer\"; // AutoOffsetReset.Earliest means that the // consumer must start consuming from the // beginning of the topic, if no offset was // stored for this consumer group config.AutoOffsetReset = AutoOffsetReset.Earliest; }) // Force the consumer to use the // BinaryFileMessageSerializer: this is not strictly // necessary when the messages are produced by // Silverback but it increases the interoperability, // since it doesn't have to rely on the // 'x-message-type' header value to switch to the // BinaryFileMessageSerializer. // // In this example the BinaryFileMessageSerializer is // also set to return a CustomBinaryFileMessage // instead of the normal BinaryFileMessage. This is // only needed because we want to read the custom // 'x-message-filename' header, otherwise // 'ConsumeBinaryFiles()' would work perfectly fine // (returning a basic BinaryFileMessage, without the // extra properties). .ConsumeBinaryFiles( serializer => serializer .UseModel<CustomBinaryFileMessage>()) // Retry each chunks sequence 5 times in case of an // exception .OnError(policy => policy.Retry(5)))); } } } using Silverback.Messaging.Messages; namespace Silverback.Samples.Kafka.BinaryFileStreaming.Consumer.Messages { public class CustomBinaryFileMessage : BinaryFileMessage { [Header(\"x-filename\")] public string? Filename { get; set; } } } using System; using System.IO; using System.Threading.Tasks; using Microsoft.Extensions.Logging; using Silverback.Samples.Kafka.BinaryFileStreaming.Consumer.Messages; namespace Silverback.Samples.Kafka.BinaryFileStreaming.Consumer.Subscribers { public class BinaryFileSubscriber { private const string OutputPath = \"../../temp\"; private readonly ILogger<BinaryFileSubscriber> _logger; public BinaryFileSubscriber(ILogger<BinaryFileSubscriber> logger) { _logger = logger; } public async Task OnBinaryFileMessageReceivedAsync( CustomBinaryFileMessage binaryFileMessage) { EnsureTargetFolderExists(); var filename = Guid.NewGuid().ToString(\"N\") + binaryFileMessage.Filename; _logger.LogInformation(\"Saving binary file as {Filename}...\", filename); // Create a FileStream to save the file using var fileStream = File.OpenWrite(Path.Combine(OutputPath, filename)); if (binaryFileMessage.Content != null) { // Asynchronously copy the message content to the FileStream. // The message chunks are streamed directly and the entire file is // never loaded into memory. await binaryFileMessage.Content.CopyToAsync(fileStream); } _logger.LogInformation( \"Written {FileStreamLength} bytes into {Filename}\", fileStream.Length, filename); } private static void EnsureTargetFolderExists() { if (!Directory.Exists(OutputPath)) Directory.CreateDirectory(OutputPath); } } } Full source code: https://github.com/BEagle1984/silverback/tree/master/samples/Kafka/BinaryFileStreaming.Consumer"
  },
  "samples/mqtt/basic.html": {
    "href": "samples/mqtt/basic.html",
    "title": "MQTT - Basic | Silverback",
    "keywords": "MQTT - Basic This sample implements the simple possible producer and consumer. See also: Connecting to a Message Broker Common The message being exchanged is defined in a common project. namespace Silverback.Samples.Mqtt.Basic.Common { public class SampleMessage { public int Number { get; set; } } } Full source code: https://github.com/BEagle1984/silverback/tree/master/samples/Mqtt/Basic.Common Producer The producer uses a hosted service to publish some messages in the background. Startup EndpointsConfigurator Background Service using Microsoft.Extensions.DependencyInjection; namespace Silverback.Samples.Mqtt.Basic.Producer { public class Startup { public void ConfigureServices(IServiceCollection services) { // Enable Silverback services .AddSilverback() // Use Apache Mqtt as message broker .WithConnectionToMessageBroker( options => options .AddMqtt()) // Delegate the inbound/outbound endpoints configuration to a separate // class. .AddEndpointsConfigurator<EndpointsConfigurator>(); // Add the hosted service that produces the random sample messages services.AddHostedService<ProducerBackgroundService>(); } public void Configure() { } } } using MQTTnet.Protocol; using Silverback.Messaging.Configuration; using Silverback.Samples.Mqtt.Basic.Common; namespace Silverback.Samples.Mqtt.Basic.Producer { public class EndpointsConfigurator : IEndpointsConfigurator { public void Configure(IEndpointsConfigurationBuilder builder) { builder .AddMqttEndpoints( endpoints => endpoints // Configure the client options .Configure( config => config .WithClientId(\"samples.basic.producer\") .ConnectViaTcp(\"localhost\")) // Produce the SampleMessage to the samples-basic topic .AddOutbound<SampleMessage>( endpoint => endpoint .ProduceTo(\"samples/basic\") .WithQualityOfServiceLevel( MqttQualityOfServiceLevel.AtLeastOnce) .Retain())); } } } using System; using System.Threading; using System.Threading.Tasks; using Microsoft.Extensions.DependencyInjection; using Microsoft.Extensions.Hosting; using Microsoft.Extensions.Logging; using Silverback.Messaging.Broker; using Silverback.Messaging.Publishing; using Silverback.Samples.Mqtt.Basic.Common; namespace Silverback.Samples.Mqtt.Basic.Producer { public class ProducerBackgroundService : BackgroundService { private readonly IServiceScopeFactory _serviceScopeFactory; private readonly ILogger<ProducerBackgroundService> _logger; public ProducerBackgroundService( IServiceScopeFactory serviceScopeFactory, ILogger<ProducerBackgroundService> logger) { _serviceScopeFactory = serviceScopeFactory; _logger = logger; } protected override async Task ExecuteAsync(CancellationToken stoppingToken) { // Create a service scope and resolve the IPublisher // (the IPublisher cannot be resolved from the root scope and cannot // therefore be directly injected into the BackgroundService) using var scope = _serviceScopeFactory.CreateScope(); var publisher = scope.ServiceProvider.GetRequiredService<IPublisher>(); var broker = scope.ServiceProvider.GetRequiredService<IBroker>(); int number = 0; while (!stoppingToken.IsCancellationRequested) { // Check whether the connection has been established, since the // BackgroundService will start immediately, before the application // is completely bootstrapped if (!broker.IsConnected) { await Task.Delay(100, stoppingToken); continue; } await ProduceMessageAsync(publisher, ++number); await Task.Delay(100, stoppingToken); } } private async Task ProduceMessageAsync(IPublisher publisher, int number) { try { await publisher.PublishAsync( new SampleMessage { Number = number }); _logger.LogInformation(\"Produced {Number}\", number); } catch (Exception ex) { _logger.LogError(ex, \"Failed to produce {Number}\", number); } } } } Full source code: https://github.com/BEagle1984/silverback/tree/master/samples/Mqtt/Basic.Producer Consumer The consumer processes the messages and outputs their value to the standard output. Startup EndpointsConfigurator Subscriber using Microsoft.Extensions.DependencyInjection; namespace Silverback.Samples.Mqtt.Basic.Consumer { public class Startup { public void ConfigureServices(IServiceCollection services) { // Enable Silverback services .AddSilverback() // Use Apache Mqtt as message broker .WithConnectionToMessageBroker( options => options .AddMqtt()) // Delegate the inbound/outbound endpoints configuration to a separate // class. .AddEndpointsConfigurator<EndpointsConfigurator>() // Register the subscribers .AddSingletonSubscriber<SampleMessageSubscriber>(); } public void Configure() { } } } using MQTTnet.Protocol; using Silverback.Messaging.Configuration; using Silverback.Samples.Mqtt.Basic.Common; namespace Silverback.Samples.Mqtt.Basic.Consumer { public class EndpointsConfigurator : IEndpointsConfigurator { public void Configure(IEndpointsConfigurationBuilder builder) { builder .AddMqttEndpoints( endpoints => endpoints // Configure the client options .Configure( config => config .WithClientId(\"samples.basic.consumer\") .ConnectViaTcp(\"localhost\") // Send last will message if disconnecting // ungracefully .SendLastWillMessage( lastWill => lastWill .Message(new TestamentMessage()) .ProduceTo(\"samples/testaments\"))) // Consume the samples/basic topic .AddInbound( endpoint => endpoint .ConsumeFrom(\"samples/basic\") .WithQualityOfServiceLevel( MqttQualityOfServiceLevel.AtLeastOnce) // Silently skip the messages in case of exception .OnError(policy => policy.Skip()))); } } } using Microsoft.Extensions.Logging; using Silverback.Samples.Mqtt.Basic.Common; namespace Silverback.Samples.Mqtt.Basic.Consumer { public class SampleMessageSubscriber { private readonly ILogger<SampleMessageSubscriber> _logger; public SampleMessageSubscriber(ILogger<SampleMessageSubscriber> logger) { _logger = logger; } public void OnMessageReceived(SampleMessage message) => _logger.LogInformation(\"Received {MessageNumber}\", message.Number); } } Full source code: https://github.com/BEagle1984/silverback/tree/master/samples/Mqtt/Basic.Consumer"
  },
  "samples/mqtt/basic-v3.html": {
    "href": "samples/mqtt/basic-v3.html",
    "title": "MQTT - Basic (v3) | Silverback",
    "keywords": "MQTT - Basic (v3) This sample implements the simple possible producer and consumer, but using MQTT protocol version 3. See also: Connecting to a Message Broker Common The message being exchanged is defined in a common project. namespace Silverback.Samples.Mqtt.Basic.Common { public class SampleMessage { public int Number { get; set; } } } Full source code: https://github.com/BEagle1984/silverback/tree/master/samples/Mqtt/Basic.Common Producer The producer uses a hosted service to publish some messages in the background. Startup EndpointsConfigurator Background Service using Microsoft.Extensions.DependencyInjection; namespace Silverback.Samples.Mqtt.Basic.ProducerV3 { public class Startup { public void ConfigureServices(IServiceCollection services) { // Enable Silverback services .AddSilverback() // Use Apache Mqtt as message broker .WithConnectionToMessageBroker( options => options .AddMqtt()) // Delegate the inbound/outbound endpoints configuration to a separate // class. .AddEndpointsConfigurator<EndpointsConfigurator>(); // Add the hosted service that produces the random sample messages services.AddHostedService<ProducerBackgroundService>(); } public void Configure() { } } } using MQTTnet.Formatter; using MQTTnet.Protocol; using Silverback.Messaging.Configuration; using Silverback.Samples.Mqtt.Basic.Common; namespace Silverback.Samples.Mqtt.Basic.ProducerV3 { public class EndpointsConfigurator : IEndpointsConfigurator { public void Configure(IEndpointsConfigurationBuilder builder) { builder .AddMqttEndpoints( endpoints => endpoints // Configure the client options .Configure( config => config .WithClientId(\"samples.basic.producer\") .ConnectViaTcp(\"localhost\") .UseProtocolVersion(MqttProtocolVersion.V310)) // Produce the SampleMessage to the samples-basic topic .AddOutbound<SampleMessage>( endpoint => endpoint .ProduceTo(\"samples/basic\") .WithQualityOfServiceLevel( MqttQualityOfServiceLevel.AtLeastOnce) .Retain())); } } } using System; using System.Threading; using System.Threading.Tasks; using Microsoft.Extensions.DependencyInjection; using Microsoft.Extensions.Hosting; using Microsoft.Extensions.Logging; using Silverback.Messaging.Broker; using Silverback.Messaging.Publishing; using Silverback.Samples.Mqtt.Basic.Common; namespace Silverback.Samples.Mqtt.Basic.ProducerV3 { public class ProducerBackgroundService : BackgroundService { private readonly IServiceScopeFactory _serviceScopeFactory; private readonly ILogger<ProducerBackgroundService> _logger; public ProducerBackgroundService( IServiceScopeFactory serviceScopeFactory, ILogger<ProducerBackgroundService> logger) { _serviceScopeFactory = serviceScopeFactory; _logger = logger; } protected override async Task ExecuteAsync(CancellationToken stoppingToken) { // Create a service scope and resolve the IPublisher // (the IPublisher cannot be resolved from the root scope and cannot // therefore be directly injected into the BackgroundService) using var scope = _serviceScopeFactory.CreateScope(); var publisher = scope.ServiceProvider.GetRequiredService<IPublisher>(); var broker = scope.ServiceProvider.GetRequiredService<IBroker>(); int number = 0; while (!stoppingToken.IsCancellationRequested) { // Check whether the connection has been established, since the // BackgroundService will start immediately, before the application // is completely bootstrapped if (!broker.IsConnected) { await Task.Delay(100, stoppingToken); continue; } await ProduceMessageAsync(publisher, ++number); await Task.Delay(100, stoppingToken); } } private async Task ProduceMessageAsync(IPublisher publisher, int number) { try { await publisher.PublishAsync( new SampleMessage { Number = number }); _logger.LogInformation(\"Produced {Number}\", number); } catch (Exception ex) { _logger.LogError(ex, \"Failed to produce {Number}\", number); } } } } Full source code: https://github.com/BEagle1984/silverback/tree/master/samples/Mqtt/Basic.ProducerV3 Consumer The consumer processes the messages and outputs their value to the standard output. Startup EndpointsConfigurator Subscriber using Microsoft.Extensions.DependencyInjection; namespace Silverback.Samples.Mqtt.Basic.ConsumerV3 { public class Startup { public void ConfigureServices(IServiceCollection services) { // Enable Silverback services .AddSilverback() // Use Apache Mqtt as message broker .WithConnectionToMessageBroker( options => options .AddMqtt()) // Delegate the inbound/outbound endpoints configuration to a separate // class. .AddEndpointsConfigurator<EndpointsConfigurator>() // Register the subscribers .AddSingletonSubscriber<SampleMessageSubscriber>(); } public void Configure() { } } } using MQTTnet.Formatter; using MQTTnet.Protocol; using Silverback.Messaging.Configuration; using Silverback.Samples.Mqtt.Basic.Common; namespace Silverback.Samples.Mqtt.Basic.ConsumerV3 { public class EndpointsConfigurator : IEndpointsConfigurator { public void Configure(IEndpointsConfigurationBuilder builder) { builder .AddMqttEndpoints( endpoints => endpoints // Configure the client options .Configure( config => config .WithClientId(\"samples.basic.consumer\") .ConnectViaTcp(\"localhost\") .UseProtocolVersion(MqttProtocolVersion.V310) // Send last will message if disconnecting // ungracefully .SendLastWillMessage( lastWill => lastWill .Message(new TestamentMessage()) .ProduceTo(\"samples/testaments\"))) // Consume the samples/basic topic // Note: It is mandatory to specify the message type, since // MQTT 3 doesn't support message headers (aka user // properties) .AddInbound<SampleMessage>( endpoint => endpoint .ConsumeFrom(\"samples/basic\") .WithQualityOfServiceLevel( MqttQualityOfServiceLevel.AtLeastOnce) // Silently skip the messages in case of exception .OnError(policy => policy.Skip()))); } } } using Microsoft.Extensions.Logging; using Silverback.Samples.Mqtt.Basic.Common; namespace Silverback.Samples.Mqtt.Basic.ConsumerV3 { public class SampleMessageSubscriber { private readonly ILogger<SampleMessageSubscriber> _logger; public SampleMessageSubscriber(ILogger<SampleMessageSubscriber> logger) { _logger = logger; } public void OnMessageReceived(SampleMessage message) => _logger.LogInformation(\"Received {MessageNumber}\", message.Number); } } Full source code: https://github.com/BEagle1984/silverback/tree/master/samples/Mqtt/Basic.ConsumerV3"
  },
  "samples/mqtt/binaryfile-streaming.html": {
    "href": "samples/mqtt/binaryfile-streaming.html",
    "title": "MQTT - Files Streaming | Silverback",
    "keywords": "MQTT - Files Streaming This sample demonstrates how to deal with raw binary contents and large messages, to transfer some files through Mqtt. See also: Binary Files , Chunking Producer The producer exposes two REST API that receive the path of a local file to be streamed. The second API uses a custom BinaryFileMessage to forward further metadata (the file name in this example). Startup EndpointsConfigurator CustomBinaryFileMessage API Controller using Microsoft.AspNetCore.Builder; using Microsoft.Extensions.DependencyInjection; namespace Silverback.Samples.Mqtt.BinaryFileStreaming.Producer { public class Startup { public void ConfigureServices(IServiceCollection services) { // Enable Silverback services .AddSilverback() // Use Apache Mqtt as message broker .WithConnectionToMessageBroker( options => options .AddMqtt()) // Delegate the inbound/outbound endpoints configuration to a separate // class. .AddEndpointsConfigurator<EndpointsConfigurator>(); // Add API controllers and SwaggerGen services.AddControllers(); services.AddSwaggerGen(); } public void Configure(IApplicationBuilder app) { // Enable middlewares to serve generated Swagger JSON and UI app.UseSwagger().UseSwaggerUI( uiOptions => { uiOptions.SwaggerEndpoint( \"/swagger/v1/swagger.json\", $\"{GetType().Assembly.FullName} API\"); }); // Enable routing and endpoints for controllers app.UseRouting(); app.UseEndpoints(endpoints => { endpoints.MapControllers(); }); } } } using MQTTnet.Protocol; using Silverback.Messaging.Configuration; using Silverback.Messaging.Messages; namespace Silverback.Samples.Mqtt.BinaryFileStreaming.Producer { public class EndpointsConfigurator : IEndpointsConfigurator { public void Configure(IEndpointsConfigurationBuilder builder) { builder .AddMqttEndpoints( endpoints => endpoints // Configure the client options .Configure( config => config .WithClientId(\"samples.binary-file.producer\") .ConnectViaTcp(\"localhost\")) // Produce the binary files to the // samples-binary-file-streaming topic .AddOutbound<BinaryFileMessage>( endpoint => endpoint .ProduceTo(\"samples/binary-files\") .WithQualityOfServiceLevel( MqttQualityOfServiceLevel.AtLeastOnce))); } } } using Silverback.Messaging.Messages; namespace Silverback.Samples.Mqtt.BinaryFileStreaming.Producer.Messages { public class CustomBinaryFileMessage : BinaryFileMessage { [Header(\"x-filename\")] public string? Filename { get; set; } } } using System.IO; using System.Threading.Tasks; using Microsoft.AspNetCore.Mvc; using Silverback.Messaging.Messages; using Silverback.Messaging.Publishing; using Silverback.Samples.Mqtt.BinaryFileStreaming.Producer.Messages; namespace Silverback.Samples.Mqtt.BinaryFileStreaming.Producer.Controllers { [ApiController] [Route(\"[controller]\")] public class ProducerController : ControllerBase { private readonly IPublisher _publisher; public ProducerController(IPublisher publisher) { _publisher = publisher; } [HttpPost(\"binary-file\")] public async Task<IActionResult> ProduceBinaryFileAsync( string filePath, string? contentType) { // Open specified file stream using var fileStream = System.IO.File.OpenRead(filePath); // Create a BinaryFileMessage that wraps the file stream var binaryFileMessage = new BinaryFileMessage(fileStream); if (!string.IsNullOrEmpty(contentType)) binaryFileMessage.ContentType = contentType; // Publish the BinaryFileMessage that will be routed to the outbound // endpoint. The FileStream will be read and produced chunk by chunk, // without the entire file being loaded into memory. await _publisher.PublishAsync(binaryFileMessage); return NoContent(); } [HttpPost(\"custom-binary-file\")] public async Task<IActionResult> ProduceBinaryFileWithCustomHeadersAsync( string filePath, string? contentType) { // Open specified file stream using var fileStream = System.IO.File.OpenRead(filePath); // Create a CustomBinaryFileMessage that wraps the file stream. The // CustomBinaryFileMessage extends the BinaryFileMessage adding an extra // Filename property that is also exported as header. var binaryFileMessage = new CustomBinaryFileMessage { Content = fileStream, Filename = Path.GetFileName(filePath) }; if (!string.IsNullOrEmpty(contentType)) binaryFileMessage.ContentType = contentType; // Publish the BinaryFileMessage that will be routed to the outbound // endpoint. The FileStream will be read and produced chunk by chunk, // without the entire file being loaded into memory. await _publisher.PublishAsync(binaryFileMessage); return NoContent(); } } } Full source code: https://github.com/BEagle1984/silverback/tree/master/samples/Mqtt/BinaryFileStreaming.Producer Consumer The consumer simply streams the file to a temporary folder in the local file system. Startup EndpointsConfigurator CustomBinaryFileMessage Subscriber using Microsoft.Extensions.DependencyInjection; using Silverback.Samples.Mqtt.BinaryFileStreaming.Consumer.Subscribers; namespace Silverback.Samples.Mqtt.BinaryFileStreaming.Consumer { public class Startup { public void ConfigureServices(IServiceCollection services) { // Enable Silverback services .AddSilverback() // Use Apache Mqtt as message broker .WithConnectionToMessageBroker( options => options .AddMqtt()) // Delegate the inbound/outbound endpoints configuration to a separate // class. .AddEndpointsConfigurator<EndpointsConfigurator>() // Register the subscribers .AddSingletonSubscriber<BinaryFileSubscriber>(); } public void Configure() { } } } using MQTTnet.Protocol; using Silverback.Messaging.Configuration; using Silverback.Samples.Mqtt.BinaryFileStreaming.Consumer.Messages; namespace Silverback.Samples.Mqtt.BinaryFileStreaming.Consumer { public class EndpointsConfigurator : IEndpointsConfigurator { public void Configure(IEndpointsConfigurationBuilder builder) { builder .AddMqttEndpoints( endpoints => endpoints // Configure the client options .Configure( config => config .WithClientId(\"samples.binary-file.consumer\") .ConnectViaTcp(\"localhost\")) // Consume the samples-binary-file-streaming topic .AddInbound( endpoint => endpoint .ConsumeFrom(\"samples/binary-files\") .WithQualityOfServiceLevel( MqttQualityOfServiceLevel.AtLeastOnce) // Force the consumer to use the // BinaryFileMessageSerializer: this is not strictly // necessary when the messages are produced by // Silverback but it increases the interoperability, // since it doesn't have to rely on the // 'x-message-type' header value to switch to the // BinaryFileMessageSerializer. // // In this example the BinaryFileMessageSerializer is // also set to return a CustomBinaryFileMessage // instead of the normal BinaryFileMessage. This is // only needed because we want to read the custom // 'x-message-filename' header, otherwise // 'ConsumeBinaryFiles()' would work perfectly fine // (returning a basic BinaryFileMessage, without the // extra properties). .ConsumeBinaryFiles( serializer => serializer .UseModel<CustomBinaryFileMessage>()) // Retry each chunks sequence 5 times in case of an // exception .OnError(policy => policy.Retry(5)))); } } } using Silverback.Messaging.Messages; namespace Silverback.Samples.Mqtt.BinaryFileStreaming.Consumer.Messages { public class CustomBinaryFileMessage : BinaryFileMessage { [Header(\"x-filename\")] public string? Filename { get; set; } } } using System; using System.IO; using System.Threading.Tasks; using Microsoft.Extensions.Logging; using Silverback.Samples.Mqtt.BinaryFileStreaming.Consumer.Messages; namespace Silverback.Samples.Mqtt.BinaryFileStreaming.Consumer.Subscribers { public class BinaryFileSubscriber { private const string OutputPath = \"../../temp\"; private readonly ILogger<BinaryFileSubscriber> _logger; public BinaryFileSubscriber(ILogger<BinaryFileSubscriber> logger) { _logger = logger; } public async Task OnBinaryFileMessageReceivedAsync( CustomBinaryFileMessage binaryFileMessage) { EnsureTargetFolderExists(); var filename = Guid.NewGuid().ToString(\"N\") + binaryFileMessage.Filename; _logger.LogInformation(\"Saving binary file as {Filename}...\", filename); // Create a FileStream to save the file using var fileStream = File.OpenWrite(Path.Combine(OutputPath, filename)); if (binaryFileMessage.Content != null) { // Asynchronously copy the message content to the FileStream. // The message chunks are streamed directly and the entire file is // never loaded into memory. await binaryFileMessage.Content.CopyToAsync(fileStream); } _logger.LogInformation( \"Written {FileStreamLength} bytes into {Filename}\", fileStream.Length, filename); } private static void EnsureTargetFolderExists() { if (!Directory.Exists(OutputPath)) Directory.CreateDirectory(OutputPath); } } } Full source code: https://github.com/BEagle1984/silverback/tree/master/samples/Mqtt/BinaryFileStreaming.Consumer"
  },
  "samples/samples.html": {
    "href": "samples/samples.html",
    "title": "Samples | Silverback",
    "keywords": "Samples In this section you find a collection of working samples based on Silverback and implementing a wide range of different use cases. The full source code can be found in the GitHub repository under the /samples folder. A README.md in the root of the samples folder explains how to run each of the samples."
  }
}