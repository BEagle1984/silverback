<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Event Sourcing | Silverback </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Event Sourcing | Silverback ">
    <meta name="generator" content="docfx 2.56.6.0">
    
  
    <link rel="apple-touch-icon" sizes="180x180" href="../images/icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="../images/icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="../images/icons/favicon-16x16.png">
    <link rel="manifest" href="../images/icons/site.webmanifest">
    <link rel="mask-icon" href="../images/icons/safari-pinned-tab.svg" color="#5bbad5">
  
    <link rel="stylesheet" href="../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../styles/docfx.css">
    <link rel="stylesheet" href="../styles/main.css">
    <meta property="docfx:navrel" content="../toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    
    <meta property="docfx:rel" content="../">
    
    <script src="https://kit.fontawesome.com/e3306be642.js" crossorigin="anonymous"></script>
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../index.html">
                <img id="logo" class="svg" src="../images/logo.png" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div class="container body-content">
        
        <div id="search-results">
          <div class="search-list"></div>
          <div class="sr-items">
            <p><i class="glyphicon glyphicon-refresh index-loading"></i></p>
          </div>
          <ul id="pagination"></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="event-sourcing">
<h1 id="event-sourcing">Event Sourcing</h1>

<p><code>Silverback.EventSourcing</code> is a basic implementation of an event store that perfectly integrates within the Silverback ecosystem. At the moment only a version using Entity Framework Core is implemented, allowing to store the events in a database but other implementations may be added in the future.</p>
<h2 id="configuration">Configuration</h2>
<p>The only needed configuration is the call to <code>UseDbContext&lt;TDbContext&gt;</code> when initializing Silverback.</p>
<pre><code class="lang-csharp">public class Startup
{
    public void ConfigureServices(IServiceCollection services)
    {
        services.AddSilverback().UseDbContext&lt;MyDbContext&gt;()
    }
}
</code></pre>
<h2 id="creating-the-event-store">Creating the Event Store</h2>
<p>Creating an event store is very straightforward and requires basically just 3 components: a domain entity model, the event store model and a repository.</p>
<h3 id="domain-entity-model">Domain Entity model</h3>
<p>The domain entity have to extend <code>EventSourcingDomainEntity</code> (or a custom class implementing <code>IEventSourcingDomainEntity</code>).
The two generic type parameters refer to the type of the key (entity unique identifier) and the base type for the domain events (can be omited if you don't need domain events).</p>
<pre><code class="lang-csharp">public class Person : EventSourcingDomainEntity&lt;int, PersonDomainEvent&gt;
{
    public Person()
    {
    }

    public Person(IReadOnlyCollection&lt;IEntityEvent&gt; events) : base(events)
    {
    }

    public string Name { get; private set; }
    public string SocialSecurityNumber { get; private set; }
    public int Age { get; private set; }
    public string PhoneNumber { get; private set; }
}
</code></pre>
<div class="IMPORTANT">
<h5>Important</h5>
<p>The domain entity must have a constructor able to rebuild the entity state from the stored events.</p>
</div>
<p>The <code>AddAndApplyEvent</code> protected method must be used to add new events.</p>
<pre><code class="lang-csharp">public class Person : EventSourcingDomainEntity&lt;int, PersonDomainEvent&gt;
{
    public void ChangeName(string newName) =&gt;
        AddAndApplyEvent(new NameChangedEvent
        {
            NewName = newName
        });

    public void ChangeAge(int newAge) =&gt;
        AddAndApplyEvent(new AgeChangedEvent
        {
            NewAge = newAge
        });

    public void ChangePhoneNumber(string newPhoneNumber) =&gt;
        AddAndApplyEvent(new PhoneNumberChangedEvent
        {
            NewPhoneNumber = newPhoneNumber
        });
}
</code></pre>
<p>An <em>Apply</em> method is needed for each event type to modify the entity current state according to the described mutation.</p>
<pre><code class="lang-csharp">public class Person : EventSourcingDomainEntity&lt;int, PersonDomainEvent&gt;
{
    private void Apply(NameChangedEvent @event) =&gt; Name = @event.NewName;
 
    private void Apply(AgeChangedEvent @event) =&gt; Age = @event.NewAge;

    private void Apply(PhoneNumberChangedEvent @event, bool isReplaying)
    {
        PhoneNumber = @event.NewPhoneNumber;

        // Fire domain event only if the event is new
        if (!isReplaying)
            AddEvent&lt;PhoneNumberChangedDomainEvent&gt;();
    }
}
</code></pre>
<div class="NOTE">
<h5>Note</h5>
<p>The apply method can be private but it must have a specific signature: its name must begin with <em>&quot;Apply&quot;</em> and have a parameter of the specific event type (or base type).
It can also receive an additional boolean parameter (<code>isReplaying</code>) that will let you differentiate between new events and events that are being reapplied because loaded from the store.</p>
</div>
<p>The events are just models inheriting from <code>EntityEvent</code> (or another custom class implementing <code>IEntityEvent</code>).</p>
<pre><code class="lang-csharp">public class NameChangedEvent : EntityEvent 
{ 
    public string NewName { get; set; } 
}

public class AgeChangedEvent : EntityEvent 
{ 
    public int NewAge { get; set; } 
}

public class PhoneNumberChangedEvent : EntityEvent 
{ 
    public string NewPhoneNumber { get; set; } 
}
</code></pre>
<h3 id="event-store-model">Event Store model</h3>
<p>The event store basically consists of an <em>EventStore</em> entity and related event (they either inherit from <code>EventStoreEntity</code> and <code>EventEntity</code> or implement the interfaces <code>IEventStoreEntity</code> and <code>IEventEntity</code> respectively).</p>
<pre><code class="lang-csharp">public class PersonEventStore : EventStoreEntity&lt;PersonEvent&gt;
{
    [Key]
    public int Id { get; set; }

    public string SocialSecurityNumber { get; set; }
}

public class PersonEvent : EventEntity
{
    [Key]
    public int Id { get; private set; }
}
</code></pre>
<div class="NOTE">
<h5>Note</h5>
<p>The event store record can be extended with extra fields (see <code>SocialSecurityNumber</code> in the example above) and those will be automatically set with the value of the matching propertyi in the domain entity (unless the mapping method is overridden in the repository implementing a custom logic).</p>
</div>
<div class="IMPORTANT">
<h5>Important</h5>
<p>It is advised to add some indexes and a concurrency token, to ensure proper performance and consistency.</p>
</div>
<p>A DbSet must also be mapped to the defined event store entity and that's it.</p>
<pre><code class="lang-csharp">public class MyDbContext : DbContext
{
    public MyDbContext(DbContextOptions options) : base(options)
    {
    }

    public DbSet&lt;PersonEventStore&gt; Persons { get; set; }
}
</code></pre>
<h3 id="eventstore-repository">EventStore repository</h3>
<p>The repository is the component that is storing the domain entity in form of single events, being able to rebuild it afterwards.</p>
<p>The repository must inherit from <code>DbContextEventStoreRepository</code> and the 4 generic type parameters refer respectively to:</p>
<ul>
<li>the domain entity</li>
<li>its unique key</li>
<li>the event store entity</li>
<li>its related event entity</li>
</ul>
<pre><code class="lang-csharp">public class PersonEventStoreRepository
    : DbContextEventStoreRepository&lt;Person, int, PersonEventStore, PersonEvent&gt;
{
    public PersonEventStoreRepository(DbContext dbContext)
        : base(dbContext)
    {
    }
}
</code></pre>
<h2 id="storing-and-retrieving-entities">Storing and retrieving entities</h2>
<p>Using the <code>EventStoreRepository</code> to store and retrieve domain entities is fairly simple. Have a look at the following code snippet to get an idea.</p>
<pre><code class="lang-csharp">public class PersonService
{
    private readonly MyDbContext _dbContext;
    private readonly PersonEventStoreRepository _repository =
        new PersonEventStoreRepository(_dbContext);

    public async Task&lt;Person&gt; CreatePerson(string name, int age)
    {
        var person = new Person();
        person.ChangeName(&quot;Sergio&quot;);
        person.ChangeAge(35);

        person = await _repository.StoreAsync(person);
        await _dbContext.SaveChangesAsync();

        return person;
    }

    public async Task&lt;Person&gt; ChangePhoneNumber(
        int personId,
        string newPhoneNumber)
    {
        var person = _repository.Get(p =&gt; p.Id == personId);

        person.ChangePhoneNumber(newPhoneNumber);

        person = await _repository.StoreAsync(person);
        await _dbContext.SaveChangesAsync();

        return person;
    }
}
</code></pre>
<h2 id="merging-events--handling-conflicts">Merging events / handling conflicts</h2>
<p>You may need to merge events coming from different sources and/or being received with a certain latency. In the example below the <em>Apply</em> method checks whether another (newer) conflicting event was added already in the meantime.</p>
<pre><code class="lang-csharp">private void Apply(NameChangedEvent @event, bool isReplaying)
{
    // Skip if a newer event exists
    if (!isReplaying &amp;&amp; Events.Any(e =&gt; 
        e is NameChangedEvent &amp;&amp;
        e.Timestamp &gt; @event.Timestamp))
    {
        return;
    }

    Name = @event.NewName;
}
</code></pre>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/beagle1984/silverback/blob/master/docs/concepts/event-sourcing.md/#L1" class="contribution-link">Improve this doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="footer">
          <div class="container contacts">
            <a href="https://github.com/BEagle1984" rel="nofollow noopener noreferrer"><i class='fab fa-github'></i> GitHub</a>
            <a href="mailto:silverback-project@outlook.com" rel="nofollow noopener noreferrer"><i class='fas fa-envelope'></i> E-Mail</a>
          </div>
          <div class="container">
            <span class="pull-right">
              <a href="#top">&uarr; Back to top</a>
            </span>
            © 2020 Sergio Aquilini
            
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../styles/docfx.js"></script>
    <script type="text/javascript" src="../styles/main.js"></script>
  </body>
</html>
