<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Chunking | Silverback </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Chunking | Silverback ">
    <meta name="generator" content="docfx 2.56.5.0">
    
  
    <link rel="apple-touch-icon" sizes="180x180" href="../../images/icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="../../images/icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="../../images/icons/favicon-16x16.png">
    <link rel="manifest" href="../../images/icons/site.webmanifest">
    <link rel="mask-icon" href="../../images/icons/safari-pinned-tab.svg" color="#5bbad5">
  
    <link rel="stylesheet" href="../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../styles/docfx.css">
    <link rel="stylesheet" href="../../styles/main.css">
    <meta property="docfx:navrel" content="../../toc.html">
    <meta property="docfx:tocrel" content="../toc.html">
    
    <meta property="docfx:rel" content="../../">
    
    <script src="https://kit.fontawesome.com/e3306be642.js" crossorigin="anonymous"></script>
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../../index.html">
                <img id="logo" class="svg" src="../../images/logo.png" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div class="container body-content">
        
        <div id="search-results">
          <div class="search-list"></div>
          <div class="sr-items">
            <p><i class="glyphicon glyphicon-refresh index-loading"></i></p>
          </div>
          <ul id="pagination"></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="chunking">
<h1 id="chunking">Chunking</h1>

<p>The message brokers are usually very efficient at handling huge amount of relatively small messages. In order to make the most out of it you may want to split your largest messages (e.g. containing binary data) into smaller chunks. Silverback can handle such scenario transparently, reassembling the message automatically in the inbound connector before pushing it to the internal bus.</p>
<h2 id="producer-configuration">Producer configuration</h2>
<p>The producer endpoint can be configured to split the message into chunks by specifying their maximum size (in bytes).</p>
<figure>
	<a href="../../images/diagrams/chunk-basic.png"><img src="../../images/diagrams/chunk-basic.png"></a>
    <figcaption>The messages are being split into small chunks.</figcaption>
</figure>
<pre><code class="lang-csharp">new KafkaProducerEndpoint(&quot;silverback-examples-events&quot;)
{
    Configuration = new KafkaProducerConfig
    {
        ...
    },
    Chunk = new ChunkSettings
    {
        Size = 100000
    }
}
</code></pre>
<h2 id="consumer-configuration">Consumer configuration</h2>
<p>An <code>IChunkStore</code> implementation is needed to temporary store the chunks until the full message has been received. Silverback has two built-in implementations: the <code>InMemoryChunkStore</code> and the <code>DbChunkStore</code>.</p>
<figure>
	<a href="../../images/diagrams/chunk-basic.png"><img src="../../images/diagrams/chunk-basic.png"></a>
    <figcaption>The message chunks are automatically aggregated once the full message is received.</figcaption>
</figure>
<h3 id="in-memory-temporary-store">In-Memory temporary store</h3>
<p>The <code>InMemoryChunkStore</code> should be your default choice as it doesn't require any extra storage. As the name suggests, the chunks are simply kept in memory until the full message can be rebuilt and consumed.</p>
<p>This approach has of course some limitations and requires that all chunks are received by the same consumer: with Kafka this is usually ensured by setting the same key to all chunks, thing that is done automatically by Silverback setting the same key and the same headers to all chunks (except for the chunk index header, of course).</p>
<figure>
	<a href="../../images/diagrams/chunk-nokey.png"><img src="../../images/diagrams/chunk-nokey.png"></a>
    <figcaption>Kafka: without a key the messages are written to a random partition.</figcaption>
</figure>
<figure>
	<a href="../../images/diagrams/chunk-key.png"><img src="../../images/diagrams/chunk-key.png"></a>
    <figcaption>Kafka: with the key being set the chunks related to the same message will land in the same partition.</figcaption>
</figure>
<p>On the other hand it isn't a big deal if multiple producers are writing in the same topic/queue and the chunks of different message are interleaved. Silverback will commit the offsets only when no chunk is left in memory, to prevent any message loss.</p>
<figure>
	<a href="../../images/diagrams/chunk-interleaved.png"><img src="../../images/diagrams/chunk-interleaved.png"></a>
    <figcaption>Silverback handles the inteleaved chunks transparently.</figcaption>
</figure>
<div class="IMPORTANT">
<h5>Important</h5>
<p>It isn't guaranteed that you will never consume a message twice, if you use multiple producers to write into the topic or queue. It is up to you to ensure idempotency or enable exactly-once processing through the inbound connector (see <a class="xref" href="../02-configuration/03-inbound.html">Inbound Connector</a>).</p>
</div>
<pre><code class="lang-csharp">public class Startup
{
    public void ConfigureServices(IServiceCollection services)
    {
        services
            .AddSilverback()
            .UseDbContext&lt;MyDbContext&gt;()
            .WithConnectionToMessageBroker(options =&gt; options
                .AddKafka()
                .AddInMemoryChunkStore());
    }
}
</code></pre>
<div class="TIP">
<h5>Tip</h5>
<p>The <code>AddInMemoryChunkStore</code> method has some optional parameters to configure the maximum chunks retention (in case of a producer failure, you may receive only part of the chunks of a given message and without this setting they would stay in memory forever).</p>
</div>
<h3 id="database-temporary-store">Database temporary store</h3>
<p>The <code>DbChunkStore</code> will temporary store the chunks into a database table and the inbound connector will rebuild the original message as soon as all chunks have been received. This table can be shared between multiple consumers, making it safer when chunks aren't properly written to the same partition.</p>
<figure>
	<a href="../../images/diagrams/chunk-persisted.png"><img src="../../images/diagrams/chunk-persisted.png"></a>
    <figcaption>The chunks are persisted to a database table that is shared across the consumers.</figcaption>
</figure>
<div class="NOTE">
<h5>Note</h5>
<p>The <code>Silverback.EntityFrameworkCore</code> package is also required and the <code>DbContext</code> must include a <code>DbSet&lt;TemporaryMessageChunk&gt;</code>. See also the <a class="xref" href="../06-extras/01-dbcontext.html">Sample DbContext (EF Core)</a>.</p>
</div>
<pre><code class="lang-csharp">public class Startup
{
    public void ConfigureServices(IServiceCollection services)
    {
        services
            .AddSilverback()
            .UseDbContext&lt;MyDbContext&gt;()
            .WithConnectionToMessageBroker(options =&gt; options
                .AddKafka()
                .AddDbChunkStore());
    }
}
</code></pre>
<div class="TIP">
<h5>Tip</h5>
<p>The <code>AddDbChunkStore</code> method has some optional parameters to configure the maximum chunks retention (in case of a producer failure, you may receive only part of the chunks of a given message and without this setting they would stay in the database forever).</p>
</div>
<h3 id="custom-chunk-store">Custom chunk store</h3>
<p>It is of course possible to create other implementations of <code>IChunkStore</code> to use another kind of storage for the message chunks.</p>
<pre><code class="lang-csharp">public class Startup
{
    public void ConfigureServices(IServiceCollection services)
    {
        services
            .AddSilverback()
            .UseDbContext&lt;MyDbContext&gt;()
            .WithConnectionToMessageBroker(options =&gt; options
                .AddKafka()
                .AddChunkStore&lt;SomeCustomChunkStore&gt;());
    }
}
</code></pre>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/beagle1984/silverback/blob/master/docs/concepts/03-advanced/02-chunking.md/#L1" class="contribution-link">Improve this doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="footer">
          <div class="container contacts">
            <a href="https://github.com/BEagle1984" rel="nofollow noopener noreferrer"><i class='fab fa-github'></i> GitHub</a>
            <a href="mailto:silverback-project@outlook.com" rel="nofollow noopener noreferrer"><i class='fas fa-envelope'></i> E-Mail</a>
          </div>
          <div class="container">
            <span class="pull-right">
              <a href="#top">&uarr; Back to top</a>
            </span>
            © 2020 Sergio Aquilini
            
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../styles/main.js"></script>
  </body>
</html>
