// Copyright (c) 2024 Sergio Aquilini
// This code is licensed under MIT license (see LICENSE file for details)

using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Reflection;
using System.Text;
using Silverback.Tools.Generators.Common;

namespace Silverback.Tools.Generators.KafkaConfigProxies;

public class BuilderGenerator
{
    public BuilderGenerator(Type proxiedType)
    {
        ProxiedType = proxiedType;
        GeneratedClassName = $"Kafka{proxiedType.Name}urationBuilder";
        BuiltTypeName = $"Kafka{proxiedType.Name}uration";
    }

    protected Type ProxiedType { get; }

    protected string GeneratedClassName { get; }

    protected string BuiltTypeName { get; }

    protected StringBuilder StringBuilder { get; } = new();

    public virtual string Generate()
    {
        GenerateClassHeading();
        MapClassProperties();
        GenerateBasicFooter();

        return StringBuilder.ToString();
    }

    protected virtual string GetClassSummary() => $"The autogenerated part of the <see cref=\"{GeneratedClassName}\" /> class.";

    protected virtual string GetClassSignature() => $"public partial class {GeneratedClassName}";

    [SuppressMessage("Globalization", "CA1308:Normalize strings to uppercase", Justification = "False positive, it makes no sense")]
    protected virtual void MapClassProperties()
    {
        IEnumerable<PropertyInfo> properties =
            ReflectionHelper.GetProperties(ProxiedType, false)
                .Where(property => !IgnoredProperties.Contains(property));

        StringBuilder fieldsStringBuilder = new();
        StringBuilder propertiesStringBuilder = new();
        StringBuilder buildMethodStringBuilder = new();

        foreach (PropertyInfo property in properties)
        {
            string propertyType = ReflectionHelper.GetTypeString(property.PropertyType);
            string argument = property.Name.ToCamelCase();
            string field = $"_{argument}";
            string visibility = MustBeInternal(property.Name) ? "internal" : "public partial";

            fieldsStringBuilder.AppendLine($"    private {propertyType} {field};");
            fieldsStringBuilder.AppendLine();

            propertiesStringBuilder.AppendLine($"    {visibility} {GeneratedClassName} With{property.Name}({propertyType} {argument})");
            propertiesStringBuilder.AppendLine("    {");
            propertiesStringBuilder.AppendLine($"        {field} = {argument};");
            propertiesStringBuilder.AppendLine("        return this;");
            propertiesStringBuilder.AppendLine("    }");
            propertiesStringBuilder.AppendLine();

            buildMethodStringBuilder.AppendLine($"            {property.Name} = {field},");
        }

        StringBuilder.Append(fieldsStringBuilder);
        StringBuilder.Append(propertiesStringBuilder);
        StringBuilder.AppendLine("    /// <summary>");
        StringBuilder.AppendLine("    ///     Builds the configuration.");
        StringBuilder.AppendLine("    /// </summary>");
        StringBuilder.AppendLine("    /// <returns>");
        StringBuilder.AppendLine("    ///     The configuration.");
        StringBuilder.AppendLine("    /// </returns>");
        StringBuilder.AppendLine($"    protected override {BuiltTypeName} BuildCore() =>");
        StringBuilder.AppendLine("        base.BuildCore() with");
        StringBuilder.AppendLine("        {");
        StringBuilder.Append(buildMethodStringBuilder);
        StringBuilder.AppendLine("        };");
    }

    protected void GenerateBasicFooter() => StringBuilder.AppendLine("}");

    private static bool MustBeInternal(string propertyName) =>
        propertyName
            is "EnablePartitionEof"
            or "EnableDeliveryReports"
            or "EnableIdempotence"
            or "EnableGaplessGuarantee"
            or "CheckCrcs"
            or "TransactionalId";

    private void GenerateClassHeading()
    {
        StringBuilder.AppendLine("/// <content>");
        StringBuilder.AppendLine($"///     {GetClassSummary()}");
        StringBuilder.AppendLine("/// </content>");
        StringBuilder.AppendLine("[SuppressMessage(\"StyleCop.CSharp.MaintainabilityRules\", \"SA1402:File may only contain a single type\", Justification = \"Autogenerated all at once\")]");
        StringBuilder.AppendLine("[SuppressMessage(\"StyleCop.CSharp.OrderingRules\", \"SA1202: 'public' members should come before 'internal' members\", Justification = \"Autogenerated\")]");
        StringBuilder.AppendLine("[SuppressMessage(\"StyleCop.CSharp.DocumentationRules\", \"SA1600:Elements should be documented\", Justification = \"Documented in other partial\")]");
        StringBuilder.AppendLine("[SuppressMessage(\"StyleCop.CSharp.DocumentationRules\", \"SA1601:Partial elements should be documented\", Justification = \"Autogenerated\")]");
        StringBuilder.AppendLine(GetClassSignature());
        StringBuilder.AppendLine("{");
    }
}
