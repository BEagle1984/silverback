// Copyright (c) 2024 Sergio Aquilini
// This code is licensed under MIT license (see LICENSE file for details)

using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Reflection;
using System.Text;
using Confluent.Kafka;
using Silverback.Tools.Generators.Common;

namespace Silverback.Tools.Generators.KafkaConfigProxies;

internal sealed class BuilderGenerator
{
    private readonly Type _proxiedType;

    private readonly string _generatedClassName;

    private readonly bool _isChildType;

    private readonly StringBuilder _stringBuilder = new();

    public BuilderGenerator(Type proxiedType)
    {
        _proxiedType = proxiedType;
        _isChildType = _proxiedType != typeof(ClientConfig);
        _generatedClassName = _isChildType ? $"Kafka{_proxiedType.Name}urationBuilder" : "KafkaClientConfigurationBuilder";
    }

    public string Generate()
    {
        if (!_isChildType)
        {
            GenerateInterfaceHeading();
            MapInterfaceProperties();
            GenerateBasicFooter();

            _stringBuilder.AppendLine();

            GenerateClientsBuilderClassHeading();
            MapClientsBuilderClassProperties();
            GenerateBasicFooter();

            _stringBuilder.AppendLine();
        }

        GenerateClassHeading();
        MapClassProperties();
        GenerateBasicFooter();

        return _stringBuilder.ToString();
    }

    private static bool MustBeInternal(string propertyName) =>
        propertyName
            is "EnableAutoCommit"
            or "EnablePartitionEof"
            or "AllowAutoCreateTopics"
            or "EnableDeliveryReports"
            or "EnableIdempotence"
            or "TopicMetadataRefreshSparse"
            or "SocketKeepaliveEnable"
            or "SocketNagleDisable"
            or "ApiVersionRequest"
            or "EnableSslCertificateVerification"
            or "EnableSaslOauthbearerUnsecureJwt"
            or "CheckCrcs"
            or "EnableGaplessGuarantee"
            or "TransactionalId";

    private void GenerateClassHeading()
    {
        _stringBuilder.AppendLine("/// <content>");
        _stringBuilder.AppendLine(
            _isChildType
                ? $"///     The autogenerated part of the <see cref=\"{_generatedClassName}\" /> class."
                : $"///     The autogenerated part of the <see cref=\"{_generatedClassName}{{TClientConfig,TBuilder}}\" /> class.");
        _stringBuilder.AppendLine("/// </content>");
        _stringBuilder.AppendLine("[SuppressMessage(\"StyleCop.CSharp.MaintainabilityRules\", \"SA1402:File may only contain a single type\", Justification = \"Autogenerated all at once\")]");
        _stringBuilder.AppendLine("[SuppressMessage(\"StyleCop.CSharp.OrderingRules\", \"SA1202: 'public' members should come before 'internal' members\", Justification = \"Autogenerated\")]");
        _stringBuilder.AppendLine("[SuppressMessage(\"StyleCop.CSharp.DocumentationRules\", \"SA1600:Elements should be documented\", Justification = \"Documented in other partial\")]");
        _stringBuilder.AppendLine("[SuppressMessage(\"StyleCop.CSharp.DocumentationRules\", \"SA1601:Partial elements should be documented\", Justification = \"Autogenerated\")]");
        _stringBuilder.AppendLine(
            _isChildType
                ? $"public partial class {_generatedClassName}"
                : $"public partial class {_generatedClassName}<TClientConfig, TBuilder> : IKafkaClientConfigurationBuilder");
        _stringBuilder.AppendLine("{");
    }

    private void GenerateInterfaceHeading()
    {
        _stringBuilder.AppendLine("/// <summary>");
        _stringBuilder.AppendLine("///     Builds the <see cref=\"KafkaProducerConfiguration\" /> or <see cref=\"KafkaConsumerConfiguration\" />.");
        _stringBuilder.AppendLine("/// </summary>");
        _stringBuilder.AppendLine("[SuppressMessage(\"StyleCop.CSharp.MaintainabilityRules\", \"SA1402:File may only contain a single type\", Justification = \"Autogenerated all at once\")]");
        _stringBuilder.AppendLine("[SuppressMessage(\"StyleCop.CSharp.DocumentationRules\", \"SA1600:Elements should be documented\", Justification = \"Internal interface\")]");
        _stringBuilder.AppendLine("[SuppressMessage(\"StyleCop.CSharp.OrderingRules\", \"SA1201:Elements should appear in the correct order\", Justification = \"Autogenerated\")]");
        _stringBuilder.AppendLine($"internal interface I{_generatedClassName}");
        _stringBuilder.AppendLine("{");
    }

    private void GenerateClientsBuilderClassHeading()
    {
        _stringBuilder.AppendLine("/// <content>");
        _stringBuilder.AppendLine("///     The autogenerated part of the <see cref=\"KafkaClientsConfigurationBuilder\" /> class.");
        _stringBuilder.AppendLine("/// </content>");
        _stringBuilder.AppendLine("[SuppressMessage(\"StyleCop.CSharp.MaintainabilityRules\", \"SA1402:File may only contain a single type\", Justification = \"Autogenerated all at once\")]");
        _stringBuilder.AppendLine("[SuppressMessage(\"StyleCop.CSharp.DocumentationRules\", \"SA1600:Elements should be documented\", Justification = \"Documented in other partial\")]");
        _stringBuilder.AppendLine("[SuppressMessage(\"StyleCop.CSharp.DocumentationRules\", \"SA1601:Partial elements should be documented\", Justification = \"Autogenerated\")]");
        _stringBuilder.AppendLine("public partial class KafkaClientsConfigurationBuilder");
        _stringBuilder.AppendLine("{");
    }

    [SuppressMessage("Globalization", "CA1308:Normalize strings to uppercase", Justification = "False positive, it makes no sense")]
    private void MapClassProperties()
    {
        IEnumerable<PropertyInfo> properties =
            ReflectionHelper.GetProperties(_proxiedType, !_isChildType)
                .Where(
                    property => !IgnoredProperties.Contains(property) &&
                                property.Name != "GroupId");

        foreach (PropertyInfo property in properties)
        {
            string propertyType = ReflectionHelper.GetTypeString(property.PropertyType, true);
            string valueVariableName = property.Name.ToCamelCase();
            string visibility = MustBeInternal(property.Name) ? "internal" : "public partial";

            if (!_isChildType)
            {
                _stringBuilder.Append($"    void IKafkaClientConfigurationBuilder.With{property.Name}({propertyType} {valueVariableName})");
                _stringBuilder.AppendLine($" => With{property.Name}({valueVariableName});");
            }

            _stringBuilder.AppendLine(
                _isChildType
                    ? $"    {visibility} {_generatedClassName} With{property.Name}({propertyType} {valueVariableName})"
                    : $"    {visibility} TBuilder With{property.Name}({propertyType} {valueVariableName})");
            _stringBuilder.AppendLine("    {");
            _stringBuilder.AppendLine($"        ClientConfig.{property.Name} = {valueVariableName};");
            _stringBuilder.AppendLine("        return This;");
            _stringBuilder.AppendLine("    }");
            _stringBuilder.AppendLine();
        }
    }

    private void MapInterfaceProperties()
    {
        IEnumerable<PropertyInfo> properties =
            ReflectionHelper.GetProperties(_proxiedType, !_isChildType)
                .Where(property => !IgnoredProperties.Contains(property));

        foreach (PropertyInfo property in properties)
        {
            string propertyType = ReflectionHelper.GetTypeString(property.PropertyType, true);
            string valueVariableName = property.Name.ToCamelCase();

            _stringBuilder.AppendLine($"    void With{property.Name}({propertyType} {valueVariableName});");
            _stringBuilder.AppendLine();
        }
    }

    private void MapClientsBuilderClassProperties()
    {
        IEnumerable<PropertyInfo> properties =
            ReflectionHelper.GetProperties(_proxiedType, !_isChildType)
                .Where(
                    property => !IgnoredProperties.Contains(property) &&
                                property.Name != "ClientId");

        foreach (PropertyInfo property in properties)
        {
            string propertyType = ReflectionHelper.GetTypeString(property.PropertyType, true);
            string valueVariableName = property.Name.ToCamelCase();
            string visibility = MustBeInternal(property.Name) ? "internal" : "public partial";

            _stringBuilder.AppendLine($"    {visibility} KafkaClientsConfigurationBuilder With{property.Name}({propertyType} {valueVariableName})");
            _stringBuilder.AppendLine("    {");
            _stringBuilder.AppendLine($"        _sharedConfigurationActions.Add(builder => builder.With{property.Name}({valueVariableName}));");
            _stringBuilder.AppendLine("        return this;");
            _stringBuilder.AppendLine("    }");
            _stringBuilder.AppendLine();
        }
    }

    private void GenerateBasicFooter() => _stringBuilder.AppendLine("}");
}
