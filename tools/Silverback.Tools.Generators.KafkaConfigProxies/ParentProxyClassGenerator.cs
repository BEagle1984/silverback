// Copyright (c) 2024 Sergio Aquilini
// This code is licensed under MIT license (see LICENSE file for details)

using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Reflection;
using System.Text;
using Confluent.Kafka;
using Silverback.Tools.Generators.Common;

namespace Silverback.Tools.Generators.KafkaConfigProxies;

public class ParentProxyClassGenerator : ProxyClassGenerator
{
    public ParentProxyClassGenerator(Type proxiedType)
        : base(proxiedType, "KafkaClientConfiguration")
    {
    }

    protected override string GetClassSummary() => $"The autogenerated part of the <see cref=\"{GeneratedClassName}{{TConfluentConfig}}\" /> class.";

    protected override string GetClassSignature() => $"public partial record {GeneratedClassName}<TConfluentConfig>";

    [SuppressMessage("Globalization", "CA1308:Normalize strings to uppercase", Justification = "Makes no sense")]
    protected override void MapProperties()
    {
        IEnumerable<PropertyInfo> properties =
            ReflectionHelper.GetProperties(ProxiedType, true)
                .Where(property => !IgnoredProperties.Contains(property));

        StringBuilder propertiesStringBuilder = new();
        StringBuilder mapMethodStringBuilder = new();
        StringBuilder mapMethodStringBuilder2 = new();

        foreach (PropertyInfo property in properties)
        {
            string propertyType = ReflectionHelper.GetTypeString(property.PropertyType);

            if (property.Name == nameof(Config.CancellationDelayMaxMs))
                propertyType += "?";

            propertiesStringBuilder.AppendSummary(property);

            if (property.Name.EndsWith("Url") && property.PropertyType == typeof(string))
                propertiesStringBuilder.AppendLine("    [SuppressMessage(\"Design\", \"CA1056:URI-like properties should not be strings\", Justification = \"Generated according to wrapped class.\")]");

            propertiesStringBuilder.AppendLine($"    public {propertyType} {property.Name} {{ get; init; }}");
            propertiesStringBuilder.AppendLine();

            if (property.Name == nameof(Config.CancellationDelayMaxMs))
            {
                mapMethodStringBuilder2.AppendLine($"        if ({property.Name}.HasValue)");
                mapMethodStringBuilder2.AppendLine($"            confluentConfig.{property.Name} = {property.Name}.Value;");
            }
            else
            {
                mapMethodStringBuilder.AppendLine($"            {property.Name} = {property.Name},");
            }
        }

        StringBuilder.Append(propertiesStringBuilder);
        StringBuilder.AppendLine("    /// <summary>");
        StringBuilder.AppendLine("    ///     Maps to the Confluent client configuration.");
        StringBuilder.AppendLine("    /// </summary>");
        StringBuilder.AppendLine("    /// <returns>");
        StringBuilder.AppendLine("    ///     The Confluent client configuration.");
        StringBuilder.AppendLine("    /// </returns>");
        StringBuilder.AppendLine("    protected virtual TConfluentConfig MapCore()");
        StringBuilder.AppendLine("    {");
        StringBuilder.AppendLine("        TConfluentConfig confluentConfig = new()");
        StringBuilder.AppendLine("        {");
        StringBuilder.Append(mapMethodStringBuilder);
        StringBuilder.AppendLine("        };");
        StringBuilder.AppendLine();
        StringBuilder.Append(mapMethodStringBuilder2);
        StringBuilder.AppendLine();
        StringBuilder.AppendLine("        return confluentConfig;");
        StringBuilder.AppendLine("    }");
    }
}
