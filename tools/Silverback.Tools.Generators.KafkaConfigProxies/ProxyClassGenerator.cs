// Copyright (c) 2024 Sergio Aquilini
// This code is licensed under MIT license (see LICENSE file for details)

using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Reflection;
using System.Text;
using Silverback.Tools.Generators.Common;

namespace Silverback.Tools.Generators.KafkaConfigProxies;

public class ProxyClassGenerator
{
    public ProxyClassGenerator(Type proxiedType)
        : this(proxiedType, $"Kafka{proxiedType.Name}uration")
    {
    }

    protected ProxyClassGenerator(Type proxiedType, string generatedClassName)
    {
        ProxiedType = proxiedType;
        GeneratedClassName = generatedClassName;
    }

    protected Type ProxiedType { get; }

    protected string GeneratedClassName { get; }

    protected StringBuilder StringBuilder { get; } = new();

    public string Generate()
    {
        GenerateHeading();
        MapProperties();
        GenerateFooter();

        return StringBuilder.ToString();
    }

    protected virtual string GetClassSummary() => $"The autogenerated part of the <see cref=\"{GeneratedClassName}\" /> class.";

    protected virtual string GetClassSignature() => $"public partial record {GeneratedClassName}";

    [SuppressMessage("Globalization", "CA1308:Normalize strings to uppercase", Justification = "Makes no sense")]
    protected virtual void MapProperties()
    {
        IEnumerable<PropertyInfo> properties =
            ReflectionHelper.GetProperties(ProxiedType, false)
                .Where(
                    property => !IgnoredProperties.Contains(property) &&
                                property.Name != "EnableAutoCommit" &&
                                property.Name != "GroupId");

        StringBuilder propertiesStringBuilder = new();
        StringBuilder constructorStringBuilder = new();
        StringBuilder mapMethodStringBuilder = new();

        string proxiedTypeParameterName = $"{ProxiedType.Name[0].ToString().ToLowerInvariant()}{ProxiedType.Name[1..]}";

        foreach (PropertyInfo property in properties)
        {
            string propertyType = ReflectionHelper.GetTypeString(property.PropertyType, true);

            propertiesStringBuilder.AppendSummary(property);

            if (property.Name.EndsWith("Url") && property.PropertyType == typeof(string))
                propertiesStringBuilder.AppendLine("    [SuppressMessage(\"Design\", \"CA1056:URI-like properties should not be strings\", Justification = \"Generated according to wrapped class.\")]");

            propertiesStringBuilder.AppendLine($"    public {propertyType} {property.Name}");
            propertiesStringBuilder.AppendLine("    {");

            if (property.GetGetMethod() != null)
                propertiesStringBuilder.AppendLine($"        get => ClientConfig.{property.Name};");

            if (property.Name == "DeliveryReportFields")
            {
                propertiesStringBuilder.AppendLine("        init");
                propertiesStringBuilder.AppendLine("        {");
                propertiesStringBuilder.AppendLine("            if (value != null)");
                propertiesStringBuilder.AppendLine($"                ClientConfig.{property.Name} = value;");
                propertiesStringBuilder.AppendLine("        }");
            }
            else if (property.GetSetMethod() != null)
            {
                propertiesStringBuilder.AppendLine($"        init => ClientConfig.{property.Name} = value;");
            }

            propertiesStringBuilder.AppendLine("    }");
            propertiesStringBuilder.AppendLine();

            constructorStringBuilder.AppendLine($"        {property.Name} = {proxiedTypeParameterName}.{property.Name};");
            mapMethodStringBuilder.AppendLine($"            {property.Name} = {property.Name},");
        }

        StringBuilder.AppendLine($"    public {GeneratedClassName}()");
        StringBuilder.AppendLine("    {");
        StringBuilder.AppendLine("    }");
        StringBuilder.AppendLine();
        StringBuilder.AppendLine($"    public {GeneratedClassName}({ProxiedType.Name} {proxiedTypeParameterName})");
        StringBuilder.AppendLine($"        : base({proxiedTypeParameterName}");
        StringBuilder.AppendLine("    {");
        StringBuilder.Append(constructorStringBuilder);
        StringBuilder.AppendLine("    }");
        StringBuilder.AppendLine();
        StringBuilder.Append(propertiesStringBuilder);
        StringBuilder.AppendLine($"    protected override {ProxiedType.FullName} MapCore() =>");
        StringBuilder.AppendLine("        base.MapCore() with");
        StringBuilder.AppendLine("        {");
        StringBuilder.Append(mapMethodStringBuilder);
        StringBuilder.AppendLine("        };");
    }

    private void GenerateHeading()
    {
        StringBuilder.AppendLine("/// <content>");
        StringBuilder.AppendLine($"///     {GetClassSummary()}");
        StringBuilder.AppendLine("/// </content>");
        StringBuilder.AppendLine("[SuppressMessage(\"StyleCop.CSharp.MaintainabilityRules\", \"SA1402:File may only contain a single type\", Justification = \"Autogenerated all at once\")]");
        StringBuilder.AppendLine("[SuppressMessage(\"Design\", \"CA1044:Properties should not be write only\", Justification = \"Accessors generated according to wrapped class\")]");
        StringBuilder.AppendLine(GetClassSignature());
        StringBuilder.AppendLine("{");
        StringBuilder.AppendLine();
    }

    private void GenerateFooter() => StringBuilder.AppendLine("}");
}
