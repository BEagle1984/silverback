// Copyright (c) 2024 Sergio Aquilini
// This code is licensed under MIT license (see LICENSE file for details)

using System;
using System.Diagnostics.CodeAnalysis;
using System.Reflection;
using System.Text;
using MQTTnet.Client;
using Silverback.Tools.Generators.Common;

namespace Silverback.Tools.Generators.MqttConfigProxies;

internal sealed class BuilderGenerator
{
    private readonly Type _proxiedType;

    private readonly string _generatedClassName;

    private readonly StringBuilder _stringBuilder = new();

    public BuilderGenerator(string generatedClassName)
    {
        _proxiedType = typeof(MqttClientOptionsBuilder);
        _generatedClassName = generatedClassName;
    }

    public string Generate()
    {
        GenerateHeading();
        MapMethods();
        GenerateFooter();

        return _stringBuilder.ToString();
    }

    private static bool MustIgnore(string methodName) =>
        methodName
            is "WithProtocolVersion"
            or "WithCleanSession"
            or "WithCleanStart"
            or "WithKeepAliveSendInterval"
            or "WithNoKeepAlive"
            or "WithKeepAlivePeriod"
            or "WithClientId"
            or "WithWillMessage"
            or "WithWillDelayInterval"
            or "WithKeepAliveSendInterval"
            or "WithTopicAliasMaximum"
            or "WithMaximumPacketSize"
            or "WithReceiveMaximum"
            or "WithRequestProblemInformation"
            or "WithRequestResponseInformation"
            or "WithSessionExpiryInterval"
            or "WithUserProperty"
            or "WithCredentials"
            or "WithExtendedAuthenticationExchangeHandler"
            or "WithTcpServer"
            or "WithProxy"
            or "WithWebSocketServer"
            or "WithTls"
            or "WithConnectionUri"
            or "Build"
            or "WithWillPayload"
            or "WithWillQualityOfServiceLevel"
            or "WithWillTopic"
            or "WithWillRetain"
            or "WithWillContentType"
            or "WithWillCorrelationData"
            or "WithWillResponseTopic"
            or "WithWillUserProperty"
            or "WithTryPrivate"
            or "WithWillPayloadFormatIndicator"
            or "WithEndPoint"
            or "WithoutPacketFragmentation"
            or "WithoutThrowOnNonSuccessfulConnectResponse"
            or "WithProtocolType"
            or "WithTlsOptions"
            or "WithWillMessageExpiryInterval";

    private void GenerateHeading()
    {
        _stringBuilder.AppendLine("/// <content>");
        _stringBuilder.AppendLine($"///     The autogenerated part of the <see cref=\"{_generatedClassName}\" /> class.");
        _stringBuilder.AppendLine("/// </content>");
        _stringBuilder.AppendLine("[SuppressMessage(\"StyleCop.CSharp.MaintainabilityRules\", \"SA1402:File may only contain a single type\", Justification = \"Autogenerated all at once\")]");
        _stringBuilder.AppendLine("[SuppressMessage(\"StyleCop.CSharp.DocumentationRules\", \"SA1600:Elements should be documented\", Justification = \"Documented in other partial\")]");
        _stringBuilder.AppendLine("[SuppressMessage(\"StyleCop.CSharp.DocumentationRules\", \"SA1601:Partial elements should be documented\", Justification = \"Autogenerated\")]");
        _stringBuilder.AppendLine($"public partial class {_generatedClassName}");
        _stringBuilder.AppendLine("{");
    }

    [SuppressMessage("Globalization", "CA1308:Normalize strings to uppercase", Justification = "False positive, it makes no sense")]
    private void MapMethods()
    {
        foreach (MethodInfo method in ReflectionHelper.GetMethods(_proxiedType))
        {
            if (MustIgnore(method.Name))
                continue;

            _stringBuilder.Append($"    public partial {_generatedClassName} {method.Name}(");

            ParameterInfo[] parameters = method.GetParameters();

            for (int i = 0; i < parameters.Length; i++)
            {
                ParameterInfo parameter = parameters[i];
                _stringBuilder.Append($"{ReflectionHelper.GetTypeString(parameter.ParameterType, true)} {parameter.Name}");
                if (i < parameters.Length - 1)
                    _stringBuilder.Append(", ");
            }

            _stringBuilder.AppendLine(");");
            _stringBuilder.AppendLine();
        }
    }

    private void GenerateFooter() => _stringBuilder.AppendLine("}");
}
