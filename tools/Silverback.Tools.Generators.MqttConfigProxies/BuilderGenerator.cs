// Copyright (c) 2020 Sergio Aquilini
// This code is licensed under MIT license (see LICENSE file for details)

using System;
using System.Diagnostics.CodeAnalysis;
using System.Reflection;
using System.Text;
using MQTTnet.Client.Options;
using Silverback.Tools.Generators.Common;

namespace Silverback.Tools.Generators.MqttConfigProxies;

internal sealed class BuilderGenerator
{
    private readonly Type _proxiedType;

    private readonly string _generatedClassName;

    private readonly StringBuilder _stringBuilder = new();

    public BuilderGenerator()
    {
        _proxiedType = typeof(MqttClientOptionsBuilder);
        _generatedClassName = "MqttClientConfigurationBuilder";
    }

    public string Generate()
    {
        GenerateHeading();
        MapMethods();
        GenerateFooter();

        return _stringBuilder.ToString();
    }

    private static bool MustIgnore(string methodName) =>
        methodName
            is "WithProtocolVersion"
            or "WithCommunicationTimeout"
            or "WithCleanSession"
            or "WithKeepAliveSendInterval"
            or "WithNoKeepAlive"
            or "WithKeepAlivePeriod"
            or "WithClientId"
            or "WithWillMessage"
            or "WithWillDelayInterval"
            or "WithKeepAliveSendInterval"
            or "WithTopicAliasMaximum"
            or "WithMaximumPacketSize"
            or "WithReceiveMaximum"
            or "WithRequestProblemInformation"
            or "WithRequestResponseInformation"
            or "WithSessionExpiryInterval"
            or "WithUserProperty"
            or "WithCredentials"
            or "WithExtendedAuthenticationExchangeHandler"
            or "WithTcpServer"
            or "WithProxy"
            or "WithWebSocketServer"
            or "WithTls"
            or "WithPacketInspector"
            or "Build";

    private void GenerateHeading()
    {
        _stringBuilder.AppendLine("/// <content>");
        _stringBuilder.AppendLine($"///     The autogenerated part of the <see cref=\"{_generatedClassName}\" /> class.");
        _stringBuilder.AppendLine("/// </content>");
        _stringBuilder.AppendLine("[SuppressMessage(\"\", \"SA1649\", Justification = \"Autogenerated all at once\")]");
        _stringBuilder.AppendLine("[SuppressMessage(\"\", \"SA1402\", Justification = \"Autogenerated all at once\")]");
        _stringBuilder.AppendLine("[SuppressMessage(\"StyleCop.CSharp.DocumentationRules\", \"SA1600:Elements should be documented\", Justification = \"Generated code\")]");
        _stringBuilder.AppendLine("[SuppressMessage(\"StyleCop.CSharp.DocumentationRules\", \"SA1601:Partial elements should be documented\", Justification = \"Generated code\")]");
        _stringBuilder.AppendLine($"public partial class {_generatedClassName}");
        _stringBuilder.AppendLine("{");
    }

    [SuppressMessage("Globalization", "CA1308:Normalize strings to uppercase", Justification = "False positive, it makes no sense")]
    private void MapMethods()
    {
        foreach (MethodInfo method in ReflectionHelper.GetMethods(_proxiedType))
        {
            if (MustIgnore(method.Name))
                continue;

            _stringBuilder.Append($"    public partial {_generatedClassName} {method.Name}(");

            ParameterInfo[] parameters = method.GetParameters();

            for (int i = 0; i < parameters.Length; i++)
            {
                ParameterInfo parameter = parameters[i];
                _stringBuilder.Append($"{ReflectionHelper.GetTypeString(parameter.ParameterType, true)} {parameter.Name}");
                if (i < parameters.Length - 1)
                    _stringBuilder.Append(", ");
            }

            _stringBuilder.AppendLine(");");
            _stringBuilder.AppendLine();
        }
    }

    private void GenerateFooter()
    {
        _stringBuilder.AppendLine("}");
    }
}
