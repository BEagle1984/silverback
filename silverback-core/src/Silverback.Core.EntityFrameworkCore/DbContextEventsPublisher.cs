// Copyright (c) 2018-2019 Sergio Aquilini
// This code is licensed under MIT license (see LICENSE file for details)

using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.EntityFrameworkCore;
using Silverback.Domain;
using Silverback.Messaging.Messages;
using Silverback.Messaging.Publishing;
using Silverback.Util;

namespace Silverback.EntityFrameworkCore
{
    /// <summary>
    /// Exposes some extension methods for the <see cref="DbContext"/> that handle domain events as part 
    /// of the SaveChanges transaction.
    /// </summary>
    public static class DbContextEventsPublisher
    {
        /// <summary>
        /// Publishes the domain events generated by the tracked entities and then executes the provided save changes procedure.
        /// </summary>
        public static int ExecuteSaveTransaction(DbContext dbContext, Func<int> saveChanges, IPublisher publisher) =>
            ExecuteSaveTransaction(dbContext, () => Task.FromResult(saveChanges()), publisher, false).Result;

        /// <summary>
        /// Publishes the domain events generated by the tracked entities and then executes the provided save changes procedure.
        /// </summary>
        public static Task<int> ExecuteSaveTransactionAsync(DbContext dbContext, Func<Task<int>> saveChangesAsync, IPublisher publisher) =>
            ExecuteSaveTransaction(dbContext, saveChangesAsync, publisher, true);

        private static async Task<int> ExecuteSaveTransaction(DbContext dbContext, Func<Task<int>> saveChanges, IPublisher publisher,  bool async)
        {
            await PublishDomainEvents(dbContext, publisher, async);

            var saved = false;
            try
            {
                var result = await saveChanges();

                saved = true;

                await PublishEvent<TransactionCompleteEvent>(publisher, async);

                return result;
            }
            catch (Exception)
            {
                if (!saved)
                    await PublishEvent<TransactionAbortedEvent>(publisher, async);

                throw;
            }
        }

        private static async Task PublishDomainEvents(DbContext dbContext, IPublisher publisher, bool async)
        {
            var events = GetDomainEvents(dbContext);

            // Keep publishing events fired inside the event handlers
            while (events.Any())
            {
                if (async)
                    await events.ForEachAsync(publisher.PublishAsync);
                else
                    events.ForEach(publisher.Publish);

                events = GetDomainEvents(dbContext);
            }
        }

        private static List<IDomainEvent<IDomainEntity>> GetDomainEvents(DbContext dbContext)
        {
            var events = dbContext.ChangeTracker.Entries<IDomainEntity>()
                .SelectMany(e => e.Entity.DomainEvents)
                .ToList();

            // Clear all events to avoid firing the same event multiple times during the recursion
            events.ForEach(e => e.Source.ClearEvents());

            return events;
        }

        private static Task<int> SaveChanges(DbContext dbContext, bool acceptAllChangesOnSuccess, CancellationToken cancellationToken, bool async) =>
            async
            ? dbContext.SaveChangesAsync(acceptAllChangesOnSuccess, cancellationToken)
            : Task.FromResult(dbContext.SaveChanges(acceptAllChangesOnSuccess));

        private static async Task PublishEvent<TEvent>(IPublisher publisher, bool async)
            where TEvent : new()
        {
            if (async)
                await publisher.PublishAsync(new TEvent());
            else
                publisher.Publish(new TEvent());
        }
    }
}